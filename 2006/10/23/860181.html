<html>
<!-- Mirrored from archives.miloush.net/michkap/archive/2006/10/23/860181.html by HTTrack Website Copier/3.x [XR&CO'2014], Thu, 25 May 2017 00:42:39 GMT -->
<head><meta charset="utf-8" /><meta name="viewport" content="width=device-width" /><title>When _wcsnicmp can't hack it, CompareStringW delivers</title></head><body>
<h1>When _wcsnicmp can't hack it, CompareStringW delivers</h1>
<p><em>by Michael S. Kaplan, published on 2006/10/23 00:11 -07:00, original URI: http://blogs.msdn.com/michkap/archive/2006/10/23/860181.aspx</em></p>
<hr/> <!-- Archival Source: ProcessPostOld -->
<font face="Tahoma" size="3"> <p>The question that nikos asked in the microsoft.public.win32.programmer.international newsgroup was: </p> <blockquote><font face="Times New Roman,Times"> <p><font size="2">This occurs within code that searches text within files<br><br>If the text file (UTF-8) contains a bulgarian P (capital) and I try to match it with a lowercase p, _wcsnicmp "fails" (i.e. says strings are not identical but they ARE when case is not considered) whereas lstrmpi succeeds.<br><br>A bit more information:<br><br>The letter appears in the file as these bytes<br><font face="Consolas,Courier New,Lucida Console,Courier"><strong>CAPITAL P (UTF8): (EF BB BF) D0&nbsp; A0</strong></font><br><br>I load the file and convert to unicode as such:<br><font face="Consolas,Courier New,Lucida Console,Courier"><strong>MultiByteToWideChar(CP_UTF8, 0, ....);</strong></font><br><br>in unicode trim the same letter has the following encoding:<br></font><font size="2"><font face="Consolas,Courier New,Lucida Console,Courier"><strong>normal(UPPER) Разредка<br>0D642D0&nbsp;&nbsp; 20 04 30 04 37 04 40 04&nbsp;&nbsp; .0.7.@.<br>00D642D8&nbsp; 35 04 34 04 3A 04 30 04&nbsp; 5.4.:.0.<br>target (LOWER) разредка<br>00D64500&nbsp; 40 04 30 04 37 04 40 04&nbsp; @.0.7.@.<br>00D64508&nbsp; 35 04 34 04 3A 04 30 04&nbsp; 5.4.:.0.</strong></font><br><br>_wcsnicmp fails to see these strings as identical whereas lstrcmpi is ok. Clearly this has something to do with the locale CRT uses and WINAPI uses, but I didn't touch anything, the program is running with<br>the defaults of a unicode application for an english (UK) pc.<br><br>I could switch to lstrcmpi but my problem is that i search for text in a big buffer which isn't 0-terminated, so i'd have to copy it out and that would slow things down<br><br>any clues?<br>thanks<br>nikos</font></p></font></blockquote> <p>Now there are two separate issues here&nbsp;(the UTF-8 piece in the beginning is a red herring), and one note:</p> <p>The note is that text should be looked in the debugger as WORD values rather than BYTE values, to avoid the byte reversal seen above (the actual text has code point values of U+0420 U+0430 and so on). </p> <p><strong>Issue #1</strong> has to do with why </font><font face="Tahoma" size="3"><a href="http://msdn2.microsoft.com/en-us/library/chd90w8e.aspx">_wcsnicmp</a>'s results don't match <a href="http://msdn.microsoft.com/library/en-us/winui/winui/windowsuserinterface/resources/strings/stringreference/stringfunctions/lstrcmpi.asp">lstrcmpiW</a>'s. The reason is that <font face="Tahoma" size="3"><a href="http://msdn2.microsoft.com/en-us/library/chd90w8e.aspx">_wcsnicmp</a></font> is doing a lexicographic (binary) comparison, and <a href="http://msdn.microsoft.com/library/en-us/winui/winui/windowsuserinterface/resources/strings/stringreference/stringfunctions/lstrcmpi.asp">lstrcmpiW</a> is doing a linguistic comparison. If you really want to use the CRT here, then you should really switch to the CRT's linguistic comparison function, <a href="http://msdn2.microsoft.com/en-us/library/a697c234.aspx">_wcsnicoll</a>.</font></p> <p><font face="Tahoma" size="3">And then, once you take care of the first issue and have two functions with the same basic method of returning linguistically appropriate&nbsp;results, you have <strong>Issue #2</strong> to deal with: &nbsp;to make sure they are using appropriate locale values. With <a href="http://msdn.microsoft.com/library/en-us/winui/winui/windowsuserinterface/resources/strings/stringreference/stringfunctions/lstrcmpi.asp">lstrcmpiW</a>&nbsp;one has no choice -- in Windows &lt; Vista the thread locale is used, and then in Vista the user locale is now what is used. But with <a href="http://msdn2.microsoft.com/en-us/library/a697c234.aspx">_wcsnicoll</a>&nbsp;one must either set the locale appropriately (it starts up with the "C" locale which only handles A-Z/a-z casing, which will never match <a href="http://msdn.microsoft.com/library/en-us/winui/winui/windowsuserinterface/resources/strings/stringreference/stringfunctions/lstrcmpi.asp">lstrcmpiW</a>), or else call the new _wcsnicoll_l, which allows you to pass the locale you wish to use.</font></p> <p><font face="Tahoma" size="3">Now of course this points to what may be the best solution for a single function that will let you pass string length, ignore case, choose an appropriate locale,&nbsp;and work in different versions of Windows&nbsp;-- the master NLS collation function, <a href="http://msdn.microsoft.com/library/en-us/winui/winui/windowsuserinterface/resources/strings/stringreference/stringfunctions/comparestring.asp">CompareStringW</a>!</font></p> <p><font face="Tahoma" size="3">And <a href="http://msdn.microsoft.com/library/en-us/winui/winui/windowsuserinterface/resources/strings/stringreference/stringfunctions/lstrcmpi.asp">lstrcmpiW</a>&nbsp;is just a wrapper around <a href="http://msdn.microsoft.com/library/en-us/winui/winui/windowsuserinterface/resources/strings/stringreference/stringfunctions/comparestring.asp">CompareStringW</a>&nbsp;anyway, so if you almost liked the behavior of&nbsp;<a href="http://msdn.microsoft.com/library/en-us/winui/winui/windowsuserinterface/resources/strings/stringreference/stringfunctions/lstrcmpi.asp">lstrcmpiW</a> then the behavior of <a href="http://msdn.microsoft.com/library/en-us/winui/winui/windowsuserinterface/resources/strings/stringreference/stringfunctions/comparestring.asp">CompareStringW</a>&nbsp;should be perfect. :-)</font></p> <p><font face="Tahoma" size="3"></font>&nbsp;</p> <p><font size="3"><font face="Tahoma"><font color="#ff0080"><em>This post brought to you by</em> <strong><font size="6">Р</font></strong> <em>(<a href="http://www.fileformat.info/info/unicode/char/0420">U+0420</a>, a.k.a. CYRILLIC LETTER CAPITAL ER)</em></font></font></p></font>
<hr/><p><a id="860415" href="#860415">#</a> <strong>Adam</strong> on Monday, October 23, 2006 3:44 AM:</p><div style="margin-left: 1em"><p>&quot;But with _wcsnicoll one must either set the locale appropriately (it starts up with the &quot;C&quot; locale which only handles A-Z/a-z casing, which will never match lstrcmpiW)&quot;</p>
<p>Wha!?!</p>
<p>Why on earth does the locale not propagate to the C runtime properly? When setting the Windows locale, why isn't setlocale() also called (or faked) so that the C functions (like wcsnicoll()) use the same locale as the Windows functions?</p>
<p>Are you /trying/ to make the standard C functions look broken?</p></div>
<p><a id="860455" href="#860455">#</a> <strong>Michael S. Kaplan</strong> on Monday, October 23, 2006 3:51 AM:</p><div style="margin-left: 1em"><P>Me? No. </P>
<P>But I believe the standard defines the default behavior here. You have to call SetLocale to yourself to choose the behavior that matches the OS user settings.</P></div>
<p><a id="862990" href="#862990">#</a> <strong>Adam</strong> on Monday, October 23, 2006 10:38 AM:</p><div style="margin-left: 1em"><p>Apologies - by &quot;you&quot;, I meant MS.</p>
<p>Still, according to the POSIX standard[0] (which follows the C standard wherever the C standard defines behaviour) for how the locale is set up:</p>
<p>&quot;If the LANG environment variable is not set or is set to the empty string, the implementation-dependent default locale is used.&quot;</p>
<p>So, if the user does not set a locale in their environment (which most users will not), the implementation is free to use any suitable default locale. With windows, that would appear to me to be the current windows locale for the user. I'd have certainly thought it would be more appropriate than the &quot;C&quot; locale!</p>
<p>Further, while the user *can* use setlocale()[1] to change their locale for a program using the C runtime, I am not aware of *any* prohibition in the C (or even POSIX) standard on implementors providing their own high-level functions that call any other standard function (e.g. setlocale()) as one small part part of their operation. Especially if such a call/behaviour was documented. Frankly, I'd be absolutely amazed if this kind of prohibition existed.</p>
<p>(Note - many of the standard functions are defined as being not allowed to affect the shared state of some non-reentrant library functions, e.g. rand(), but again that is only a limitation of the functions defined by the standard)</p>
<p>[0] <a rel="nofollow" target="_new" href="http://www.opengroup.org/onlinepubs/007908799/xbd/envvar.html">http://www.opengroup.org/onlinepubs/007908799/xbd/envvar.html</a></p>
<p>[1] <a rel="nofollow" target="_new" href="http://www.opengroup.org/onlinepubs/007908799/xsh/setlocale.html">http://www.opengroup.org/onlinepubs/007908799/xsh/setlocale.html</a></p></div>
<p><a id="863039" href="#863039">#</a> <strong>Michael S. Kaplan</strong> on Monday, October 23, 2006 11:02 AM:</p><div style="margin-left: 1em"><p>Well, in that case the most likely reason would be the perf issue, I guess -- I mean, the &quot;C&quot; locale has the advantage of being much faster (at the cost of being somewhat linguistically lame).</p></div>
<p><a id="863598" href="#863598">#</a> <strong>Mihai</strong> on Monday, October 23, 2006 1:09 PM:</p><div style="margin-left: 1em"><p>From the C Standard (ISO 9899):</p>
<p>&lt;&lt;</p>
<p>At program startup, the equivalent of</p>
<p> &nbsp; &nbsp;setlocale(LC_ALL, &quot;C&quot;);</p>
<p>is executed.</p>
<p>&gt;&gt;</p>
<p>(section 7.11.1.1, &quot;The setlocale function&quot;)</p></div>
<p><a id="864466" href="#864466">#</a> <strong>Michael S. Kaplan</strong> on Monday, October 23, 2006 2:10 PM:</p><div style="margin-left: 1em"><p>Ah, I guess my initial recollection was correct! :-)</p></div>
<p><a id="865042" href="#865042">#</a> <strong>Adam</strong> on Monday, October 23, 2006 3:22 PM:</p><div style="margin-left: 1em"><p>Mihai &gt; Cool. But could you post some more context there? (C standard is expensive :( )</p>
<p>I'm pretty sure that this isn't mandated if LC_ALL (or any of the other language variables) is already set to something other than &quot;C&quot; in the environment. Why bother with the other environment vars if conforming apps are forced to override them all at program startup?</p>
<p>Seems odd.</p></div>
<p><a id="866407" href="#866407">#</a> <strong>Dean Harding</strong> on Monday, October 23, 2006 8:36 PM:</p><div style="margin-left: 1em"><p>Adam, C and POSIX are two different standards...</p>
<p>You can download drafts of ISO standards for free. For example, the latest working draft:</p>
<p><a rel="nofollow" target="_new" href="http://www.open-std.org/jtc1/sc22/wg14/www/docs/n1124.pdf">http://www.open-std.org/jtc1/sc22/wg14/www/docs/n1124.pdf</a></p>
<p>From there:</p>
<p>4. At program startup, the equivalent of</p>
<p>setlocale(LC_ALL, &quot;C&quot;);</p>
<p>is executed.</p>
<p>5. The implementation shall behave as if no library function calls the setlocale function.</p></div>
<p><a id="869922" href="#869922">#</a> <strong>Adam</strong> on Tuesday, October 24, 2006 2:33 PM:</p><div style="margin-left: 1em"><p>Dean,</p>
<p>Cheers for the link. I'm aware that C and POSIX are different. But the C standard is expensive and (as far as I *was* aware) not online, while POSIX (Single Unix Specification), which follows the C standard as much as it can, is. That's a great help though, thanks.</p>
<p>As for the &quot;The implementation shall behave as if no library function calls the setlocale() function&quot; - hmm......I'd always taken that to mean that the the implementation shall behave as if no *standard* library function calls the setlocale() function, but the standard does seem to be quite precise about using &quot;library&quot; and &quot;standard library&quot;. But srand() has a similar clause (7.20.2.2) which means that an implementation may not provide, say, a &quot;setgenseed(char *, unsigned)&quot; function that would set the PRNG algorithm and seed at the same time, which seems - strange.</p>
<p>I can understand forcing such guarantees on *standard* library functions - a strictly conforming program should be able to rely on, say, strtok(), not breaking on one system as part of their implementation of the library uses it but does not act as-if it did not.</p>
<p>But yeah, your reading seems right.</p>
<p>But still - that leads me to wonder about where &quot;the implementation&quot; ends, and where &quot;another library that happens to be supplied by the vendor&quot; begins. There's certainly no prohibition on 3rd party libraries acting as-if they call setlocale() or srand() or strtok(). At what point does a library that happens to be supplied by the compiler vendor (e.g. Win32, as supplied by MS), where all parts of the library are defined in separate (non-standard) headers, stop being part of &quot;the implementation&quot;?</p>
<p>Maybe I should head over to comp.lang.c.moderated or comp.std.c :)</p></div>
<hr/><p><em>go to <a id="newer" href="http://archives.miloush.net/michkap/archive/2006/10/23/864447.html" title="We missed International Caps Lock Day! :-(">newer</a> or <a id="older" href="http://archives.miloush.net/michkap/archive/2006/10/23/859331.html" title="How far will 5% coverage get you?">older</a> post, or back to <a href="http://archives.miloush.net/michkap/archive/index.html">index</a> or <a href="http://archives.miloush.net/michkap/archive/index.html#2006-10">month</a> or <a href="http://archives.miloush.net/michkap/archive/index.html#2006-10-23">day</a></em></p></body>
<!-- Mirrored from archives.miloush.net/michkap/archive/2006/10/23/860181.html by HTTrack Website Copier/3.x [XR&CO'2014], Thu, 25 May 2017 00:42:39 GMT -->
</html>