<html>
<!-- Mirrored from archives.miloush.net/michkap/archive/2006/10/20/847933.html by HTTrack Website Copier/3.x [XR&CO'2014], Thu, 25 May 2017 00:42:39 GMT -->
<head><meta charset="utf-8" /><meta name="viewport" content="width=device-width" /><title>Complex string mapping</title></head><body>
<h1>Complex string mapping</h1>
<p><em>by Michael S. Kaplan, published on 2006/10/20 10:03 -04:00, original URI: http://blogs.msdn.com/b/michkap/archive/2006/10/20/847933.aspx</em></p>
<hr/> <!-- Archival Source: ProcessPostNew -->
<FONT face=Tahoma size=3>
<P>So, the note I got the other day was: </P>
<BLOCKQUOTE><FONT face="Times New Roman,Times" size=2>
<P>Hi Michael,<BR><BR>This is Chris 􏰁􏰁􏰁􏰁􏰁􏰁, we met at lunch at the Unicode conference in San Francisco some months back. <BR><BR>...<BR><BR>I have a new question and judging from your blog, you might have the answer to this one as well. I'd like to set up our system to normalize text that enters our system to full-width kana and half-width latin. <BR><BR>I noticed that LCMapString provides the option to convert to full-width or half-width. However, it appears that it will convert everything to one or the other. Is there a way to get what I'm looking for without first analyzing the text to determine if it contains latin and/or kana before calling the function? or am I better off just implementing the conversion on my own? <BR><BR>Hope all is well,<BR><BR>Chris</FONT>&nbsp;</P></BLOCKQUOTE>
<P mce_keep="true">This is&nbsp;the sort of thing that could make a&nbsp;nice interview question&nbsp;if the candidate either had some familiarity with Unicode and you took a few minutes to explain the available, relevant&nbsp;NLS API functions. For today I'll just go ahead and answer it; if you want to treat it like an interview question then don't look at the code below. :-)</P>
<P mce_keep="true">Well, there is no way to automatically do everything in a single function call -- these flags in <A class="" href="http://msdn.microsoft.com/library/en-us/intl/nls_5s2v.asp" mce_href="http://msdn.microsoft.com/library/en-us/intl/nls_5s2v.asp">LCMapString</A> that make up <STRONG><A class="" href="http://archives.miloush.net/michkap/archive/2005/06/24/432121.html" mce_href="http://archives.miloush.net/michkap/archive/2005/06/24/432121.html">LCMapString's <EM>other</EM> job</A></STRONG> work on the whole string that is passed to the function, trying to map it&nbsp;as requested.</P>
<P mce_keep="true">However, you can make use of a single <A class="" href="http://msdn.microsoft.com/library/en-us/winui/winui/windowsuserinterface/resources/strings/stringreference/stringfunctions/getstringtypew.asp" mce_href="http://msdn.microsoft.com/library/en-us/winui/winui/windowsuserinterface/resources/strings/stringreference/stringfunctions/getstringtypew.asp">GetStringTypeW</A> call with the CT_CTYPE3 flag, after which you can scroll through the&nbsp;WORD&nbsp;array that is returned&nbsp;and use the data in to figure out what to convert and how. Something like the following hastily put together console app that will run just fine with a Japanese system locale (if it isn't then you may see the odd question mark in the output and would have to run under the debugger to prove to yourself that everything will work):</P>
<BLOCKQUOTE><B><FONT face="Consolas,Courier New,Lucida Console,Console" size=1>
<P mce_keep="true">#define _UNICODE<BR>#define UNICODE<BR>#include &lt;stdio.h&gt;<BR>#include &lt;windows.h&gt;</P>
<P mce_keep="true">void wmain(int argc, wchar_t *argv[ ]) {<BR>&nbsp;&nbsp;&nbsp; if(argc != 2) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <FONT color=#00cc00>// Some kind of usage message might be nice here<BR></FONT>&nbsp;&nbsp;&nbsp; } else {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int cch = lstrlenW(argv[1]);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; WORD * lpCharType = (WORD *)HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, cch * sizeof(WORD));<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if(NULL != lpCharType) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if(GetStringTypeW(CT_CTYPE3, argv[1], cch, lpCharType)) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; wchar_t * wzResults = (wchar_t *)HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, (cch + 1) * sizeof(WCHAR));<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if(NULL != wzResults) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int ich; <BR><BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for(ich = 0; ich &lt; cch; ich++) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if((lpCharType[ich] &amp; (C3_KATAKANA | C3_HALFWIDTH)) == (C3_KATAKANA | C3_HALFWIDTH)) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <FONT color=#00cc00>// Half width katakana; since NLS identified it, assume we can convert it<BR></FONT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; LCMapStringW(LOCALE_INVARIANT, LCMAP_FULLWIDTH, &amp;(argv[1][ich]), 1, &amp;wzResults[ich], 1);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; } else if((lpCharType[ich] &amp; (C3_ALPHA | C3_FULLWIDTH | C3_HIRAGANA | C3_KATAKANA)) == (C3_ALPHA | C3_FULLWIDTH)) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <FONT color=#00cc00>// Full width Alpha that is not Hiragana or Katakana; since NLS identified it, assume we can convert it<BR></FONT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; LCMapStringW(LOCALE_INVARIANT, LCMAP_HALFWIDTH, &amp;(argv[1][ich]), 1, &amp;wzResults[ich], 1);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; } else {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <FONT color=#00cc00>// Just copy over everything else, as is</FONT><BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; wzResults[ich] = argv[1][ich];<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; wprintf(L"Resulting string of size %d is: %s", cch, wzResults);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; HeapFree(GetProcessHeap(), 0, (LPVOID)wzResults);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; HeapFree(GetProcessHeap(), 0, (LPVOID)lpCharType);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<BR>&nbsp;&nbsp;&nbsp; }<BR>}&nbsp;</P></FONT></B></BLOCKQUOTE>
<P mce_keep="true">You can pick&nbsp;an interesting test string like <STRONG>ＱケｹQけ</STRONG>, which is &nbsp;<A class="" href="http://www.fileformat.info/info/unicode/char/ff31" mce_href="http://www.fileformat.info/info/unicode/char/ff31">U+ff31</A> <A class="" href="http://www.fileformat.info/info/unicode/char/30b1" mce_href="http://www.fileformat.info/info/unicode/char/30b1">U+30b1</A> <A class="" href="http://www.fileformat.info/info/unicode/char/ff79" mce_href="http://www.fileformat.info/info/unicode/char/ff79">U+ff79</A> <A class="" href="http://www.fileformat.info/info/unicode/char/0051" mce_href="http://www.fileformat.info/info/unicode/char/0051">U+0051</A> <A class="" href="http://www.fileformat.info/info/unicode/char/3051" mce_href="http://www.fileformat.info/info/unicode/char/3051">U+3051</A> or:</P>
<P mce_keep="true">FULLWIDTH LATIN CAPITAL LETTER Q<BR>KATAKANA LETTER KE<BR>HALFWIDTH KATAKANA LETTER KE<BR>LATIN CAPITAL LETTER Q<BR>HIRAGANA LETTER KE</P>
<P mce_keep="true">Now the small dance with C3_ALPHA, C3_HIRAGANA, and C3_KATAKANA is necessary for the reasons I mentioned in <STRONG><A class="" href="http://archives.miloush.net/michkap/archive/2005/09/12/463991.html" mce_href="http://archives.miloush.net/michkap/archive/2005/09/12/463991.html">Is Kana 'alphabetic' ? Depends on who you ask....</A></STRONG>.</P>
<P mce_keep="true">And of course you may have to decide what you wanted to do with numbers and/or punctuation (this code as written will just copy them as they are). </P>
<P mce_keep="true">But you get the idea. </P>
<P mce_keep="true">In theory if you have multiple characters of the same type in a row you could try to call <A class="" href="http://msdn.microsoft.com/library/en-us/intl/nls_5s2v.asp" mce_href="http://msdn.microsoft.com/library/en-us/intl/nls_5s2v.asp">LCMapString</A> with larger string, but in practice the time to do all that checking may not be worth the effort. You can play with it, and see what you think (though if you want to provide a sample that proves such an optimization then be sure you include your profile numbers that proves it's faster!).</P>
<P mce_keep="true">&nbsp;</P>
<P mce_keep="true"><FONT color=#ff00ff><EM>This post brought to you by</EM> <STRONG><FONT size=6>ｹ</FONT></STRONG> <EM>(<A class="" href="http://www.fileformat.info/info/unicode/char/ff79" mce_href="http://www.fileformat.info/info/unicode/char/ff79">U+ff79</A>, a.k.a. HALFWIDTH KATAKANA LETTER KE)</EM></FONT></P></FONT>
<hr/><p><a id="849928" href="#849928">#</a> <strong>Haali</strong> on 20 Oct 2006 1:12 PM:</p><div style="margin-left: 1em"><p>A minor problem: PSDK documentation doesn't list HEAP_ZERO_MEMORY as a valid flag for HeapFree().</p></div>
<p><a id="850357" href="#850357">#</a> <strong>Michael S. Kaplan</strong> on 20 Oct 2006 4:31 PM:</p><div style="margin-left: 1em"><P>I think I am just always in the habit of passing the same flags to both functions! :-) </P>
<P>But you are right, it is not very meaningful there, unless maybe it zeroes out the memory as a part of the free as a security thing?<BR><BR>In any case, fixed now....</P></div>
<p><a id="851826" href="#851826">#</a> <strong>Mihai</strong> on 20 Oct 2006 10:27 PM:</p><div style="margin-left: 1em"><p>Interview question: what is wrong with the code above?</p>
<p>Hint: try ﾍﾟﾍﾞ &lt;U+FF8D U+FF9F U+FF8D U+FF9E&gt;</p></div>
<p><a id="851841" href="#851841">#</a> <strong>Michael S. Kaplan</strong> on 20 Oct 2006 10:40 PM:</p><div style="margin-left: 1em"><P>Hmmm...works just fine for me; </P>
<P>&nbsp; HALFWIDTH KATAKANA LETTER HE<BR>&nbsp; HALFWIDTH KATAKANA SEMI-VOICED SOUND MARK<BR>&nbsp; HALFWIDTH KATAKANA LETTER HE<BR>&nbsp; HALFWIDTH KATAKANA VOICED SOUND MARK</P>
<P>becomes</P>
<P>&nbsp; KATAKANA LETTER HE<BR>&nbsp; KATAKANA-HIRAGANA SEMI-VOICED SOUND MARK<BR>&nbsp; KATAKANA LETTER HE<BR>&nbsp; KATAKANA-HIRAGANA VOICED SOUND MARK</P>
<P>just as I would expect?</P></div>
<p><a id="851849" href="#851849">#</a> <strong>Michael S. Kaplan</strong> on 20 Oct 2006 10:43 PM:</p><div style="margin-left: 1em"><p>Or </p>
<p>ﾍﾟﾍﾞ &nbsp;-----&gt; &nbsp; ヘ゜ヘ゛</p>
<p>if you want characters, and</p>
<p>U+ff8d U+ff9f U+ff8d U+ff9e &nbsp;--&gt; &nbsp;U+30d8 U+309c U+30d8 U+309b </p>
<p>if you want code points....</p>
</div>
<p><a id="853987" href="#853987">#</a> <strong>Mihai</strong> on 21 Oct 2006 8:38 PM:</p><div style="margin-left: 1em"><p>You should get ぺべ &lt;U+307A U+3079&gt;</p>
<p>This is what you get if you call LCMapString on the full buffer, instead of doing it one codepoint at the time.</p>
<p>One of the basic i18n things: process full strings, not one character/codepoint at the time :-)</p>
<p>Looks like you are having a bad day :-)</p></div>
<p><a id="853997" href="#853997">#</a> <strong>Michael S. Kaplan</strong> on 21 Oct 2006 8:43 PM:</p><div style="margin-left: 1em"><p>Ah, but that doesn't meet the initial requirements of the halfwidth Latin mixed in, unless you add the logic to separate the string into runs, handling each &quot;run&quot; separately....</p>
<p>Did you have an algorithm you wanted tp share for that part? :-)</p>
</div>
<p><a id="854261" href="#854261">#</a> <strong>Mihai</strong> on 21 Oct 2006 10:46 PM:</p><div style="margin-left: 1em"><p>&lt;&lt;unless you add the logic to separate the string into runs, handling each &quot;run&quot; separately....&gt;&gt;</p>
<p>Now, that's and interviw answer :-)</p>
<p>I might have something, but not ready to publish. Because I have to find it first :-)</p>
<p>It is something I have wrote many-many years ago, to convert software glossaries from narow to wide. It was when the Windows UI moved from narow (Win 3.x) to wide (Win 95).</p>
<p>Only 10 years :-)</p>
<p>In fact, it is probably beter if I just rewrite it. This way I can also be sure is legal :-)</p></div>
<p><a id="854685" href="#854685">#</a> <strong>Michael S. Kaplan</strong> on 22 Oct 2006 1:53 AM:</p><div style="margin-left: 1em"><p>One could also go the other direction and just convert the whole string to full width and then convert the alpha that is not kana to half width, though that would mean two passes across the string by NLS and one for the user....</p>
</div>
<p><a id="859063" href="#859063">#</a> <strong>Mihai</strong> on 22 Oct 2006 10:55 PM:</p><div style="margin-left: 1em"><p>I have also thought about it.</p>
<p>But should be a bit more than &quot;the alpha that is not kana,&quot; because wide $, wide # (and all the other wide Latin stuff that is in the FF01-FF5E range and is not alpha) should also be converted to narow.</p>
<p>Then we have another problem at FFE0, with the question &quot;what about the wide Yen?&quot; which is a problem in general :-)</p></div>
<p><a id="859676" href="#859676">#</a> <strong>Michael S. Kaplan</strong> on 23 Oct 2006 1:02 AM:</p><div style="margin-left: 1em"><p>Or perhaps it needs to be context sensitive -- wide when next to the Kana and narrow when not?</p>
</div>
<p><a id="863343" href="#863343">#</a> <strong>Mihai</strong> on 23 Oct 2006 12:03 PM:</p><div style="margin-left: 1em"><p>&lt;&lt;wide when next to the Kana and narrow when not&gt;&gt;</p>
<p>And now we have to see how to define &quot;next to the Kana&quot; :-)</p>
<p>What if they are in between Kana and Latin? :-)</p>
<p>This proves how an apparently simple problem proves to be quite complex. Good interview question, no doubt.</p></div>
<hr/><p><em>go to <a id="newer" href="http://archives.miloush.net/michkap/archive/2006/10/21/852262.html" title="It might be getting a little less embarrassing">newer</a> or <a id="older" href="http://archives.miloush.net/michkap/archive/2006/10/20/846755.html" title="Over One Million Served!">older</a> post, or back to <a href="http://archives.miloush.net/michkap/archive/index.html">index</a> or <a href="http://archives.miloush.net/michkap/archive/index.html#2006-10">month</a> or <a href="http://archives.miloush.net/michkap/archive/index.html#2006-10-20">day</a></em></p></body>
<!-- Mirrored from archives.miloush.net/michkap/archive/2006/10/20/847933.html by HTTrack Website Copier/3.x [XR&CO'2014], Thu, 25 May 2017 00:42:39 GMT -->
</html>