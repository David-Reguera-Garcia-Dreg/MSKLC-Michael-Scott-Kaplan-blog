<html>
<!-- Mirrored from archives.miloush.net/michkap/archive/2006/01/13/512408.html by HTTrack Website Copier/3.x [XR&CO'2014], Thu, 25 May 2017 00:42:40 GMT -->
<head><meta charset="utf-8" /><meta name="viewport" content="width=device-width" /><title>Some date conversions are evil in other ways</title></head><body>
<h1>Some date conversions are evil in other ways</h1>
<p><em>by Michael S. Kaplan, published on 2006/01/13 00:31 -08:00, original URI: http://blogs.msdn.com/michkap/archive/2006/01/13/512408.aspx</em></p>
<hr/> <!-- Archival Source: ProcessPostOld -->
<P><FONT face=Tahoma>One of the very first posts I ever did in this blog was <a href="http://archives.miloush.net/michkap/archive/2004/11/26/270769.html"><STRONG>'Evil date parsing', Parse, and ParseExact</STRONG></A>.</FONT></P>
<P><FONT face=Tahoma>In it I talked about the heritage of evil date parsing that dated all the way back to early versions of Visual Basic.</FONT></P>
<P><FONT face=Tahoma>The method of simply trying to fit the value into a date no matter what has a lot of bad things to say about it, though it does have some positive moments, such as one I was asked about the other day.</FONT></P>
<P><FONT face=Tahoma>Someone wanted to take the Hijri date '30-10-1426' and use it to do some work with. Easy to do in VB 6.0 or VBA 6.x with simple code like the following:</FONT></P>
<BLOCKQUOTE dir=ltr style="MARGIN-RIGHT: 0px">
<BLOCKQUOTE dir=ltr style="MARGIN-RIGHT: 0px">
<P><FONT face=Tahoma><FONT face="Courier New"><STRONG>VBA.Calendar = vbCalHijri<BR>dte = CDate("30-10-1426")<BR>Debug.Print dte</STRONG></FONT></FONT></P></BLOCKQUOTE></BLOCKQUOTE>
<P><FONT face=Tahoma>The value returned in the debug window was 11/1/1426. Oops! And this is especially an oops because reportedly this was one of those months where the moon was not spotted until the next day, a fact that Windows knows nothing about since the historical data is not kept. In the end, VB/VBA/COM are all smart enough to increment to the next month (where smart is defined here as not throwing an error).</FONT></P>
<P><FONT face=Tahoma>But it gets worse.</FONT></P>
<P><FONT face=Tahoma>The person asking the question was using SQL Server's support (which I talked about a bit <a href="http://archives.miloush.net/michkap/archive/2005/04/26/412398.html">here</A>), running a query like this:</FONT></P>
<BLOCKQUOTE dir=ltr style="MARGIN-RIGHT: 0px">
<BLOCKQUOTE dir=ltr style="MARGIN-RIGHT: 0px">
<P><FONT face="Courier New">select * from dbo.tblAppointments <BR>where convert(datetime, colDate, 131) <BR>between convert(datetime, '1-10-1426', 131) <BR>and convert(datetime, '30-10-1426', 131)</FONT></P></BLOCKQUOTE></BLOCKQUOTE>
<P><FONT face=Tahoma>The problem here is that although SQL Server uses the same basic algorithm for its Hijri conversions, it does not forgive anything outside of its known range. So it returns an error, with text something like "<FONT face="Courier New" color=#ff0000 size=2><STRONG>The conversion of a char data type to a datetime data type resulted in an out-of-range datetime value.</STRONG></FONT>"</FONT></P>
<P><FONT face=Tahoma>When comparing these two sets of results that are both technically not correct, i</FONT><FONT face=Tahoma>t does kind of take the phrase 'choosing the lesser of two evils' to a whole new level, if you ask me. In this case, however, with the armed with the "pragmatic" knowledge&nbsp;that the date value is actually legal, I guess I would prefer the VB/VBA/COM behavior in this case, since it does not cause the program to stop just because there is&nbsp;a limitation due to the lack of historical knowledge of prior moon sightings. At least the range checking would have worked....</FONT></P>
<P><FONT face=Tahoma>On the other hand, I am sure&nbsp;you can hypothesize about cases where letting it continue might be more evil. So sometimes the SQL Server behavior might seem better.</FONT></P>
<P><FONT face=Tahoma>It all depends on how you look at it, I guess.</FONT></P>
<P><FONT face=Tahoma>What do you think is the better generic behavior in this less than ideal situation?</FONT></P>
<P><FONT face=Tahoma></FONT>&nbsp;</P>
<P><FONT face=Tahoma color=#ff1493><EM>This post brought to you by</EM> "<FONT size=6>Ú‡</FONT>" <EM>(<A href="http://www.fileformat.info/info/unicode/char/0687">U+0687</A>, a.k.a. ARABIC LETTER TCHEHEH)</EM></FONT></P>
<hr/><p><a id="512427" href="#512427">#</a> <strong>Maurits</strong> on Friday, January 13, 2006 3:54 AM:</p><div style="margin-left: 1em">If the computer doesn't know for sure, it should own up to it and say so.<br><br>Guessing is bad.</div>
<p><a id="512460" href="#512460">#</a> <strong>Universalis</strong> on Friday, January 13, 2006 6:27 AM:</p><div style="margin-left: 1em">Some of the trouble comes from the assumption that SQL Server should be given valid dates in its search arguments. This seems unduly restrictive. For example, if you ask me to list the dates between 0 March 2006 and 0/0/2007, the answer is simple, obvious, straightforward and unambiguous, even though the dates themselves aren't valid. The same applies for dates between 1-10-1426 and 30-10-1426.<br><br>Incidentally, do Muslims really have more birthdays than the rest of us? Will a Muslim celebrate his 100th birthday after only having lived 97 years?</div>
<p><a id="512518" href="#512518">#</a> <strong>Michael S. Kaplan</strong> on Friday, January 13, 2006 10:23 AM:</p><div style="margin-left: 1em">Indeed Universalis, and this is my conundrum on the issue!<br><br>The big worry could be similar to people being born on February 29th, a day that does not exist in over 75% of the years. :-)</div>
<p><a id="512578" href="#512578">#</a> <strong>Maurits</strong> on Friday, January 13, 2006 12:11 PM:</p><div style="margin-left: 1em">&gt; list the dates between 0 March 2006 and 0/0/2007<br><br>You can do this with DatePart, as a radix search...<br><br>CREATE PROCEDURE DatesBetween<br>(<br>@StartYear int,<br>@StartMonth int,<br>@StartDay int,<br>@EndYear int,<br>@EndMonth int,<br>@EndDay int<br>)<br><br>SELECT date<br>FROM Dates -- need to build this table first<br>WHERE<br>DatePart(year, date) BETWEEN @StartYear AND @EndYear AND<br>(<br>__ DatePart(year, date) &gt; @StartYear OR<br>__ DatePart(month, date) &gt; @StartMonth OR<br>__ (<br>_____ DatePart(month, date) = @StartMonth AND<br>_____ DatePart(day, date) &gt;= @StartDay<br>__ )<br>) AND<br>(<br>__ DatePart(year, date) &lt; @EndYear OR<br>__ DatePart(month, date) &lt; @EndMonth OR<br>__ (<br>_____ DatePart(month, date) = @EndMonth AND<br>_____ DatePart(day, date) &lt;= @EndDay<br>__ )<br>)<br>order by<br>__ date<br><br>Erroring on invalid datetimes is a feature, in my opinion.</div>
<p><a id="512617" href="#512617">#</a> <strong>Nick Lamb</strong> on Friday, January 13, 2006 1:09 PM:</p><div style="margin-left: 1em">SQL Server gets this right (as well it might, this is an expected and iirc required feature of SQL). We also know that fixing this in MySQL was considered a significant improvement.<br><br>Everything that faces toward the programmer (including language features in e.g. SQL, web services and operating sytem APIs) should fail with diagnostics. That means at least a meaningful error code along with the input that caused the problem.<br><br>The documentation for such functions should clearly state what basis is used for the date-time representation or for both representations if the function performs an explicit conversion - and it should give an example of an error. Programmers can build on this strong foundation, by handling errors if they occur, and by avoiding errors where possible elsewhere in the system.<br><br>What's actually desirable in user-facing applications is a completely separate issue. For a start, (real scenario) what do you think  should happen with a date of birth from medical records which reads &quot;Winter 1923/4&quot; ? Individual applications will need careful consideration and thorough testing, APIs with arbitrary defaults don't help much if at all.</div>
<p><a id="512620" href="#512620">#</a> <strong>Michael S. Kaplan</strong> on Friday, January 13, 2006 1:22 PM:</p><div style="margin-left: 1em">Hi Nick --<br><br>I usually would agree with you (after all, I have been calling the 'feature' in VBA evil for a long time -- and I do not tend to be in favor of things I consider 'evil.'<br><br>In this particular case, however, it is not quite so black and white to me. Because it *was* a valid date and an inability to recognize that fact is a flaw. How serious is that flaw is hard to say, but there are definitely negative conseqences for developers and users.</div>
<p><a id="512622" href="#512622">#</a> <strong>Michael S. Kaplan</strong> on Friday, January 13, 2006 1:23 PM:</p><div style="margin-left: 1em">Hi Maurits --<br><br>But in this case, the date is actually valid. Swallowing dates, refusing to admit thedir existence in an ostrich-like, head-in-the-sand maneuver is also a problem....</div>
<p><a id="512626" href="#512626">#</a> <strong>Maurits</strong> on Friday, January 13, 2006 1:37 PM:</p><div style="margin-left: 1em">Indeed.  There are more than two kinds of behavior, and their desirability is as follows:<br><br>1) Correctly reject all invalid dates.  Accept all valid dates.<br>2) Correctly reject most invalid dates.  Accept move valid dates. (Bug, but forgivable.  Fix it or work around it.)<br>3) Accept anything.<br>4) Abandon the datetime format.<br><br>What does SQL3 have to say about datetime formats?<br><br>Frankly, I don't see Hijri support as a priority.  I'd much rather have time zone support in datetime data types.  There's a whole slew of problems on any computer with daylight savings time if you care about data that happens at the time change.</div>
<p><a id="512628" href="#512628">#</a> <strong>Maurits</strong> on Friday, January 13, 2006 1:38 PM:</p><div style="margin-left: 1em">Er, &quot;Accept move valid dates&quot; should be &quot;Accept most valid dates&quot;</div>
<p><a id="512642" href="#512642">#</a> <strong>Michael S. Kaplan</strong> on Friday, January 13, 2006 1:58 PM:</p><div style="margin-left: 1em">I'll be talking more about time zones very soon.... but I don't want to tell anyone that their system is not important, especially if we claim any level of support....</div>
<p><a id="512676" href="#512676">#</a> <strong>Maurits</strong> on Friday, January 13, 2006 3:10 PM:</p><div style="margin-left: 1em">That's the crux of the matter... what is the cost of supporting the feature, and what is the benefit?<br><br>I must disagree that the VB/VBA behavior is &quot;smart&quot; - I think any Hijri calendar user would agree with me*.  It's indeed very similar to the 2/29 issue you bring up.  How would a Gregorian calendar user feel if their appointment they made for 2/29 showed up on 3/1 instead?  If they got an error entering the appointment they could resort to other means of reminding themselves instead of silently being a day late.<br><br>* If there are any Hijri users around that disagree, please chime in...</div>
<p><a id="512694" href="#512694">#</a> <strong>Michael S. Kaplan</strong> on Friday, January 13, 2006 3:47 PM:</p><div style="margin-left: 1em">I don't think I seriously called it smart, and I am on record on saying it is evil.<br><br>In this case it only does something smarter than denying the existence if a day somewhat by accident (and it still misrepresents the day, anyway).<br><br>The Feb. 29th issue is not an issue, unless it is not a leap year. And I would rather it show up on the day after the 28th than NEVER. :-)</div>
<p><a id="512703" href="#512703">#</a> <strong>Maurits</strong> on Friday, January 13, 2006 4:04 PM:</p><div style="margin-left: 1em">OK, then I agree with you that it is evil and not necessarily smart. :)<br><br>With 2/29 I was trying to make an analogy.  There is software out there that mishandles leap years.  I personally ran into one that skipped reminders for 2/29/2000.<br><br>If the choice is between<br><br>1) Accept the appointment for 2/29/2000 but show it on 3/1/2000 because 2/29/2000 is an invalid date and I don't want to rock the boat or anything<br>and<br>2) Reject the appointment for 2/29/2000 with an &quot;invalid date&quot; error because everyone knows centuries are not leap years<br><br>I'll pick 2).  They're both wrong, but to me, 2) is &quot;more desireable&quot; wrong behavior.</div>
<p><a id="512733" href="#512733">#</a> <strong>Nick Lamb</strong> on Friday, January 13, 2006 5:54 PM:</p><div style="margin-left: 1em">&quot;In this particular case, however, it is not quite so black and white to me. Because it *was* a valid date&quot;<br><br>To me it /is/ black and white but you have to be careful to define your date-time system up-front. It's not enough to say  &quot;Hijri calendar&quot; because this doesn't provide enough information. So you need to pick a specific calendar definition. Despite the political problems, I'd imagine that Windows would have to go with one [or more] of the pre-calculated calendars, which are accepted by some but not all Muslim authorities, and are based on astronomical data rather than reports of moon sightings.<br><br>So, assuming that this is all defined somewhere, 30-10-1426 is either valid or invalid, no grey areas, just like the 29th of February in any particular year of a Gregorian calendar. If it's not defined yet then someone had best go make some decisions and write them down.<br><br>As I said before, user-facing applications are a different kettle of fish. An application for scholars or followers of Islam may need to automatically transform the 30th day internally, as well as handling variable day lengths etc. But programmers whose users care will know about this, or if they don't they'll soon find out. Attempts to do it all without the programmer knowing are unlikely to succeed IMNSHO.</div>
<p><a id="512747" href="#512747">#</a> <strong>Maurits</strong> on Friday, January 13, 2006 6:55 PM:</p><div style="margin-left: 1em">All right, 'fess up... what's the Kuwaiti algorithm?<br><br><a rel="nofollow" target="_new" href="http://en.wikipedia.org/wiki/Kuwaiti_algorithm">http://en.wikipedia.org/wiki/Kuwaiti_algorithm</a><br><br>If a calendar is nondeterministic, there may not be an elegant solution other than to include month lengths in Windows Update patches.</div>
<p><a id="512791" href="#512791">#</a> <strong>Michael S. Kaplan</strong> on Friday, January 13, 2006 9:47 PM:</p><div style="margin-left: 1em">I was actually involved with the topic Dr. International wrote to cover this issue (referenced by the Wikipedia article). AFAIK, the article's claims are not true.</div>
<p><a id="512818" href="#512818">#</a> <strong>Marvin</strong> on Saturday, January 14, 2006 1:09 AM:</p><div style="margin-left: 1em">What a waste of bandwidth (in this otherwise interesting blog)! How can so many intelligent people seriously discuss this issue? You could also try to discuss methods of calculating the exact number of angels that can fit on a pinhead. A modern calendar that relies on moon sightings is simply moronic. If some people want to use it, they have bigger problems than SQL server bahvior. My suggestion to them would be to adopt a different calendar as all other peoples did in the past. If Microsoft wants to earn a few additional bucks by trying to accomodate these people... well good luck to Microsoft but I'd rather go and read about measuring angels on a pinhead.<br></div>
<p><a id="512823" href="#512823">#</a> <strong>Michael S. Kaplan</strong> on Saturday, January 14, 2006 2:10 AM:</p><div style="margin-left: 1em">Hi Marvin --<br><br>Of course I am speaking for myself and not Microsoft, but I don't tend to consider anyone's religious beliefs to be moronic. The specific questions that it raises here (and how two different products handle the same algorithm) are interesting whether one believes or not....</div>
<p><a id="512944" href="#512944">#</a> <strong>Marvin</strong> on Saturday, January 14, 2006 4:05 PM:</p><div style="margin-left: 1em">You misunderstood me. A calendar as used for business and information interchange is not the same as a religious calendar. I can calculate the time when I should sacrifice newborns to Moloch any way I want, including sigthing the moon, spitting into a puddle or standing on my head and counting to a hundred. This has nothing to do with the fact that if I want to communicate dates and times to somebody else I need to adopt some deterministic way to do so that can easily be replicated and used by other people. More so if I want to use computers to help me to determine and communicate dates. Note this way doesn't have to be the Gregorian calendar or any other existing one. <br>What is moronic is people trying to use a religious calendar for business and IT purposes.<br>As for the engineering problems I don't see any big ones here. You have two &quot;functions&quot; with different contracts. One considers a certain input invalid while another doesn't. Whichever behavior makes sense depends on user's requirements. If ligitimate use cases exist for both behaviors then an API author should provide two functions or allow to change behavior of a single one through some option. This situation is as old as programming itself. Where is the problem? <br></div>
<p><a id="512945" href="#512945">#</a> <strong>Michael S. Kaplan</strong> on Saturday, January 14, 2006 4:19 PM:</p><div style="margin-left: 1em">Yes Marvin,<br><br>But if you look at what I said, there is honestly no way to tell from it what the purpose of the SQL Server application is -- perhaps it is for a religious organization?<br><br>I guess you may not see the conundrum here, or think there is anything interesting in this post. And that is fine -- you can certainly skip anything you don't find interesting (I know I do!).<br><br>But I know from the fact that there are people who had problems in the firt place that prompted a question and from the email I have received from this one that there at least a few others who also thought so too. I know that I can live with that.... :-)</div>
<p><a id="512951" href="#512951">#</a> <strong>Marvin</strong> on Saturday, January 14, 2006 4:48 PM:</p><div style="margin-left: 1em">Re: &quot;there is honestly no way to tell from it what the purpose of the SQL Server application is -- perhaps it is for a religious organization&quot;<br><br>Then it uses the wrong technology. The 'convert' function is entirely inappropriate to handle things like dates of sacrifices. If I wanted to handle custom non-deterministic calendars (based on reign of king Arthur for example with a new day starting when a bird first heard singing) I'll get the corresponding tables and write a conversion rutine based on my interpretation of holly scriptures. <br><br>Re: &quot;But I know from the fact that there are people who had problems in the firt place... &quot;<br><br>Of course they do. And the solution for them is to use a good calendar to begin with rather than trying to force computers to guess when the bird first sung.<br><br>Long before computers many different peoples of different religions had realized this simple point and changed their secular calendars (while often retaining old ones for religious purposes). So, sorry, but in the year 2006 anybody who still has such problems should blame only himself.<br></div>
<p><a id="512957" href="#512957">#</a> <strong>Michael S. Kaplan</strong> on Saturday, January 14, 2006 5:29 PM:</p><div style="margin-left: 1em">I guess we will have to agree to disagree. Since I don't think I am wrong, I don't think those others are wrong, and even if I did I probably would not approach it quite the way that you do (it is a tad judgmental for my tastes, but that is anyone's right)....<br><br>But to get back to the actual topic -- we have one algoruthm here that approximates a calendar in use, and there is this particular historical issue that MS products do not currently support. This makes it interesting (to some) to look at the different manifestations that the non-support takes. If that is not interesting to you then feel free to move along to another post. :-)</div>
<p><a id="513027" href="#513027">#</a> <strong>Maurits</strong> on Sunday, January 15, 2006 1:05 AM:</p><div style="margin-left: 1em">As a counterpoint to Marvin's rather abrasive posts, I'll point out information I consciously withheld either... the Gregorian calendar has a little bit of nondeterminism too, the &quot;leap second.&quot;  So DateDiff(second, '1/1/2050', '1/1/2051') is not knowable until it is decided whether to have leap seconds in the year 2050.</div>
<p><a id="513083" href="#513083">#</a> <strong>Michael S. Kaplan</strong> on Sunday, January 15, 2006 11:54 AM:</p><div style="margin-left: 1em">But I would not mind being a second (or a minute or an hour) late for meetings. :-) And of course there is an alternate calendar that is provided in .NET 2.0 and Vista to cover the Umm-Al Qurah (Saudi civil) calendar, as a conscious attempt to allow matters that do not relate to religious issues to have a bit more determinism....</div>
<p><a id="513087" href="#513087">#</a> <strong>orcmid</strong> on Sunday, January 15, 2006 12:46 PM:</p><div style="margin-left: 1em">Back in the day when Turbo Pascal on CP/M-80 was a hobbyist's dream development environment, I remember cobbling up a small set of date conversions that would work between day numbers (signed ints relative to something like January 1, 1980 or thereabouts) and {yyyy, mm, dd} triples.  <br><br>What thrilled me was I found a way to get both strict and sloppy in the same kit, and it even helped with testing and debugging the little functions.<br><br>First, the sloppy functions would create the proper day numbers from (yyyy, mm, dd+7), (yyyy, mm+1, dd) and so on.  That is, daynumber(yyyy, 2, 28+3) would yield the day number for March 2 or March 3, and so on.  These simple manipulations, as we know, are all quite handy.<br><br>The strictness, used after receiving input date that is supposed to be valid, was accomplished simply by converting to the daynumber and back to the calendar date.  If it didn't agree with the input, the initially-given date was invalid. Solved the leap-year challenge, proper days in months, and whatever else.  It was done with tables and the usual congruences, but you got strictness when it mattered and you had relaxed rules when that made date manipulation work well.  <br><br>daynumber(yyyy, mm, dd) wasn't unreasonably flexible, and it did check ranges on its inputs so that you couldn't go to awful extremes.  <br><br>The daynumber(yyyy+k, mm, dd+j) cases all worked well but what you could do to mm was a bit more restricted, because I was a bit stingy with the table for the number of days preceding each month in a given type of year.  That is no longer a problem and it would be fun to do a more-comprehensive one, but still for a limited range of practical dates.</div>
<p><a id="513237" href="#513237">#</a> <strong>Marvin</strong> on Monday, January 16, 2006 2:21 AM:</p><div style="margin-left: 1em">Maurits,<br><br>What you have written is not a counterpoint. The leap second is entirely inconsequential in both business and IT (which is what we are all talking about). It is routinely ignored or handled incorrectly by almost all software out there and nobody even notices. The few people who *do* care like timekeepers themselves, scientists and some others are exactly in the same postion as the religious people. They need to use special software and special algorithms. <br>But I do agree that leap second is a bad thing. Keeping the calendar in precise sync with earth rotations seems like an atavism to me. I suspect it will be abandoned when we will have colonies on Mars and Moon ;-)<br></div>
<hr/><p><em>go to <a id="newer" href="http://archives.miloush.net/michkap/archive/2006/01/14/512530.html" title="Brother, can you spare a time[zone]?">newer</a> or <a id="older" href="http://archives.miloush.net/michkap/archive/2006/01/13/512390.html" title="It can be custom OR it can be internationally appropriate">older</a> post, or back to <a href="http://archives.miloush.net/michkap/archive/index.html">index</a> or <a href="http://archives.miloush.net/michkap/archive/index.html#2006-01">month</a> or <a href="http://archives.miloush.net/michkap/archive/index.html#2006-01-13">day</a></em></p></body>
<!-- Mirrored from archives.miloush.net/michkap/archive/2006/01/13/512408.html by HTTrack Website Copier/3.x [XR&CO'2014], Thu, 25 May 2017 00:42:40 GMT -->
</html>