<html>
<!-- Mirrored from archives.miloush.net/michkap/archive/2006/01/20/515238.html by HTTrack Website Copier/3.x [XR&CO'2014], Thu, 25 May 2017 00:42:40 GMT -->
<head><meta charset="utf-8" /><meta name="viewport" content="width=device-width" /><title>Getting the characters in a code page (the code)</title></head><body>
<h1>Getting the characters in a code page (the code)</h1>
<p><em>by Michael S. Kaplan, published on 2006/01/20 00:01 -08:00, original URI: http://blogs.msdn.com/michkap/archive/2006/01/20/515238.aspx</em></p>
<hr/> <!-- Archival Source: ProcessPostOld -->
<P><FONT face=Tahoma>Just recently I posted about <a href="http://archives.miloush.net/michkap/archive/2006/01/07/510411.html"><STRONG>Getting the Characters in a Code Page</STRONG></A>, and described what I thought was the best solution:</FONT></P>
<BLOCKQUOTE dir=ltr style="MARGIN-RIGHT: 0px">
<P><FONT face=Tahoma><EM>#3 -- Once again take everything in the Unicode BMP&nbsp;(0x0000 to 0xFFFF), and again use </EM><A href="http://msdn.microsoft.com/library/en-us/intl/unicode_2bj9.asp"><EM>WideCharToMultiByte</EM></A><EM>, but this time make use of the WC_NO_BEST_FIT_CHARS and WC_DEFAULTCHAR flags to make sure that no </EM><a href="http://archives.miloush.net/michkap/archive/2005/02/13/371895.html"><EM>best fit mappings</EM></A><EM> take place and that you replace anything not in the code page with the default character. Then, by using the lpUsedDefaultChar parameter, you will know whether the character was not in the code page.</EM></FONT></P></BLOCKQUOTE>
<P><FONT face=Tahoma>But someone named&nbsp;</FONT><FONT face=Tahoma>CK&nbsp;was looking more information on how to implement this,&nbsp;asking for a code sample <a href="http://archives.miloush.net/michkap/archive/2006/01/07/510411.html#514997">in a comment</A> (and then in the Suggestion Box 34 minutes later!). :-)</FONT></P>
<P><FONT face=Tahoma>Here is the sort of thing I had in mind:</FONT></P>
<BLOCKQUOTE dir=ltr style="MARGIN-RIGHT: 0px">
<P><FONT face="Courier New"><STRONG>#define _UNICODE<BR>#define UNICODE<BR>#include &lt;stdio.h&gt;<BR>#include &lt;windows.h&gt;</STRONG></FONT></P>
<P><FONT face="Courier New"><STRONG>void main() <BR>{<BR>&nbsp;&nbsp;&nbsp; BOOL fDefaultChar = false;<BR>&nbsp;&nbsp;&nbsp; WCHAR ucp;<BR>&nbsp;&nbsp;&nbsp; char ch[2];<BR>&nbsp;&nbsp;&nbsp; int cch = 0;</STRONG></FONT></P>
<P><FONT face="Courier New" color=#008000><STRONG>&nbsp;&nbsp;&nbsp; // You could use "for(ucp = 0x0000; ucp &lt; 0xffff; ++ucp)"<BR>&nbsp;&nbsp;&nbsp; //&nbsp;to include the NULL if&nbsp;you&nbsp;would like to....<BR></STRONG></FONT><FONT face="Courier New"><STRONG>&nbsp;&nbsp;&nbsp; for(ucp = 0xffff; ucp &gt; 0x0000; ucp--)<BR>&nbsp;&nbsp;&nbsp; {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int cb;<BR></STRONG><BR></FONT><STRONG><FONT face="Courier New">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ch[0] = 0;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ch[1] = 0;</FONT></STRONG></P>
<P><FONT face="Courier New"><STRONG>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cb = WideCharToMultiByte(<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 932,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; WC_NO_BEST_FIT_CHARS | WC_COMPOSITECHECK | WC_DEFAULTCHAR,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &amp;ucp,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 1,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ch,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 2,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; NULL,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &amp;fDefaultChar);</STRONG></FONT></P>
<P><FONT face="Courier New"><STRONG>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if(cb &gt; 0 &amp;&amp; !fDefaultChar)<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // This code point is on the code page, so do something with it.<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cch++;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; wprintf(L"U+%04x\n", ucp);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<BR>&nbsp;&nbsp;&nbsp; }</STRONG></FONT></P>
<P><FONT face="Courier New"><STRONG>&nbsp;&nbsp;&nbsp; wprintf(L"\nA total of %d code points in the code page.", cch);<BR>}</STRONG></FONT></P></BLOCKQUOTE>
<P><FONT face=Tahoma>Obviously you can replace those wprintf calls with whatever you wanted do with the characters on the code page, and replace the code page value with whatever ANSI or OEM code page you wanted to use....</FONT></P>
<P><FONT face=Tahoma></FONT>&nbsp;</P>
<P><FONT face=Tahoma color=#ff1493><EM>This post brogught to you by</EM> "U" <EM>(<A href="http://www.fileformat.info/info/unicode/char/0055">U+0055</A>, a.k.a. LATIN CAPITAL LETTER U)</EM></FONT></P>
<hr/><p><a id="515286" href="#515286">#</a> <strong>Nick Lamb</strong> on Friday, January 20, 2006 6:34 AM:</p><div style="margin-left: 1em">Try inverting the loop? U+FFFF is not a character, but U+0000 NULL probably makes an appearance in a lot of character sets.<br><br>    for(ucp = 0x0000; ucp &lt; 0xffff; ++ucp)</div>
<p><a id="515337" href="#515337">#</a> <strong>Michael S. Kaplan</strong> on Friday, January 20, 2006 10:17 AM:</p><div style="margin-left: 1em">Yes, that would work too (though NULL is always NULL on  all of the ACPs and OEM CPs on Windows, so you cn scratch the &quot;a lot of&quot; and replace with &quot;all of&quot;). :-)<br><br>But since the main goal was a sample showing how you would use WideCharToMultiByte to find the valid characters (a piece which is important even in non-contrived scenarios!) it is probably good enough for a sample.<br><br>My main interest in this case (since many computer languages do not support both prefix and postfix operators) was to avoid adding that particular confusion here. :-)</div>
<p><a id="515341" href="#515341">#</a> <strong>Michael S. Kaplan</strong> on Friday, January 20, 2006 10:24 AM:</p><div style="margin-left: 1em">Ok, taken in as as friendly amendment in a comment, Nick. :-)</div>
<p><a id="515361" href="#515361">#</a> <strong>Maurits</strong> on Friday, January 20, 2006 11:18 AM:</p><div style="margin-left: 1em">OK, so I can do the loop and get U+FFFF but not U+0000...<br>Or I can do the loop and get U+0000 but not U+FFFF...<br><br>Any way to get both?  How about<br><br>ucp = 0;<br>do {<br>...<br>} while (++ucp)</div>
<p><a id="515362" href="#515362">#</a> <strong>Michael S. Kaplan</strong> on Friday, January 20, 2006 11:20 AM:</p><div style="margin-left: 1em">Well, since 0xFFFF is not a code point ever, and since 0x0000 is always one but never has anything to do with the langugae/script of the code page, it is more of an academic exercise in both cases, right? :-)</div>
<p><a id="515396" href="#515396">#</a> <strong>Maurits</strong> on Friday, January 20, 2006 12:19 PM:</p><div style="margin-left: 1em">Yes, it's academic in this particular case.<br><br>But as a general question, it has practical value:<br>&quot;How do you iterate over the entire range of values of an integer type?&quot;</div>
<p><a id="515418" href="#515418">#</a> <strong>Michael S. Kaplan</strong> on Friday, January 20, 2006 1:02 PM:</p><div style="margin-left: 1em">Actually, integer types are easier than the uint ones. :-)</div>
<p><a id="515419" href="#515419">#</a> <strong>CK</strong> on Friday, January 20, 2006 1:04 PM:</p><div style="margin-left: 1em">Michael,<br><br>Thanks for the example.  Your blogs are useful.<br><br>CK</div>
<p><a id="515449" href="#515449">#</a> <strong>Maurits</strong> on Friday, January 20, 2006 2:11 PM:</p><div style="margin-left: 1em">Sure, you could do something like<br><br>for(i = 0; i &gt;= 0; i++)<br><br>to get all the /non-negative/ values of a signed integer type.  (Or start at 1 for just the positive)<br><br>But it's not so easy to get ALL the values (positive, zero, and negative) of a signed integer type... you have to do something crazy like<br><br>int i = INT_MIN;<br>do { /* stuff */ } while (++i != INT_MIN);</div>
<p><a id="515454" href="#515454">#</a> <strong>Maurits</strong> on Friday, January 20, 2006 2:18 PM:</p><div style="margin-left: 1em">Or perhaps this is more readable:<br><br>int i = INT_MIN;<br>do { /* stuff */ } while (i++ != INT_MAX);<br><br>But still not perfect for systems that error on overflow... :(</div>
<p><a id="515586" href="#515586">#</a> <strong>David</strong> on Friday, January 20, 2006 7:20 PM:</p><div style="margin-left: 1em">I believe you forgot about surrogate pairs, an unfortunate dark chapter in the UTF-16LE saga.<br><br>Surrogate pairs are the dirty hack in the spec to deal with the fact that 2 bytes just doesn't cut it.  Surrogate pairs start with one byte-pair 0xd800-0xdbff followed by another from 0xdc00-0xdfff.  I'm not sure what happens if you pass HALF of a surrogate pair to WidecharToMultiByte but my guess is you'll always get a bad result for values 0xd800-0xdfff.<br></div>
<p><a id="515591" href="#515591">#</a> <strong>Michael S. Kaplan</strong> on Friday, January 20, 2006 7:29 PM:</p><div style="margin-left: 1em">Hi David,<br><br>I did not forget about them. But they not apply to any Windows OEM or ANSI code page. Nothingbad happens other than the fact that you get no mapping on the code page.<br><br>Though you could optimjize the code bt skipping that range (since it would be skipped anyway) it is probably not worth it.... :-)<br><br></div>
<p><a id="515592" href="#515592">#</a> <strong>bmm6o</strong> on Friday, January 20, 2006 7:31 PM:</p><div style="margin-left: 1em">Maurits:<br><br>To write that loop, I would probably index with a larger data type (e.g. int) and cast to the smaller one where necessary.  The loop would then look more like every other loop.</div>
<p><a id="515743" href="#515743">#</a> <strong>Nick Lamb</strong> on Saturday, January 21, 2006 10:03 AM:</p><div style="margin-left: 1em">&quot;I'm not sure what happens if you pass HALF of a surrogate pair to WidecharToMultiByte but my guess is you'll always get a bad result for values 0xd800-0xdfff.&quot;<br><br>For e.g. UTF-8 you get illegal results from all shipping versions of Windows. As you'll see in the documentation Microsoft has tried (again) to fix this in Vista. I no longer have a Vista test system so I can't testify as to its correctness.<br><br>Michael rightly points out that for this particular application (getting the list of characters in a specific legacy code page) that particular bug doesn't do much harm. Of course plenty of other bugs have survived in this family of APIs for many years, so I also wouldn't altogether trust it...<br><br>Does Windows provide iconv() or an analagous streaming conversion API ?</div>
<p><a id="515774" href="#515774">#</a> <strong>Michael S. Kaplan</strong> on Saturday, January 21, 2006 1:23 PM:</p><div style="margin-left: 1em">Actually, the UTF-8 definition on Windows has been tightening up on every successive version of Windows, as the Unicode definition has tightened up. Illegal sequences will actually be dropped completely (and silently) by default and will error out if you ask for errors to stop the conversion via flag....</div>
<p><a id="515786" href="#515786">#</a> <strong>Nick Lamb</strong> on Saturday, January 21, 2006 2:15 PM:</p><div style="margin-left: 1em">Michael, we're talking about WideCharToMultiByte not MultiByteToWideChar in this thread. The conversion from UTF-8 has been improving (though still not compliant so far as I can see) but in XP the conversion from UTF-16 to UTF-8 still accepts lone surrogates and outputs illegal UTF-8 sequences.<br><br>The reason for mentioning iconv() is that WideCharToMultiByte doesn't have any state. A naive programmer might easily take a UTF-16 disk file, and attempt to read it in a block at time, passing the block to WideCharToMultiByte and sending the UTF-8 to a new disk file, over a network socket or whatever. The WCTMB API makes it extremely difficult to get this right but MSDN neither recommends an alternative nor warns of the danger.<br></div>
<p><a id="515794" href="#515794">#</a> <strong>Michael S. Kaplan</strong> on Saturday, January 21, 2006 3:05 PM:</p><div style="margin-left: 1em">Yes, Nick -- but it the fact is that both are improved from that in server 2003 and even further in Vista. We impove, and defend users against bad data such as lone surrogates (which are actually a bug from whoever inserted the bad data, not us).<br><br>If a user is chunking text to WideCharToMultiByte they will have problems, though that is likely why both MLang and .NET necoding methods do have more stateful mechanisms than the low-level NLS API.<br><br>In the meantime, avoiding bad data is the best way at all times, so stay away from questionable data sources and you won't have any problems. :-)</div>
<p><a id="515795" href="#515795">#</a> <strong>Michael S. Kaplan</strong> on Saturday, January 21, 2006 3:07 PM:</p><div style="margin-left: 1em">ALso, note that Vista has added a WC_ERR_INVALID_CHARS flag for WideCharToMultiByte. We do keep getting better....</div>
<p><a id="516144" href="#516144">#</a> <strong>Mihai</strong> on Monday, January 23, 2006 4:59 AM:</p><div style="margin-left: 1em">&quot;But they not apply to any Windows OEM or ANSI code page.&quot;<br><br>But the title is &quot;Getting the characters in a code page,&quot; not &quot;Getting the characters in an ANSI code page.&quot;<br><br>To really get a complete code page, you can try iterating from 0 to 0x10FFFF, taking care to use surogates for everything above BMP.<br></div>
<p><a id="516205" href="#516205">#</a> <strong>Michael S. Kaplan</strong> on Monday, January 23, 2006 10:05 AM:</p><div style="margin-left: 1em">To be honest, this is only needed in two cases (GB18030 and UTF-8), both of which cover the whole range and are thus not really needed. ZNo other code page on Windows supports supplementary characters....</div>
<p><a id="553522" href="#553522">#</a> <strong>asdf</strong> on Friday, March 17, 2006 3:24 AM:</p><div style="margin-left: 1em">It's really easy to do loops over an inclusive range without overflow:<br><br>for (bool go = true; go; (go = (f != l)) &amp;&amp; (++f, true))<br> &nbsp;stuff;<br><br>or<br><br>do {<br> &nbsp; stuff;<br>} while ((f != l) &amp;&amp; (++f, true));<br><br>or wrap it up in a macro:<br><br>#define inclusive_for(init, cond, inc) \<br> &nbsp; if (bool ar3_d0n3_ = false) {} \<br> &nbsp; else for (init; !ar3_d0n3_; (ar3_d0n3_ = !(bool)(cond)) || ((inc), false))<br><br>inclusive_for (int i = INT_MIN; i != INT_MAX; ++i)<br> &nbsp; cout &lt;&lt; i;<br><br>And yes the macro has to be written that way to protect against:<br><br>if (0) {<br>} else if (0)<br> &nbsp; inclusive_for (uintmax_t i = 0, i != UINTMAX_MAX, ++i)<br> &nbsp; &nbsp; &nbsp;cout &lt;&lt; i;<br>else {<br> &nbsp; &nbsp;// not what you expect, without the if else thing<br>}<br></div>
<hr/><p><em>referenced by</em></p><div style="margin-left: 1em"><p>2006/04/22 <a href="http://archives.miloush.net/michkap/archive/2006/04/22/580636.html">Dial 911, code page 864 isn't breathing</a></p></div><p><em>go to <a id="newer" href="http://archives.miloush.net/michkap/archive/2006/01/21/515793.html" title="Return of the Mark">newer</a> or <a id="older" href="http://archives.miloush.net/michkap/archive/2006/01/19/514718.html" title="What are directional marks -- chumps who point?">older</a> post, or back to <a href="http://archives.miloush.net/michkap/archive/index.html">index</a> or <a href="http://archives.miloush.net/michkap/archive/index.html#2006-01">month</a> or <a href="http://archives.miloush.net/michkap/archive/index.html#2006-01-20">day</a></em></p></body>
<!-- Mirrored from archives.miloush.net/michkap/archive/2006/01/20/515238.html by HTTrack Website Copier/3.x [XR&CO'2014], Thu, 25 May 2017 00:42:40 GMT -->
</html>