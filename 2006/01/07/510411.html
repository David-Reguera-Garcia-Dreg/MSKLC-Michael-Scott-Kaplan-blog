<html>
<!-- Mirrored from archives.miloush.net/michkap/archive/2006/01/07/510411.html by HTTrack Website Copier/3.x [XR&CO'2014], Thu, 25 May 2017 00:42:40 GMT -->
<head><meta charset="utf-8" /><meta name="viewport" content="width=device-width" /><title>Getting the characters in a code page</title></head><body>
<h1>Getting the characters in a code page</h1>
<p><em>by Michael S. Kaplan, published on 2006/01/07 10:20 -05:00, original URI: http://blogs.msdn.com/b/michkap/archive/2006/01/07/510411.aspx</em></p>
<hr/> <!-- Archival Source: ProcessPostNew -->
<P><FONT face=Tahoma>In the Suggestion Box, rob asked the following question:</FONT></P>
<BLOCKQUOTE dir=ltr style="MARGIN-RIGHT: 0px">
<BLOCKQUOTE dir=ltr style="MARGIN-RIGHT: 0px">
<P><FONT size=2><EM>Michael, <BR><BR>As posted over at Raymond Chen's blog. What is the best way to display all the characters in i.e. codepage 932 (Japanese) and other codepage that is supported on Windows (post win2k era). The characters doesn't have to display in any fancy format. I just want the result (characters) store in a vector of string or a string table. Any recommendation? Or resources that you can point me to. <BR><BR>Thanks <BR>Rob</EM></FONT></P></BLOCKQUOTE></BLOCKQUOTE>
<P><FONT face=Tahoma>Indeed, over in Raymond Chen's blog, there is an <a href="http://blogs.msdn.com/oldnewthing/archive/2006/01/05/509642.aspx">off-topic conversation</A> going on in the comments about how to get the characters in a code page.</FONT></P>
<P><FONT face=Tahoma>You can look at the conversation if you want; you will generally see people taking the wrong approach to the problem (in my opinion). Let's look at three possible ways to do the job:</FONT></P>
<P><FONT face=Tahoma>#1 -- Take all of the lead bytes for the code page via the <A href="http://msdn.microsoft.com/library/en-us/intl/nls_0ctr.asp">GetCPInfo</A> function and try each possible trail byte, converting each sequence via <A href="http://msdn.microsoft.com/library/en-us/intl/unicode_17si.asp">MultiByteToWideChar</A>. As the conversation sort of implied, there are many complications with this approach, although it is possible if you carefully check the return values to make sure only one character comes back, etc. Also, since I said I three suggestions, what were the odds that the first one would be my recommendation? :-)</FONT></P>
<P><FONT face=Tahoma>#2 -- Take everything in the Unicode BMP&nbsp;(0x0000 to 0xFFFF) and&nbsp;try to round trip it through <A href="http://msdn.microsoft.com/library/en-us/intl/unicode_2bj9.asp">WideCharToMultiByte</A> and <A href="http://msdn.microsoft.com/library/en-us/intl/unicode_17si.asp">MultiByteToWideChar</A>; if it round trips and it is a single character, then clearly it is on the code page. This approach is more feasible although it is more work than you really need to do, so I would not recommend this one either.</FONT></P>
<P><FONT face=Tahoma>#3 -- Once again take everything in the Unicode BMP&nbsp;(0x0000 to 0xFFFF), and again use <A href="http://msdn.microsoft.com/library/en-us/intl/unicode_2bj9.asp">WideCharToMultiByte</A>, but this time make use of the WC_NO_BEST_FIT_CHARS and WC_DEFAULTCHAR flags to make sure that no <a href="http://archives.miloush.net/michkap/archive/2005/02/13/371895.html">best fit mappings</A> take place and that you replace anything not in the code page with the default character. Then, by using the <EM>lpUsedDefaultChar</EM> parameter, you will know whether the character was not in the code page.</FONT></P>
<P><FONT face=Tahoma>The advantagess to #3 over the other two methods are obvious -- you will get every character in the code page and any time it is not valid you will know by directly checking a Boolean flag. </FONT><FONT face=Tahoma>For cp932 (the one in the example) and all of the "ANSI" and "OEM" code pages on Windows, there would never be more than two bytes per character so a single two bytes would cover the lpMultiByteStr target buffer (for some of the others the job is a bit harder, but it is unclear whether that is being asked). You could even try the same run a second time without the WC_NO_BEST_FIT_CHARS flag and then compare the two to obtain all of the best fit mappings in the code page. And in short order you would have every character in the code page mapping.</FONT></P>
<P><FONT face=Tahoma>Easy! and perhaps even a good interview question, ignoring the fact that the candidate would have to come in knowing all about the NLS API functions!</FONT></P>
<P><FONT face=Tahoma>Now note that this approach will not get you all of the characters in a language, not only because <a href="http://archives.miloush.net/michkap/archive/2004/12/10/279398.html">you can't get the letters in a language easily</A> but also because <a href="http://archives.miloush.net/michkap/archive/2005/03/01/382289.html">code pages are really not enough</A>&nbsp;to cover a language.</FONT></P>
<P><FONT face=Tahoma></FONT>&nbsp;</P>
<P><FONT face=Tahoma color=#ff1493><EM>This post brought to you by</EM> "<FONT size=6>ï¾™</FONT>" <EM>(<A href="http://www.fileformat.info/info/unicode/char/ff99">U+ff99</A>, HALFWIDTH KATAKANA LETTER RU)</EM></FONT></P>
<hr/><p><a id="510533" href="#510533">#</a> <strong>Michael Dunn_</strong> on 8 Jan 2006 2:52 AM:</p><div style="margin-left: 1em">As a variation on #1, how about passing each of the possible lead+trail byte combos to _ismbclegal?</div>
<p><a id="510541" href="#510541">#</a> <strong>Mihai</strong> on 8 Jan 2006 4:08 AM:</p><div style="margin-left: 1em">The only problem (with all of the solutions) is that not all code pages can be covered like this. The main exception is GB-18030, which has characters outside BMP.<br><br>Sure, one might extend the range beyond BMP, but the performance goes down and the consumed memory goes up.<br>In this case a variant of #1 might give better results (whith the warning that the complications and care will be even bigger :-)<br></div>
<p><a id="510560" href="#510560">#</a> <strong>Michael S. Kaplan</strong> on 8 Jan 2006 9:53 AM:</p><div style="margin-left: 1em">For both GB18030 and UTF-8, *all* of Unicode is covered, so if it is a characetr, its oin the code page. And that's that. Easy!<br><br>#1 is never easier, though -- it is always more work....</div>
<p><a id="510561" href="#510561">#</a> <strong>Michael S. Kaplan</strong> on 8 Jan 2006 9:54 AM:</p><div style="margin-left: 1em">Mike, that is still more work by the time you are done, certainly more complicated to implement....</div>
<p><a id="510606" href="#510606">#</a> <strong>Mihai</strong> on 8 Jan 2006 3:24 PM:</p><div style="margin-left: 1em">&quot;For both GB18030 and UTF-8, *all* of Unicode is covered&quot;<br>True. But the proposed solutions #2 and #3 take BMP only.<br><br>&quot;#1 is never easier, though -- it is always more work....&quot;<br>True again :-)<br>But I was talking about better results in performance and consumed memory.<br>Sometimes you have to work more for these two.</div>
<p><a id="510610" href="#510610">#</a> <strong>Michael S. Kaplan</strong> on 8 Jan 2006 3:52 PM:</p><div style="margin-left: 1em">Ah, you missed my point -- you do not need to do anything for UTF-8 and  GB18030 -- no conversion needed at all!<br><br>It is all in there.</div>
<p><a id="510724" href="#510724">#</a> <strong>Mihai</strong> on 9 Jan 2006 3:11 AM:</p><div style="margin-left: 1em">&quot;Ah, you missed my point&quot;<br>True :-) But now I get it.<br><br>But do you mean GB18030 contains everything that is in Unicode? I thought it is a (big) subset. So it is a bit like 932, only much bigger, but still not covering all of Unicode. Or is it?</div>
<p><a id="510752" href="#510752">#</a> <strong>Michael S. Kaplan</strong> on 9 Jan 2006 6:56 AM:</p><div style="margin-left: 1em">GB18030 is completely tied to Unicode as it is defined, and thus everything in Unicode is in GB18030.</div>
<p><a id="510924" href="#510924">#</a> <strong>Rob</strong> on 9 Jan 2006 3:14 PM:</p><div style="margin-left: 1em">Michael,<br><br>Thanks for the explanation.  If I use recommendation #3 how would I distinguish what characters belong to what code page?  Would I use the Hex range for determine the code page?<br><br>Thanks<br>Rob</div>
<p><a id="510936" href="#510936">#</a> <strong>Michael S. Kaplan</strong> on 9 Jan 2006 3:40 PM:</p><div style="margin-left: 1em">Hi Rob,<br><br>For #3 -- check the return value of the WideCharToMultiByte call -- if the conversion succeeds, it is a valid part of the code page you used to convert, and the byte(s) are in the multibyte param. If it fails, then skip to the next character....</div>
<p><a id="510963" href="#510963">#</a> <strong>Maurits [MSFT]</strong> on 9 Jan 2006 4:29 PM:</p><div style="margin-left: 1em">This works... until a code page comes out with a supplementary code point in it...</div>
<p><a id="510964" href="#510964">#</a> <strong>Michael S. Kaplan</strong> on 9 Jan 2006 4:33 PM:</p><div style="margin-left: 1em">There are no new code pages coming in Windows, sorry! :-)</div>
<p><a id="511257" href="#511257">#</a> <strong>Rob</strong> on 10 Jan 2006 12:32 PM:</p><div style="margin-left: 1em">Michael,<br><br>Thanks for the info.  I'll try #3 and store all the valid code point into a vector of CString and then print them into a file and open them up in IE.  Viewing in IE will allow me to see all the valid characters.<br><br>Rob</div>
<p><a id="514997" href="#514997">#</a> <strong>CK</strong> on 19 Jan 2006 2:56 PM:</p><div style="margin-left: 1em">Hi Michael,<br><br>Any code sample(s) for recommendation #3?  Thanks in advance if you have any.<br><br>Thanks<br>CK</div>
<hr/><p><em>referenced by</em></p><div style="margin-left: 1em"><p>2006/01/20 <a href="http://archives.miloush.net/michkap/archive/2006/01/20/515238.html">Getting the characters in a code page (the code)</a></p></div><p><em>go to <a id="newer" href="http://archives.miloush.net/michkap/archive/2006/01/07/510513.html" title="Miscellany and things even less relevant">newer</a> or <a id="older" href="http://archives.miloush.net/michkap/archive/2006/01/06/509784.html" title="If it&#39;s not in Unicode, don&#39;t expect it in Windows">older</a> post, or back to <a href="http://archives.miloush.net/michkap/archive/index.html">index</a> or <a href="http://archives.miloush.net/michkap/archive/index.html#2006-01">month</a> or <a href="http://archives.miloush.net/michkap/archive/index.html#2006-01-07">day</a></em></p></body>
<!-- Mirrored from archives.miloush.net/michkap/archive/2006/01/07/510411.html by HTTrack Website Copier/3.x [XR&CO'2014], Thu, 25 May 2017 00:42:40 GMT -->
</html>