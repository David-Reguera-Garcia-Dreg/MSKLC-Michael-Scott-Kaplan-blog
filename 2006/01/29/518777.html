<html>
<!-- Mirrored from archives.miloush.net/michkap/archive/2006/01/29/518777.html by HTTrack Website Copier/3.x [XR&CO'2014], Thu, 25 May 2017 00:42:40 GMT -->
<head><meta charset="utf-8" /><meta name="viewport" content="width=device-width" /><title>Handling multilingual data in SQL Server</title></head><body>
<h1>Handling multilingual data in SQL Server</h1>
<p><em>by Michael S. Kaplan, published on 2006/01/29 03:01 -05:00, original URI: http://blogs.msdn.com/b/michkap/archive/2006/01/29/518777.aspx</em></p>
<hr/> <!-- Archival Source: ProcessPostNew -->
<p><font face=Tahoma>Seth Siegal asked in the Suggestion Box:</font></p>
<blockquote dir=ltr style="MARGIN-RIGHT: 0px">
<p><em>What is the best practice for searching large table in mixed languages. Context is SQL Server 2000 or SQL Server 2005. The problem is storing in a single column character data from mixed languages and then providing a search capability to find the best match given a search string in some arbitrary language. The column, of course, is Unicode data type with some collation. Is there an optimal default collation? What is recommendation for table design for efficiency -- collation, indexes? </em></p>
<p><em>As an example, consider an international directory of business names and a stored procedure to search for a name "like" &lt;some string&gt; where &lt;some string&gt; is user input in any language. Since collation determines comparison rules it seems the appropriate collation is one that best matches the language of the search string. Further, to facilitate matching it seems appropriate to relax restrictions such as case and accent sensitivity. That is a strict binary comparison is not "user friendly." However there are serious performance implications when the collation of the search string does not match the collation of the database column and dynamic casting is used to make them match. </em></p>
<p dir=ltr><em>Example (approximate SQL): </em></p>
<blockquote dir=ltr style="MARGIN-RIGHT: 0px">
<p><font face="Courier New">MyBigTable (ID int not null, SearchString nvarchar(1000) not null collate &lt;Optimal Collation For Mixed Languages&gt;) <br />create procedure UserSearch @SearchString nvarchar(1000), @SearchCollation nvarchar(128) as <br />select * from MyBigTable <br />where SearchString collate @SearchCollation like @SearchString </font></p></blockquote></blockquote>
<p><font face=Tahoma>The answer to this question is buried in some important implementation details surrounding the way collations work....</font></p>
<p><font face=Tahoma>The first issue is that every&nbsp;"Windows" (which is to say, not SQL compatibility)&nbsp;collation is <strong>a view of everything in the table, according to a particular language or set of languages</strong>.</font></p>
<p><font face=Tahoma>Now this helps the first parr if Seth's question -- any collation can be used if you are sticking with Unicode data (though how you want non-Unicode clients to behave when querying the data may have an influence your final choice).</font></p>
<p><font face=Tahoma>However, because of this design, it is easy to find situations where weights in one collation will not distinguish as well as weights in another collation, depending on&nbsp;how important&nbsp;the differences are for a given language. As I point out in <a HREF="http://archives.miloush.net/michkap/archive/2005/02/05/367666.html"><strong>You can't ignore diacritics when a language does not give them diacritic weight</strong></a>, one person's primary distinction can easily be another person's secondary distinction. Especially in a case where one is planning to ignore case or accent differences, this means that one person's equality is another's inequality.</font></p>
<p><font face=Tahoma>In order to properly support the querying of multilingual data well, you really do have to do both seek and ordering operations using the collation that will match the queryer's expectations.</font></p>
<p><font face=Tahoma>But as Seth points out this can lead to serious performance issues.....</font></p>
<p><font face=Tahoma>Luckily, I haved posted about how to work around that issue. :-)</font></p>
<p><font face=Tahoma>In the post <a HREF="http://archives.miloush.net/michkap/archive/2005/05/06/415199.html"><strong>Making SQL Server index usage a bit more deterministic</strong></a> I explain how to make sure that performance will not suffer with such operations do to non-indexed queries being run. And I highly recoomend this technique be used any time you do have to commonly deal with multiple languages....</font></p>
<p><font face=Tahoma></font>&nbsp;</p>
<p><font face=Tahoma color=#ff1493><em>This post brought to you by</em> "<font size=6>ﬁù</font>" <em>(<a href="http://www.fileformat.info/info/unicode/char/079d">U+079d</a>, a.k.a. THANNA LETTER SHEENU)</em></font></p>
<hr/><p><a id="522810" href="#522810">#</a> <strong>Sabish</strong> on 1 Feb 2006 11:51 PM:</p><div style="margin-left: 1em">I am a Programmer</div>
<hr/><p><em>referenced by</em></p><div style="margin-left: 1em"><p>2007/04/11 <a href="http://archives.miloush.net/michkap/archive/2007/04/11/2087685.html">Microsoft is not uncaron^H^Hing about the issue!</a></p><p>2006/06/07 <a href="http://archives.miloush.net/michkap/archive/2006/06/07/620277.html">Performance issues with language specific sorts?</a></p></div><p><em>go to <a id="newer" href="http://archives.miloush.net/michkap/archive/2006/01/29/518934.html" title="It can&#39;t be all about the money">newer</a> or <a id="older" href="http://archives.miloush.net/michkap/archive/2006/01/28/518787.html" title="The parts of AP">older</a> post, or back to <a href="http://archives.miloush.net/michkap/archive/index.html">index</a> or <a href="http://archives.miloush.net/michkap/archive/index.html#2006-01">month</a> or <a href="http://archives.miloush.net/michkap/archive/index.html#2006-01-29">day</a></em></p></body>
<!-- Mirrored from archives.miloush.net/michkap/archive/2006/01/29/518777.html by HTTrack Website Copier/3.x [XR&CO'2014], Thu, 25 May 2017 00:42:40 GMT -->
</html>