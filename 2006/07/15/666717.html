<html>
<!-- Mirrored from archives.miloush.net/michkap/archive/2006/07/15/666717.html by HTTrack Website Copier/3.x [XR&CO'2014], Thu, 25 May 2017 00:42:39 GMT -->
<head><meta charset="utf-8" /><meta name="viewport" content="width=device-width" /><title>How long is that non-Unicode string?</title></head><body>
<h1>How long is that non-Unicode string?</h1>
<p><em>by Michael S. Kaplan, published on 2006/07/15 13:05 -04:00, original URI: http://blogs.msdn.com/b/michkap/archive/2006/07/15/666717.aspx</em></p>
<hr/> <!-- Archival Source: ProcessPostNew -->
<P><FONT face=Tahoma>The question that came to me by email from a woman named Denise was: </FONT></P>
<BLOCKQUOTE dir=ltr style="MARGIN-RIGHT: 0px">
<P><FONT face=Garamond>What is the easiest way to get the length of an MBCS string <EM>in characters</EM>, by which I mean not in bytes but having an ideograph be treated as length 1? Assuming you know the code page the string is in, and it is in one of the regular Windows cod pages.</FONT></P></BLOCKQUOTE>
<P><FONT face=Tahoma>This is actually kind of like an interesting interview question, and gives rise to many possible approaches....</FONT></P>
<P><FONT face=Tahoma>So, in the spirit of interview questions <A href="http://archives.miloush.net/michkap/archive/2005/09/13/465228.html">I</A> <A href="http://archives.miloush.net/michkap/archive/2005/02/28/381465.html">have</A> <A href="http://archives.miloush.net/michkap/archive/2006/02/02/523189.html">asked</A> in the past, I'd like to put this question out there for everyone!</FONT></P>
<P><FONT face=Tahoma>Now&nbsp;of course since it is an "interview" question, the best answer is the one that answers the question while properly balancing concerns like </FONT></P>
<UL>
<LI><FONT face=Tahoma>performance</FONT></LI>
<LI><FONT face=Tahoma>memory usage</FONT></LI>
<LI><FONT face=Tahoma>maintainability</FONT></LI>
<LI><FONT face=Tahoma>understandability</FONT></LI>
<LI><FONT face=Tahoma>while of course solving the actual problem -- the length&nbsp;in <STRONG>characters</STRONG>, not bytes, of a CJK string in a given code page</FONT></LI></UL>
<P><FONT face=Tahoma>In keeping with Denise's original formulation of the question, let's limit the code page range to the ANSI/OEM code pages (thus <A href="http://www.microsoft.com/globaldev/reference/dbcs/932.mspx">932</A>, <A href="http://www.microsoft.com/globaldev/reference/dbcs/936.mspx">936</A>, <A href="http://www.microsoft.com/globaldev/reference/dbcs/949.mspx">949</A>, and <A href="http://www.microsoft.com/globaldev/reference/dbcs/950.mspx">950</A>).</FONT></P>
<P><FONT face=Tahoma>This time I am going to try not restricting the comments (other then the usual restricting of anonymous comments), to see what happens....</FONT></P>
<P><FONT face=Tahoma>Ready, set, go!</FONT></P>
<hr/><p><a id="666770" href="#666770">#</a> <strong>Sebastian Redl</strong> on 15 Jul 2006 3:11 PM:</p><div style="margin-left: 1em">Well, there's StringCchLength. However, while MSDN explicitely says that it returns the character count (as opposed to StringCbLength), it does not say what code page is used; thus, it is either the OEM page or the current ANSI page. If it's the latter, as I would assume, you could set the current ANSI page to your desired page, call the function, then set it back. Neither does the general information page about strings offer any information about what code page is used. (While we're talking about encodings, ironically the online MSDN page in question, &quot;About Strings&quot;, reports itself to be windows-1252, but gives the example umlaut-u (&#252;) for CharLower in UTF-8, resulting in mangled display.)<br><br>There seems to be no function that takes an LCID or similar identifier that could be used to select a specific code page.</div>
<p><a id="666790" href="#666790">#</a> <strong>Michael S. Kaplan</strong> on 15 Jul 2006 3:37 PM:</p><div style="margin-left: 1em">StringCchLength will not return the right results here.... <BR><BR>Plus you have knowledge of a code page and need to know how to get the right answer no matter which of the four code pages it is in.<BR><BR>On top of everything else, since a reboot is required for default system locale changes, it would never be the fastest function you could run. :-)</div>
<p><a id="666920" href="#666920">#</a> <strong>Adam</strong> on 15 Jul 2006 8:20 PM:</p><div style="margin-left: 1em">Are we allowed to use an external library to help? If so, I choose iconv[0]. It's part of POSIX and available on most Unices and MacOS X, but GNU iconv[1] is also available for win32[2][3].<br><br>It does supports the required codepages; 932, 949 and 950 are all available as &quot;CP932&quot;, &quot;CP949&quot; and &quot;CP950&quot;, while 936 is available under the name GBK. So...<br><br>int stringCharLen(char const * src, int codepage)<br>{<br> &nbsp; &nbsp;char const * pagename;<br> &nbsp; &nbsp;switch (codepage) {<br> &nbsp; &nbsp;case 932: pagename = &quot;CP932&quot;;<br> &nbsp; &nbsp;case 949: pagename = &quot;CP949&quot;;<br> &nbsp; &nbsp;case 950: pagename = &quot;CP950&quot;;<br> &nbsp; &nbsp;case 936: pagename = &quot;GBK&quot;;<br> &nbsp; &nbsp;default: return -1;<br> &nbsp; &nbsp;}<br><br> &nbsp; &nbsp;size_t srclen = strlen(src); /* length of src _in bytes_ */<br> &nbsp; &nbsp;if (srclen == 0) {<br> &nbsp; &nbsp; &nbsp; &nbsp;return 0;<br> &nbsp; &nbsp;}<br><br> &nbsp; &nbsp;int chars = 0;<br> &nbsp; &nbsp;iconv_t cd = iconv_open(&quot;UTF-32&quot;, pagename);<br> &nbsp; &nbsp;while (1) {<br> &nbsp; &nbsp; &nbsp; &nbsp;char dest[5];<br> &nbsp; &nbsp; &nbsp; &nbsp;size_t destlen = 5;<br> &nbsp; &nbsp; &nbsp; &nbsp;size_t result = iconv(cd, &amp;src, &amp;srclen, &amp;dest, &amp;destlen);<br><br> &nbsp; &nbsp; &nbsp; &nbsp;if (result != (size_t) -1) {<br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;/* no error occurred. Must have just recoded last character. */<br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;++chars;<br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;break;<br> &nbsp; &nbsp; &nbsp; &nbsp;}<br> &nbsp; &nbsp; &nbsp; &nbsp;else if (errno == E2BIG) {<br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;/* just recoded one character that wasn't the last one. */<br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;++chars;<br> &nbsp; &nbsp; &nbsp; &nbsp;}<br> &nbsp; &nbsp; &nbsp; &nbsp;else {<br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;/* oops! */<br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;chars = -1;<br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;break;<br> &nbsp; &nbsp; &nbsp; &nbsp;}<br> &nbsp; &nbsp;}<br> &nbsp; &nbsp;iconv_close(cd);<br> &nbsp; &nbsp;return chars;<br>}<br><br>There's not much error checking, and I don't really like the very-simple switch to get charset names from codepages, but...<br><br>a) It ought to work (why is that _last_ on your list of requirements? :-)<br>b) It doesn't require you to fiddle with the current codepage.<br>c) There's not much to maintain &amp; that ought to help with its clarity.<br>d) Should have low mem usage.<br><br>Downsides are:<br><br>a) Performance won't be great. I could have used a longer &quot;dest&quot; buffer and counted the number of characters put into it instead of doing one at a time, but that would have been a bit more complicated. Besides which, optimization is what you do last, if and when you've figured out where the host spot is.<br>b) Requires a third-party dll. Is that a big deal? *shrug*<br><br>[0] <a rel="nofollow" target="_new" href="http://www.opengroup.org/pubs/online/7908799/xsh/iconv.h.html">http://www.opengroup.org/pubs/online/7908799/xsh/iconv.h.html</a><br>[1] <a rel="nofollow" target="_new" href="http://www.gnu.org/software/libiconv/">http://www.gnu.org/software/libiconv/</a><br>[2] <a rel="nofollow" target="_new" href="http://gettext.sourceforge.net/">http://gettext.sourceforge.net/</a><br>[3] <a rel="nofollow" target="_new" href="http://ftp.gnu.org/pub/gnu/libiconv/libiconv-1.9.1.bin.woe32.zip">http://ftp.gnu.org/pub/gnu/libiconv/libiconv-1.9.1.bin.woe32.zip</a><br></div>
<p><a id="666923" href="#666923">#</a> <strong>Michael S. Kaplan</strong> on 15 Jul 2006 8:29 PM:</p><div style="margin-left: 1em">Ok, not too bad -- though that is a lot of separate calls to do the conversions, which might be a bit slower than one might like.<br><br>You could do something similar with Win32 calls, too -- which would remove the external libraries issue completely.<br><br>But what about a way to avoid the multiple calls to the conversion libraries? That call may be a bit too heavy here....<br><br>(as to why I put it last on the list, it is kind of implied and is just a reminder -- the optimizations would be in the other points, of course. &lt;grin&gt;)</div>
<p><a id="666946" href="#666946">#</a> <strong>Adam</strong> on 15 Jul 2006 9:01 PM:</p><div style="margin-left: 1em">You can't grab a buffer 4 times the size of the source string and do it all at once if you've no idea how big the source string may be. If it's a multi-megabyte text file that someone's decided to run through your code, you don't want it taking up about 5 times the amount of memory it should (worst case).<br><br>So, to reduce the number of calls to iconv() you need to do the recoding in chunks (say, with a 4k dest buffer instead of a 4 byte dest buffer), which is more complex. For proof-of-concept code like the above, I'll stick with the brute-force approach. Especially when I've not even tried to compile it :)<br></div>
<p><a id="666952" href="#666952">#</a> <strong>Vlad</strong> on 15 Jul 2006 9:16 PM:</p><div style="margin-left: 1em">Here is a solution with no libraries at all. It should be reasonably fast for correctly encoded CJK string<br><br>inline bool isLeadByte(unsigned char c, int cp){<br>	if ((c &lt; 0x81)||(cp == 932 &amp;&amp; c &gt; 0xA0 &amp;&amp; c &lt; 0xE0 ))<br>		return false;<br>	else<br>		return true;<br>}<br><br>int countChars(const char *str, int cp){<br>	int count = 0;<br>	unsigned const char *ptr = (unsigned const char *)str;<br>	while(*ptr != 0){<br>		ptr += isLeadByte(*ptr,cp)? 2 : 1;<br>	 &nbsp; &nbsp;count++;<br>	}<br> &nbsp; &nbsp;return count;<br>}</div>
<p><a id="666998" href="#666998">#</a> <strong>Michael Dunn_</strong> on 15 Jul 2006 10:58 PM:</p><div style="margin-left: 1em">// Written in the comment area's little text box, totally untested ;)<br> <br>size_t GetCharCount ( LPCSTR p )<br>{<br>size_t cch = 0;<br> <br> &nbsp;while ( 0 != *p )<br> &nbsp;{<br> &nbsp; &nbsp;if ( IsDBCSLeadByte(*p) &amp;&amp; 0 != p[1] )<br> &nbsp; &nbsp; &nbsp;{ cch++; p++ }<br> &nbsp; &nbsp;else<br> &nbsp; &nbsp; &nbsp;cch++;<br> <br> &nbsp; &nbsp;p++;<br> &nbsp;}<br> <br> &nbsp;return cch;<br>}<br> <br>There are two cases, *p is a DBCS lead byte or it isn't. If it's not, then increment the character count. If it is, and the subsequent byte is non-zero (meaning it's a valid trail byte), then increment the count and increment p over the lead byte. <br>The test of p[1] != 0 handles the case of a lead byte being at the end of the string, with no trail byte.<br> <br>This uses just two locals, which can probably be put in registers. Almost everything is an increment or compare against zero, which are fast instructions.<br> <br>The only concern I'd have for maintainability is the p[1] check, but a couple lines of explanatory comments would take care of it.</div>
<p><a id="667238" href="#667238">#</a> <strong>Adam</strong> on 16 Jul 2006 4:54 AM:</p><div style="margin-left: 1em">Mike: How does handle the case where, although you know what codepage the string is in, the _current_ codepage is something else?<br><br>e.g. on a Western system, codepage 1252, you've got a string (maybe a file) you know is encoded in CP949 and want to find the number of characters in that. I got the impression that that was implied by the problem, but can't see how you're dealing with it.<br><br>Ah - but now I look at the IsDBCSLeadByte() docs on msdn[0], they point to IsDBCSLeadByteEx()[1] which takes a second &quot;codepage&quot; parameter. Hmmm......<br><br>[0] <a rel="nofollow" target="_new" href="http://msdn.microsoft.com/library/default.asp?url=/library/en-us/intl/unicode_9oag.asp">http://msdn.microsoft.com/library/default.asp?url=/library/en-us/intl/unicode_9oag.asp</a><br>[1] <a rel="nofollow" target="_new" href="http://msdn.microsoft.com/library/default.asp?url=/library/en-us/intl/unicode_0o2t.asp">http://msdn.microsoft.com/library/default.asp?url=/library/en-us/intl/unicode_0o2t.asp</a></div>
<p><a id="667255" href="#667255">#</a> <strong>Vlad</strong> on 16 Jul 2006 5:52 AM:</p><div style="margin-left: 1em">Next try , after rediscovering CharNextExA.<br>- This version is maintainable, but would require a function call for each DBCS character, &nbsp;so it is slow<br><br>#include &lt;windows.h&gt;<br>int countChars(const char *str, int codepage){<br> &nbsp; &nbsp; &nbsp; &nbsp;int &nbsp; count = 0;<br> &nbsp; &nbsp; &nbsp; &nbsp;const char *p; &nbsp;<br>	for(*p = str; *p ; p = CharNextExA(codepage,p,0))<br>		count++;<br> &nbsp; &nbsp; &nbsp; &nbsp;return count;<br>}</div>
<p><a id="667280" href="#667280">#</a> <strong>KJK::Hyperion</strong> on 16 Jul 2006 7:17 AM:</p><div style="margin-left: 1em">Why, of course you use the same, efficient, flawed method cmd.exe uses to parse batch files under a multibyte codepage: you call GetCPInfo on the desired codepage (in the case of cmd.exe, the current console output codepage, which typically defaults to the current OEM codepage), and this fills you a nice CPINFO structure you can cache until the codepage changes<br><br>Counter-question: how, exactly, is this flawed? (answer: it breaks with any multibyte codepage that doesn't use the lead byte/trail byte model, most notably UTF-8. Try chcp 65001 in a cmd session, see what happens when you try to run a batch file after that)<br><br>If you don't mind linking to user32.dll or killing Windows NT 3.x support (call me old fashioned), you could always use CharNextExA, altough the documentation is extremely vague as to what constitutes &quot;next&quot;, and I have no idea whether it would work with UTF-8 or not</div>
<p><a id="667296" href="#667296">#</a> <strong>Michael S. Kaplan</strong> on 16 Jul 2006 7:47 AM:</p><div style="margin-left: 1em">Hello Mike, <BR><BR>Your solution with IsDBCSLeadByte is intriguing, though as Adam mentioned, IsDBCSLeadByteEx would be better since it takes a code page parameter.... :-)</div>
<p><a id="667297" href="#667297">#</a> <strong>Michael S. Kaplan</strong> on 16 Jul 2006 7:49 AM:</p><div style="margin-left: 1em">Hello Vlad and KJK:Hyperion, <br><br>CharNextExA would work here, and does meet the requirements (and thankfully is a lighter call that the conversion call). The UTF-8 thing is not an issue since that is not in the current question. :-) <br><br>Though of course to do its work, CharNextExA uses IsDBCSLeadByteEx calls, so using it directly may be more efficient....</div>
<p><a id="667472" href="#667472">#</a> <strong>Adam</strong> on 16 Jul 2006 11:46 AM:</p><div style="margin-left: 1em">KJK: One advantage of my approach that I didn't mention - by simply appending to the switch at the top to get the encoding name from the codepage, adding support for other MBCSs (including UTF-8) and also SBCSs (like 1252) is trivial. It's also possible to add support for dealing with UTF-16 surrogate pairs to count unicode chars outside the BMP properly, as MS has assigned code pages 1200 and 1201 to UTF-16 LE and BE.<br></div>
<p><a id="667793" href="#667793">#</a> <strong>Mihai</strong> on 16 Jul 2006 9:19 PM:</p><div style="margin-left: 1em">&quot;CharNextExA would work here&quot;<br>Unless you run it on Win XP, where is broken :-)<br><br>I can see two ways:<br> - count chars skiping lead bytes (IsDBCSLeadByteEx)<br> &nbsp; &nbsp;while( *str ) {<br> &nbsp; &nbsp; &nbsp; &nbsp;if( !IsDBCSLeadByteEx( cp, *str ) )<br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;++count;<br> &nbsp; &nbsp; &nbsp; &nbsp;++str;<br> &nbsp; &nbsp;}<br> &nbsp; &nbsp;<br>- &quot;pretend&quot; to convert to Unicode using MultiByteToWideChar (NULL output buffer and 0 output len). This will return the number of WCHARs needed (which is the answer)<br><br>BUT!<br>1. the original question was about MBCS, not DBCS. True Michal reduced the problem to the ANSI code pages. But if you have to also support GB-18030 (and you must, if you want to sell in China :-), then the first solution is bad.<br>And the second should really do the conversion and count the surrogate pairs as one character<br><br>2. Japanese is trickier. If the string contains narrow katakana, then some of them will need two elements. So sometimes you need 4 bytes for a narrow katakana. This error is there even after converting to Unicode.<br>Example: CA DF (SJIS) converts to &lt;U+FF8A,U+FF9F&gt;, Halfwidth Katakana Letter Ha + Halfwidth Katakana semi-voiced sound mark.<br>But for the user this is Katakana Leter Pa (U+30D1), one character.<br>The solution is to use LCMapStringEx with LCMAP_FULLWIDTH first.<br><br>3. If the real request is &quot;count what the user percieves as character&quot;, it might be even more problematic. What is a &quot;character&quot; for a native Korean? The bundle of 2-4 sylables that are encoded in the Hangul Syllables block, is counted as one character, or each syllable should be counted? Is 걱 (U+AC71) one or 3 characters? I don't know, I should ask a native.<br>But if the answer is the second, then we need decomposition info.<br>And we still cannot blindly decompose, because this will also decompose the Japanese Kana that are present in the Korean code page! Probably decompose all, follwed by LCMapStringEx with LCMAP_FULLWIDTH.<br>But what about Russian characters (like cp949&lt;AC D7&gt;, mapping to U+0451, which also gets decomposed and is not fixed by LCMapStringEx.<br>No easy solutions here :-)<br><br>Ouch, my head hurts, so I will stop :-)<br></div>
<p><a id="667834" href="#667834">#</a> <strong>Michael S. Kaplan</strong> on 16 Jul 2006 10:15 PM:</p><div style="margin-left: 1em">CharNextExA &nbsp;is not broken on XP, as far as I know -- only CharNextW is.... or is this some other issue?<br><br>I never make people solve new problems unless I expand the question later. :-)</div>
<p><a id="668101" href="#668101">#</a> <strong>Adam</strong> on 17 Jul 2006 5:53 AM:</p><div style="margin-left: 1em">Michael: But the question is always expanded later. :)<br><br>I've had enough bosses who've asked for &quot;x&quot; and later asked for &quot;x + y&quot;, because &quot;y is kind of like x - how hard can it be?&quot; to be very wary of phrases like &quot;let's limit the code page range to ...&quot;. There's very often an unspoken &quot;... for now&quot;, and, being human, there is the occasional genuine mistake - &quot;Sorry, we forgot 20936. Can you add that? It's /just one more/ code page. It's not really a /new/ problem, it's just an extension of the old one.&quot;<br></div>
<p><a id="668446" href="#668446">#</a> <strong>Mihai</strong> on 17 Jul 2006 12:23 PM:</p><div style="margin-left: 1em">&quot;CharNextExA &nbsp;is not broken on XP, as far as I know -- only CharNextW&quot;<br><br>Sorry, did not test. Just (wrongly) asumed.<br>In my mind was &quot;CharNextEx is broken,&quot; without realizing that my mind migrated to Unicode a while ago :-)</div>
<p><a id="668487" href="#668487">#</a> <strong>Michael S. Kaplan</strong> on 17 Jul 2006 12:50 PM:</p><div style="margin-left: 1em">Hi Adam -- <BR><BR>Since this is not an actual interview, I never intended to expand the scope of the problem -- though this is a technique I have used in the past with interview questions, so I don't mind people exploring the idea here. :-) <BR><BR>Hi Mihai -- <BR><BR>The 'W' and 'A' versions of these functions are trying to do two very different operations, with no reasonable overlasp between them. :-)</div>
<p><a id="668545" href="#668545">#</a> <strong>Michael S. Kaplan</strong> on 17 Jul 2006 1:35 PM:</p><div style="margin-left: 1em">On the other hand, if an interview question is for ABC, then you may ask a clarifying question about the possible future need to support ABCDEFG (you may even leave your design open enough to support it in the future), but simply doing it rather than answering the original question suggests a problem in understanding project scope. :-)</div>
<p><a id="668751" href="#668751">#</a> <strong>Mihai</strong> on 17 Jul 2006 4:08 PM:</p><div style="margin-left: 1em"><FONT size=1><EM>On the other hand, if an interview question is for ABC, then you may ask a clarifying question about the possible future need to support ABCDEFG</EM></FONT> <BR><BR>If this is about my post, then: <BR>- 2 and 3 are true for the original problem <BR>- for 1 I make clear that I understand the exclusion. <BR><BR>And in an interview I would ask (it takes 10 sec, unlike here, where it can take hours :-) <BR>And, in general, here one can take some liberties that are not ok in an interview (ie mispelling Michael as "Michal", sorry :-) </div>
<p><a id="668809" href="#668809">#</a> <strong>Michael S. Kaplan</strong> on 17 Jul 2006 4:58 PM:</p><div style="margin-left: 1em">It was more about Adam's, but the points are still valid. :-)</div>
<hr/><p><em>referenced by</em></p><div style="margin-left: 1em"><p>2006/07/17 <a href="http://archives.miloush.net/michkap/archive/2006/07/17/668787.html">'A' and 'W' are sometimes living in two different worlds</a></p></div><p><em>go to <a id="newer" href="http://archives.miloush.net/michkap/archive/2006/07/15/666779.html" title="Uighur or Uyghur?">newer</a> or <a id="older" href="http://archives.miloush.net/michkap/archive/2006/07/14/665714.html" title="Can the CP_ACP be UTF-8?">older</a> post, or back to <a href="http://archives.miloush.net/michkap/archive/index.html">index</a> or <a href="http://archives.miloush.net/michkap/archive/index.html#2006-07">month</a> or <a href="http://archives.miloush.net/michkap/archive/index.html#2006-07-15">day</a></em></p></body>
<!-- Mirrored from archives.miloush.net/michkap/archive/2006/07/15/666717.html by HTTrack Website Copier/3.x [XR&CO'2014], Thu, 25 May 2017 00:42:39 GMT -->
</html>