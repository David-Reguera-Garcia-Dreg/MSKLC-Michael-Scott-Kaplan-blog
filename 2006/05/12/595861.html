<html>
<!-- Mirrored from archives.miloush.net/michkap/archive/2006/05/12/595861.html by HTTrack Website Copier/3.x [XR&CO'2014], Thu, 25 May 2017 00:42:39 GMT -->
<head><meta charset="utf-8" /><meta name="viewport" content="width=device-width" /><title>Don't use lstrcmp if you don't need it</title></head><body>
<h1>Don't use lstrcmp if you don't need it</h1>
<p><em>by Michael S. Kaplan, published on 2006/05/12 03:01 -04:00, original URI: http://blogs.msdn.com/b/michkap/archive/2006/05/12/595861.aspx</em></p>
<hr/> <!-- Archival Source: ProcessPostNew -->
<P><FONT face=Tahoma>It was over a year ago I posted <STRONG><A HREF="http://archives.miloush.net/michkap/archive/2005/03/12/394420.html">Performance gains at the cost of your own components</A></STRONG>, where I talked about the shell game that people play with peformance gains, sometimes. You know, where one component speeds up but it is done in such a way that someone else will seem slower. Kind of like skipping out on the check so that the person you had lunch with can pay it, but perhaps a bit more polite? :-)</FONT></P>
<P><FONT face=Tahoma>But all jokes aside, that whole "lightning fast init phase" is still very important, and probably always will be. No user wants to pay a penalty before they feel they have accomplished anything....</FONT></P>
<P><FONT face=Tahoma>Anyway, we ran across one of those cases in Vista just recently. As a part of&nbsp;the team's&nbsp;performance work, the code was set up to delay some of the initialization until/unless it was needed.</FONT></P>
<P><FONT face=Tahoma>Which is a good thing, because even though it probably will be needed at some point, it is usually not needed when a process is initialized.</FONT></P>
<P><FONT face=Tahoma>Of course as soon as someone actually needs&nbsp;a locale's information to be loaded there will be that perf hit. Suddenly it is the fault of the function that is called later (in this case it was <A href="http://msdn.microsoft.com/library/en-us/winui/winui/windowsuserinterface/resources/strings/stringreference/stringfunctions/comparestring.asphttp://msdn.microsoft.com/library/en-us/winui/winui/windowsuserinterface/resources/strings/stringreference/stringfunctions/comparestring.asp">CompareString</A>, but it could have been anything, really).</FONT></P>
<P><FONT face=Tahoma>The story had a very happy ending, though. It turns out that the reason that they were calling <A href="http://msdn.microsoft.com/library/en-us/winui/winui/windowsuserinterface/resources/strings/stringreference/stringfunctions/comparestring.asphttp://msdn.microsoft.com/library/en-us/winui/winui/windowsuserinterface/resources/strings/stringreference/stringfunctions/comparestring.asp">CompareString</A>&nbsp;was that they actually were not calling it; they were calling <A href="http://msdn.microsoft.com/library/en-us/winui/winui/windowsuserinterface/resources/strings/stringreference/stringfunctions/lstrcmp.asp">lstrcmp</A>. And the fact is that they did not need to be getting a linguistically appropriate result back, and that <A HREF="http://archives.miloush.net/michkap/archive/2005/12/22/506595.html"><STRONG>CompareStringOrdinal</STRONG></A> would be not only faster in general and more appropriate in terms of results, but in this particular&nbsp;scenario for a specific application it would delay loading up the locale information a bit longer.</FONT></P>
<P><FONT face=Tahoma>I am a lot less cynical about this than I used to be (don't worry, I have plenty of other things to be cynical about).</FONT></P>
<P><FONT face=Tahoma>I mean, i</FONT><FONT face=Tahoma>t is a shell game, sure. </FONT><FONT face=Tahoma>But the end result is an improvement in performance that can&nbsp;potentially affect every process on the system, whether it is noticed or not. And that can't ever be a bad thing. Especially in cases like this one when the results are actually more likely to be correct and the difference <EM>is</EM> noticed! :-)</FONT></P>
<P><FONT face=Tahoma>So, the moral of the story? Don't use the functions that provide linguistically appropriate results if you don't need an answer with such considerations kept in mind. There is that cool new <A HREF="http://archives.miloush.net/michkap/archive/2005/12/22/506595.html"><STRONG>CompareStringOrdinal</STRONG></A>&nbsp;function that is just waiting for the chance to do the non-linguistic thing when it is needed....</FONT></P>
<P><FONT face=Tahoma></FONT>&nbsp;</P>
<P><FONT face=Tahoma color=#ff1493><EM>This post brought to you by</EM> "<FONT face=Nyala size=6>áŠŸ</FONT>" <EM>(<A href="http://www.fileformat.info/info/unicode/char/129f">U+129f</A>, a.k.a. ETHIOPIC&nbsp;SYLLABLE NYWA)</EM></FONT></P>
<hr/><p><a id="595955" href="#595955">#</a> <strong>Adam</strong> on 12 May 2006 4:42 AM:</p><div style="margin-left: 1em">So, you'll need a resource at some point later in the execution, don't want to pay the price up front for loading it, but also don't want the perf hit when you finally do have to load it?<br><br>How about a function LoadLocaleInBackground()? It creates a new thread, lowers its priority a bit, starts it on the path of loading this resource and returns almost instantly to get on with important stuff.<br><br>If LoadLocaleInBackground() is never called, the first call that actually needs that data does what it does at the moment and you get the perf hit. No big deal, it's just existing behaviour.<br><br>If the function is called, and the background thread has loaded all the data into the app before the first funtion that actually uses that data it is called, great. No delay. Everyone wins.<br><br>If the function is called and the background thread is in the middle of loading the data when another function that needs it is called, the foreground thread can just wait for the background thread to finish. It shouldn't spend as much time waiting as it would have if it needed to load all the data from scratch itself, so you should still win.<br><br>As more apps become i18nised/l10nised[0], this could help more of them. Apart from the complexity[1], what have I missed here?<br><br>[0] Yes, I know that what that exapnds to is wrong, but I don't care!<br>[1] And, yes, I know I shouldn't dismiss complexity that glibly.</div>
<p><a id="596087" href="#596087">#</a> <strong>Michael S. Kaplan</strong> on 12 May 2006 8:55 AM:</p><div style="margin-left: 1em">I don't think you missed anything, but there are additional considerations here. Such as of the hit of the creation of a new thread in terms of soft page faults (the new 1mb of stack, etc.) and of course the kernel call for the thread creation itself. For a non-zero expense, it is better to put it off until you can't anymore....</div>
<p><a id="596329" href="#596329">#</a> <strong>Gabe</strong> on 12 May 2006 2:08 PM:</p><div style="margin-left: 1em">Well, presumably this background thread would be initializing everything that you don't need yet but which will be a perf hit when needed (like OLE). So the hit of the extra thread would be spread across everything that's being initialized.</div>
<p><a id="596460" href="#596460">#</a> <strong>Michael S. Kaplan</strong> on 12 May 2006 4:58 PM:</p><div style="margin-left: 1em">Yes, but it means additional soft page faults on app boot for the new thread, which will be a perf concern.</div>
<p><a id="596595" href="#596595">#</a> <strong>Gabe</strong> on 12 May 2006 7:23 PM:</p><div style="margin-left: 1em">As long as this initialization is going on in the background, there's really no need for it to happen on app boot. If I were implementing this sort of thing, I might wait 10 seconds, then start the thread, which might wait 10 seconds between initializing each different subsystem. Of course if anything was needed before it was initialized, the init would happen on the foreground thread instead.<br><br>BTW, the thread would only fault in the first couple pages of the stack. The 1MB would be allocated, but I don't expect that more than a couple pages would likely be used in most cases.</div>
<p><a id="596606" href="#596606">#</a> <strong>Michael S. Kaplan</strong> on 12 May 2006 7:46 PM:</p><div style="margin-left: 1em">Hi Gabe --<br><br>I think the point is really being missed here.<br><br>No one is complaining about the performance of lstrcmp generally that would require such a scheme -- the specific complaint was a perf. scenario tied to a delay in app bpoot that was narrowed down to our code (and we pointed out that the best fix was to not call us there!).<br><br>Perf. fixes always have to have a basis -- something that is slow that is linked to a particular area of the code....</div>
<p><a id="596644" href="#596644">#</a> <strong>Ben Cooke</strong> on 12 May 2006 9:14 PM:</p><div style="margin-left: 1em">Is there a cool *old* function that I should use when I'm targetting versions of Windows that have actually been released as well as Vista?</div>
<p><a id="596709" href="#596709">#</a> <strong>Michael S. Kaplan</strong> on 12 May 2006 11:44 PM:</p><div style="margin-left: 1em">If you need to know whether two strings are equal (which is usually what is happening here; seldom do people need to know what comes first in these cases!) than RtlCompareUnicodeString or RtlEqualUnicodeString both can make excellent choices.... :-)</div>
<hr/><p><em>go to <a id="newer" href="http://archives.miloush.net/michkap/archive/2006/05/12/596254.html" title="MSN in Tamil!">newer</a> or <a id="older" href="http://archives.miloush.net/michkap/archive/2006/05/11/595346.html" title="Let Me Make One Thing Perfectly Clear[Type]">older</a> post, or back to <a href="http://archives.miloush.net/michkap/archive/index.html">index</a> or <a href="http://archives.miloush.net/michkap/archive/index.html#2006-05">month</a> or <a href="http://archives.miloush.net/michkap/archive/index.html#2006-05-12">day</a></em></p></body>
<!-- Mirrored from archives.miloush.net/michkap/archive/2006/05/12/595861.html by HTTrack Website Copier/3.x [XR&CO'2014], Thu, 25 May 2017 00:42:39 GMT -->
</html>