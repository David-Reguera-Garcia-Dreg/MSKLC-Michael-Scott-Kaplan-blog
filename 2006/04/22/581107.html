<html>
<!-- Mirrored from archives.miloush.net/michkap/archive/2006/04/22/581107.html by HTTrack Website Copier/3.x [XR&CO'2014], Thu, 25 May 2017 00:42:39 GMT -->
<head><meta charset="utf-8" /><meta name="viewport" content="width=device-width" /><title>Getting all you can out of a keyboard layout, Part #10a</title></head><body>
<h1>Getting all you can out of a keyboard layout, Part #10a</h1>
<p><em>by Michael S. Kaplan, published on 2006/04/22 07:01 -04:00, original URI: http://blogs.msdn.com/b/michkap/archive/2006/04/22/581107.aspx</em></p>
<hr/> <!-- Archival Source: ProcessPostNew -->
<P><FONT face=Tahoma>We have come a long way in this series, haven't we? :-)</FONT></P>
<P><FONT face=Tahoma>Look at all that we have covered:</FONT></P>
<UL>
<LI><FONT face=Tahoma><FONT face=Tahoma>Part <A href="http://archives.miloush.net/michkap/archive/2006/03/23/558658.html"><STRONG>0</STRONG></A>: An enumeration with all of the Virtual Key values defined in winuser.h;</FONT></FONT> 
<LI><FONT face=Tahoma><FONT face=Tahoma>Part <A href="http://archives.miloush.net/michkap/archive/2006/03/23/558674.html"><STRONG>1</STRONG></A>: Getting Scan codes, Virtual Keys, and a single character in one shift state;</FONT></FONT> 
<LI><FONT face=Tahoma><FONT face=Tahoma>Part <A href="http://archives.miloush.net/michkap/archive/2006/03/24/558715.html"><STRONG>2</STRONG></A>: Making sure to not unload the keyboard if the user already had it loaded;</FONT></FONT> 
<LI><FONT face=Tahoma><FONT face=Tahoma>Part <A href="http://archives.miloush.net/michkap/archive/2006/03/24/559169.html"><STRONG>3</STRONG></A>: Finding dead keys and ligatures;</FONT></FONT> 
<LI><FONT face=Tahoma><FONT face=Tahoma>Part <A href="http://archives.miloush.net/michkap/archive/2006/03/27/561353.html"><STRONG>4</STRONG></A>: Moving SC/VK code determination that is static per layout out of the inner loop;</FONT></FONT> 
<LI><FONT face=Tahoma><FONT face=Tahoma>Part <A href="http://archives.miloush.net/michkap/archive/2006/03/28/561541.html"><STRONG>5</STRONG></A>: Character detection for the easy shift states;</FONT></FONT> 
<LI><FONT face=Tahoma><FONT face=Tahoma>Part <A href="http://archives.miloush.net/michkap/archive/2006/03/31/565407.html"><STRONG>6</STRONG></A>: Getting numeric keypad assignments;</FONT></FONT> 
<LI><FONT face=Tahoma><FONT face=Tahoma>Part <A href="http://archives.miloush.net/michkap/archive/2006/04/06/569632.html"><STRONG>7</STRONG></A>: Getting the base and combining characters for all of the (previously detected dead keys);</FONT></FONT> 
<LI><FONT face=Tahoma><FONT face=Tahoma>Part <A href="http://archives.miloush.net/michkap/archive/2006/04/10/570570.html"><STRONG>8</STRONG></A>: Detecting usage of the CAPS LOCK key (both SGCAPS and persistent shifting)</FONT></FONT> 
<LI><FONT face=Tahoma><FONT face=Tahoma>Parts <A href="http://archives.miloush.net/michkap/archive/2006/04/12/575080.html"><STRONG>9a</STRONG></A> and <A href="http://archives.miloush.net/michkap/archive/2006/04/13/575500.html"><STRONG>9b</STRONG></A>: Character detection of the harder shift states</FONT></LI></UL></FONT>
<P><FONT face=Tahoma>What a long, strange trip it has been!</FONT></P>
<P><FONT face=Tahoma>There is really only one item left on that list of things to do that I mentioned originally, and that is dealing with <A href="http://archives.miloush.net/michkap/archive/2005/11/15/492200.html">chained dead keys</A>, another feature that <A href="http://www.microsoft.com/globaldev/tools/msklc.mspx">MSKLC</A> does not support.</FONT></P>
<P><FONT face=Tahoma>It is a slightly more interesting feature to discuss given that (unlike the harder shift states) does not really seem to exist in any keyboard layout that ships with Windows. So unless someone has been working with the DDK to build such a keyboard, there is no way to readily test what is being done.</FONT></P>
<P><FONT face=Tahoma>I'll try not to let the somewhat theoretical nature of this post dissuade me too much. In order to dissuade you, the reader, I will try to point out more immediately relevant items as they come up. :-)</FONT></P>
<P><FONT face=Tahoma>Anyone who has both used MSKLC and also been following along with this series will notice that I have completely ignored the connection between the dead key assignments and the tables that exist, one per dead key. This connection (which is a definite part of the MSKLC UI) is completely ignored in the code that this series has put together.</FONT></P>
<P><FONT face=Tahoma>This omission is intentional; no direct connection actually exists. The code here in this series has it right!</FONT></P>
<P><FONT face=Tahoma>If you think about the consequences of that notion -- that you explicitly tell a key that <STRONG>it is a dead key</STRONG> and it will then look up its own individual <STRONG>dead key table</STRONG> on the next keystoke. Such an architecture goes a long way to explaining the reason why you must have a valid character at each stage of a chained dead key -- because once you jump to a new "dead key table" there is no state information about the old "dead key table". And since the dead key tables only allow a single UTF-16 code unit for the base character and one more for the combined character, there is simply nowhere to store the knowledge or the need for additional characters.</FONT></P>
<P><FONT face=Tahoma>This may cause people to ask why MSKLC was designed the way it was -- it was rather intensely discussed at the time, and ther was just no intuitive way we could find to show this "disconnected" model where dead key tables were not more directly tied to their dead keys.</FONT></P>
<P><FONT face=Tahoma>Given how&nbsp;uncommon the scenario of putting the same dead key into multiple keys is, it would be hard to really notice the problem (for example, to date no one has actually ever reported the issue!).</FONT></P>
<P><FONT face=Tahoma><EM>Clever people who are following this discussion can probably come up with a bug or two in MSKLC if they&nbsp;put some thought to&nbsp;it. These would basically be known limitations, but I won't give any more hints about </EM>that<EM> in case there are people who wanted to try to spot a bug. :-)</EM></FONT></P>
<P><FONT face=Tahoma>Could this all be changed? Well, obviously any architecture that blocks a particular feature admits to a single last-resort workaround: re-architecting how the code works. But that would cause all kinds of other problems like breaking backcompat with any keyboard already created, not to mention taking code that is very stable and putting it in play again. And that does not even get into needing to create multiple versions of every keyboard layout so that you could install on the old and the rearchitected code. Code that does not even belong to our team, so we'd have to convince another team to do this work.</FONT></P>
<P><FONT face=Tahoma>The price is just a bit too high, sorry. :-(</FONT></P>
<P><FONT face=Tahoma>Anyway, getting back to the chained dead keys.</FONT></P>
<P><FONT face=Tahoma>All you would need to do is change the code in a few places:</FONT></P>
<UL>
<LI><FONT face=Tahoma>In the DeadKey class, add the notion of saying whether the combined character is itself a dead key;</FONT> 
<LI><FONT face=Tahoma>In the ProcessDeadKey procedure, allow it to have knowledge of multiple dead keys that would need to be applied when it scrolls through every other character;</FONT> 
<LI><FONT face=Tahoma>In the ProcessDeadKey procedure, when the rc of the call to <A href="http://msdn.microsoft.com/library/en-us/winui/winui/windowsuserinterface/userinput/keyboardinput/keyboardinputreference/keyboardinputfunctions/tounicodeex.asp">ToUnicodeEx</A> is -1, check to make sure the dead key is not identical to either the one in process or any of the ones already processed; <STRONG>if it is neither of these</STRONG>, then use that new DeadKey class feature and call ProcessDeadKey again, recursively.</FONT></LI></UL>
<P><FONT face=Tahoma>One more problem that I did not really take care of initially (I admit I was waiting to see if someone would ask about it -- no one is getting any jobs this time around!) is the poor use of the <A href="http://msdn2.microsoft.com/en-us/library/system.collections.arraylist.aspx">ArrayList class</A> to store:</FONT></P>
<UL>
<LI><FONT face=Tahoma>The collection of DeadKey objects in the keyboard layout;</FONT> 
<LI><FONT face=Tahoma>The collection of Base characters in each DeadKey object.</FONT></LI></UL>
<P><FONT face=Tahoma>I mean, the characteristics of both of these collections are:</FONT></P>
<OL>
<LI><FONT face=Tahoma>a somewhat unbounded (or at least unknown) size;</FONT> 
<LI><FONT face=Tahoma>the items within them that would act as keys must be unique;</FONT> 
<LI><FONT face=Tahoma>keys are the size of one UTF-16 code unit, basically a ushort;</FONT> 
<LI><FONT face=Tahoma>must be able to easily look up the members of the collection by the key;</FONT> 
<LI><FONT face=Tahoma>must be able to dump out all of the members of the collection.</FONT></LI></OL>
<P><FONT face=Tahoma>Currently, the code in both cases scrolls through the entire collection to look for duplicates, since the ArrayList class that is so well suited for the first and fifth of these items is so piss poor at the second, third, and fourth. </FONT><FONT face=Tahoma>Certainly there are data structures that are better suited here, right? :-)</FONT></P>
<P><FONT face=Tahoma>The <A href="http://msdn2.microsoft.com/en-us/library/system.collections.hashtable(VS.80).aspx">Hashtable class</A> is obviously a better choice, I think -- using (ushort)char for the key values.</FONT></P>
<P><FONT face=Tahoma>This last change is not required, obviously. But it would save our performace a bit. Not to mention would keep us from needing to shudder as I have for the last few revs of our code. :-)</FONT></P>
<P><FONT face=Tahoma>Of course without a keyboard layout to test this new code on, the primary goal will be to make sure the existing scenarios do not regress. I'll post up the new code soon in Part 10b of the series.</FONT></P>
<P><FONT face=Tahoma>and perhaps how to create these sorts of keyboards another day....</FONT></P>
<P><FONT face=Tahoma></FONT></P>
<P><FONT color=#ff1493><FONT face=Tahoma><EM>This post brought to you by</EM> "A" </FONT></FONT><EM><FONT color=#ff1493><FONT face=Tahoma>(</FONT><A href="http://www.fileformat.info/info/unicode/char/0041"><FONT face=Tahoma>U+0041</FONT></A><FONT face=Tahoma>, LATIN CAPITAL LETTER A)<BR><FONT size=1>A Unicode character that is in the very small family of those whose VK value is the same as it's code point, also used for the hexidecimal version of the number 10!</FONT></FONT></FONT></EM></P>
<hr/><p><a id="8574201" href="#8574201">#</a> <strong>dk273</strong> on 4 Jun 2008 7:13 PM:</p><div style="margin-left: 1em"><p>I am totally ignorant on C# (I'm the guy who likes IBM mainframe assembler and can just about do VB6 and C++ with MFC - not even .Net yet!) &nbsp;However, I am looking to see if anyone has been able successfully to convert Michael's good code here (well in the part 9b) into good old C / MFC code?</p>
<p>If so, would they be willing to post it?</p>
<p>Many thanks,</p>
<p>David</p></div>
<p><a id="9020825" href="#9020825">#</a> <strong>Tom</strong> on 28 Oct 2008 3:56 PM:</p><div style="margin-left: 1em"><p>Michael,</p>
<p>This is a great series -- it's really helped us. &nbsp;We're trying to make some onscreen keyboard keys that display the correct labels given the user's current language/keyboard settings. &nbsp;It works on our development machines. &nbsp;We're nervous about it working with the many keyboard setups out in the real world. &nbsp;My question has to do with scan codes. &nbsp;Our current design has a scan code in each key we're trying to draw and uses a table like the one you built in this series to map those scan codes on to vk_ codes and ultimately characters so we can display appropriate labels. &nbsp;The problem is that scan codes are described in various authoritative places as "hardware dependent." &nbsp;Does that mean that I cannot assume that the second key on the fourth row of the user's keyboard will generate a scan code of 0x1E? &nbsp;If I can't assume this, I don't see a way around maintaining our own table of the physical locations of the different virtual keys on all different keyboard/language combinations and refering to those whenever the settings change. &nbsp;I hope I'm missing something!</p>
<p>Thanks very much.</p></div>
<p><a id="9022775" href="#9022775">#</a> <strong>Michael S. Kaplan</strong> on 29 Oct 2008 2:45 PM:</p><div style="margin-left: 1em"><p>They are hardware dependent, and different bits of hardware in different parts of the world will often have slightly different locations for a few keys (e.g. no 102 key, differently shaped backspace, differently shaped enter key, moved around other OEM keys, the extra key on the Japanese keyboard, etc.). And that is before I get into things like laptop keyboard layouts.</p>
<p>This will always be true, because all of these keyboards are slightly different. But there are some major groupings that will cover all of them....</p>
</div>
<p><a id="9023075" href="#9023075">#</a> <strong>Tom</strong> on 29 Oct 2008 5:45 PM:</p><div style="margin-left: 1em"><p>Thanks -- thats what we were afraid of. &nbsp;I suppose we could load some known HKL and test the scan code &lt;-&gt; VK_ mapping against what we expect it to be and then create a translation table if necessary that maps the user's scan codes to &quot;our&quot; scan codes and vice versa. &nbsp;Probably not the ugliest thing anybody has ever had to do...</p></div>
<p><a id="9023359" href="#9023359">#</a> <strong>Michael S. Kaplan</strong> on 29 Oct 2008 8:49 PM:</p><div style="margin-left: 1em"><p>I would actually recommend getting a few of the different layouts so you will see the differences -- in most cases,the scan code are there but in different places. If you have the target keyboards you will have a better sense of what you want to &quot;detect&quot; here...</p>
</div>
<p><a id="9026427" href="#9026427">#</a> <strong>Tom</strong> on 31 Oct 2008 7:26 AM:</p><div style="margin-left: 1em"><p>Good call. I'm particularly interested in scan code changes that are just the result of an OEM's decision to map scan codes differently from the standard way and compensate in their driver software. &nbsp;I'm less concerned about key placement differences than I am about different scan code -&gt; VK_ mappings for a given HKL. &nbsp;We can handle key placement differences as exceptions in our layout code.</p></div>
<p><strong>Michel K</strong> on 25 Oct 2011 6:23 AM:</p><div style="margin-left: 1em"><p>Hi, nice blog you have here!</p>
<p>But where is part 10b ??</p>
</div>
<hr/><p><em>referenced by</em></p><div style="margin-left: 1em"><p>2012/05/03 <a href="http://archives.miloush.net/michkap/archive/2012/05/03/10300316.html">The missing blog Part #10b?</a></p><p>2011/04/16 <a href="http://archives.miloush.net/michkap/archive/2011/04/16/10154700.html">Chain Chain Chain, Chain of Dead Keys</a></p><p>2008/09/03 <a href="http://archives.miloush.net/michkap/archive/2008/09/03/8921419.html">Need to know the VK for A, ay?</a></p><p>2008/08/16 <a href="http://archives.miloush.net/michkap/archive/2008/08/16/8871262.html">Optimus: from science fiction to fiction to frustration to geek porn, in just 24 months</a></p><p>2008/07/27 <a href="http://archives.miloush.net/michkap/archive/2008/07/27/8777624.html">Doing virtual simulationary keyboard stuff, only for real</a></p><p>2008/02/11 <a href="http://archives.miloush.net/michkap/archive/2008/02/11/7611812.html">Who assigns the VK_OEM_* values in keyboards?</a></p><p>2006/09/10 <a href="http://archives.miloush.net/michkap/archive/2006/09/10/748775.html">Sometimes you *want* to interfere with the keyboard's state buffer</a></p></div><p><em>go to <a id="newer" href="http://archives.miloush.net/michkap/archive/2006/04/22/581356.html" title="Unicode? Zip don&#39;t need no stinking Unicode!">newer</a> or <a id="older" href="http://archives.miloush.net/michkap/archive/2006/04/22/580636.html" title="Dial 911, code page 864 isn&#39;t breathing">older</a> post, or back to <a href="http://archives.miloush.net/michkap/archive/index.html">index</a> or <a href="http://archives.miloush.net/michkap/archive/index.html#2006-04">month</a> or <a href="http://archives.miloush.net/michkap/archive/index.html#2006-04-22">day</a></em></p></body>
<!-- Mirrored from archives.miloush.net/michkap/archive/2006/04/22/581107.html by HTTrack Website Copier/3.x [XR&CO'2014], Thu, 25 May 2017 00:42:39 GMT -->
</html>