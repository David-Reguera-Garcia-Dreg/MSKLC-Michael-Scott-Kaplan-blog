<html>
<!-- Mirrored from archives.miloush.net/michkap/archive/2006/04/17/577325.html by HTTrack Website Copier/3.x [XR&CO'2014], Thu, 25 May 2017 00:42:40 GMT -->
<head><meta charset="utf-8" /><meta name="viewport" content="width=device-width" /><title>Some strings need to feel validated</title></head><body>
<h1>Some strings need to feel validated</h1>
<p><em>by Michael S. Kaplan, published on 2006/04/17 07:01 -04:00, original URI: http://blogs.msdn.com/b/michkap/archive/2006/04/17/577325.aspx</em></p>
<hr/> <!-- Archival Source: ProcessPostNew -->
<P><FONT face=Tahoma>Reader <A href="http://spaces.msn.com/jdanielsmith/">J. Daniel Smith</A> asked the following in the Suggestion Box:</FONT></P>
<BLOCKQUOTE dir=ltr style="MARGIN-RIGHT: 0px">
<BLOCKQUOTE dir=ltr style="MARGIN-RIGHT: 0px">
<P><FONT face="Times New Roman" size=2>I'm wondering about "invalid" strings in .NET; I searched through your archives and didn't find anything exactly on-point, maybe I didn't search long enough... <BR><BR>It's straight-forward to create a semantically invalid string: <BR>&nbsp; char high = '\ud801'; // high: d800-dbff <BR>&nbsp; char low = '\udcff'; // low: dc00-dfff <BR>&nbsp; char[] chars = new char[8]; <BR>&nbsp; chars[0] = high; <BR>&nbsp; chars[1] = low; <BR><BR>&nbsp; chars[2] = high; <BR>&nbsp; chars[3] = high; // invalid <BR><BR>&nbsp; chars[4] = low; // invalid <BR>&nbsp; chars[5] = low; <BR><BR>&nbsp; chars[6] = low; // invalid <BR>&nbsp; chars[7] = high; // invalid <BR><BR>&nbsp; byte[] bytes = Encoding.Unicode.GetBytes(chars); <BR>&nbsp; string s1 = Encoding.Unicode.GetString(bytes); <BR>&nbsp; string s2 = new String(chars); <BR>where and when can such a string create problems? <BR><BR>The reason this comes about is a bit more practical than the contrived sample; for example converting the value of RSAPKCS1SignatureFormatter.CreateSignature() to a string: <BR>&nbsp; byte[] bytes = ...; // say RSAPKCS1SignatureFormatter.CreateSignature() <BR>&nbsp; string s = Encoding.Unicode.GetString(bytes); <BR>Eventually, the string will get converted to Base64 to make it easy to move around (via email, view in Notepad, etc.), but before that happens I want to combine it with other strings (but no sorting, searching, casing, etc.). &nbsp;Thus, I don't want to immediately convert the byte[] to Base64 and then add another Base64 conversion on top of that. <BR><BR>I've tried things like StringInfo.ParseCombiningCharacters() in an attempt to get the invalid string to "fail" somehow, but that seems to work fine. &nbsp;I'm sure strict Unicode semantics are enforced at some point, but where &amp; when? &nbsp;If I just use a string for internal data (and say avoid displaying it to the user which would involve fonts, etc.) do I need to be concerned with Unicode semantics?</FONT></P></BLOCKQUOTE></BLOCKQUOTE>
<P><FONT face=Tahoma>This is a topic about which I have not yet posted, so he wasn't missing anything. :-)</FONT></P>
<P><FONT face=Tahoma><EM>(By the way, you know the old saw about the guy who quit the patent office since there was nothing new that would be invented? It isn't really true, as the guy who said it was speaking against that point of view. There will always be some new internationalization issue to post about!)</EM></FONT></P>
<P><FONT face=Tahoma>If you look at the <A href="http://msdn2.microsoft.com/en-us/library/system.text.encoding(VS.80).aspx">Encoding class</A>, there is one way that&nbsp;may perhaps&nbsp;be prized above all others, especially starting in the 2.0 version of the .NET Framework -- the <A href="http://msdn.microsoft.com/library/en-us/cpref/html/frlrfSystemTextUnicodeEncodingClassTopic.asp">UnicodeEncoding class</A>. The only two things that conversions in this "code page" will do is:</FONT></P>
<UL>
<LI><FONT face=Tahoma>Move text between a byte array and a string, and</FONT> 
<LI><FONT face=Tahoma>Validate the data to make sure it is&nbsp;not one of these illegal&nbsp;sequences</FONT></LI></UL>
<P><FONT face=Tahoma>It has the additional advantage is that you can use the new fallback support in 2.0 to be able to find out the exact location and nature of problems and to be able to completely customize what happens in those cases....</FONT></P>
<P><FONT face=Tahoma>I probably ought to put together a sample of a custom encoder/decoder fallback, though I'll probably just try and convince <A href="http://blogs.msdn.com/shawnste/">Shawn</A> to do one and then link to his when he does it, instead. He coded the feature, after all. :-)</FONT></P>
<P><FONT face=Tahoma></FONT>&nbsp;</P>
<P><FONT face=Tahoma color=#ff1493><EM>This post brought to you by</EM> "Ä£" <EM>(<A href="http://www.fileformat.info/info/unicode/char/0123">U+0123</A>, a.k.a. LATIN SMALL LETTER G WITH CEDILLA)</EM></FONT></P>
<hr/><p><a id="577586" href="#577586">#</a> <strong>Marc C Brooks</strong> on 17 Apr 2006 12:14 PM:</p><div style="margin-left: 1em">While your comments about the Encoding class are (no doubt!) correct, I think you've missed the point. &nbsp;He should NOT be converting the byte array to a string AT ALL. &nbsp;Never. &nbsp;Ever. &nbsp;It's just wrong.<br><br>Rather, he should concatenate the various byte arrays that he has (down-coverting any strings to byte arrays first, as needed). &nbsp;When he's ALL DONE building up this lovely sequence of bytes that have no relationship to a unicode string, he should then BASE64 encode the final array.<br><br>At the other end, he again converts from the BASE64 string to a byte array. &nbsp;This can then be decomposed appropriately into other bytes array slices, and THOSE can be handed to Encoding to get real string values.<br><br>This insures that he never gets (rightly, justly, and fairly) by the encoding not liking his arbitrary sequence of bytes; which is not, never will be, but might seem to be coincident with a unicode string.</div>
<p><a id="577614" href="#577614">#</a> <strong>Mihai</strong> on 17 Apr 2006 12:40 PM:</p><div style="margin-left: 1em">100% agree with IDisposable. When one has a random sequence of bytes, which do not represent a string, then it is not correct to convert it to string.<br></div>
<p><a id="577622" href="#577622">#</a> <strong>Michael S. Kaplan</strong> on 17 Apr 2006 12:59 PM:</p><div style="margin-left: 1em">I got the point, I just morphed the question into one that I thought was more important to answer....<br><br>I made the other point about not using strings to hold non-string data in a different post (<a rel="nofollow" target="_new" href="http://archives.miloush.net/michkap/archive/2005/09/27/474568.html">http://blogs.msdn.com/michkap/archive/2005/09/27/474568.aspx</a>) already. :-)<br><br>But most of this question was purposely constructing invalid surrogate sequences, which is not binary data but intentionally invalid strings.....</div>
<p><a id="577688" href="#577688">#</a> <strong>Maurits [MSFT]</strong> on 17 Apr 2006 2:32 PM:</p><div style="margin-left: 1em">&gt; concatenate the various byte arrays<br><br>Is there an overload of &quot;+&quot; for byte arrays?</div>
<p><a id="578452" href="#578452">#</a> <strong>J. Daniel Smith</strong> on 18 Apr 2006 2:52 PM:</p><div style="margin-left: 1em">IDisposable: I was trying to figure out a way to not base64 encode data that is already base64 encoded; but I think I determined it wasn't possible in my situtation.<br><br>Using invalid surrogates was just to have code to show a known invalid string. &nbsp;Something like random bytes wouldn't necessarily always result in an invalid string.<br><br><a rel="nofollow" target="_new" href="http://archives.miloush.net/michkap/archive/2005/09/27/474568.html">http://blogs.msdn.com/michkap/archive/2005/09/27/474568.aspx</a> might be the blog entry I didn't find.<br><br></div>
<p><a id="578503" href="#578503">#</a> <strong>Michael S. Kaplan</strong> on 18 Apr 2006 4:08 PM:</p><div style="margin-left: 1em">You should not ever have to Base64 encode data that is already Base64 encoded --- but OTOH you should *never* be sending Base64 encoded strings through the encoding classes?</div>
<hr/><p><em>go to <a id="newer" href="http://archives.miloush.net/michkap/archive/2006/04/17/577964.html" title="Aimee Mann on the TV show Love Monkey">newer</a> or <a id="older" href="http://archives.miloush.net/michkap/archive/2006/04/17/577196.html" title="Get off my freaking key!">older</a> post, or back to <a href="http://archives.miloush.net/michkap/archive/index.html">index</a> or <a href="http://archives.miloush.net/michkap/archive/index.html#2006-04">month</a> or <a href="http://archives.miloush.net/michkap/archive/index.html#2006-04-17">day</a></em></p></body>
<!-- Mirrored from archives.miloush.net/michkap/archive/2006/04/17/577325.html by HTTrack Website Copier/3.x [XR&CO'2014], Thu, 25 May 2017 00:42:40 GMT -->
</html>