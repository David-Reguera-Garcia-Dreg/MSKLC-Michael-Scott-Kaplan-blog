<html>
<!-- Mirrored from archives.miloush.net/michkap/archive/2006/04/24/581700.html by HTTrack Website Copier/3.x [XR&CO'2014], Thu, 25 May 2017 00:42:39 GMT -->
<head><meta charset="utf-8" /><meta name="viewport" content="width=device-width" /><title>When the documentation is confusing, it is often because the functionality is, too</title></head><body>
<h1>When the documentation is confusing, it is often because the functionality is, too</h1>
<p><em>by Michael S. Kaplan, published on 2006/04/24 04:01 -04:00, original URI: http://blogs.msdn.com/b/michkap/archive/2006/04/24/581700.aspx</em></p>
<hr/> <!-- Archival Source: ProcessPostNew -->
<P><FONT face=Tahoma>It is easy to take cheap shots at documentation writers for their mistakes.</FONT></P>
<P><FONT face=Tahoma>But it is usually placing the blame in the wrong place, since in many cases it is the actual functionality that was confusing first. So if the writer's attempts to clarify that which is hard to explain fall short then it falls upon the PM/developer/tester of the functionality to step up and help with that....</FONT></P>
<P><FONT face=Tahoma><EM>(In fact this week we are doing a doc. review for Vista to try and help with this!)</EM></FONT></P>
<P><FONT face=Tahoma>Anyway, way back near the beginning of this whole&nbsp;blogging adventure for me, I posted about <STRONG><A href="http://archives.miloush.net/michkap/archive/2004/12/19/325199.html">API Consistency and Developer Comfort</A></STRONG>. In it I talked about some of those consistencies between small groups of functions within the Win32 API.</FONT></P>
<P><FONT face=Tahoma>It is a comfort thing, as I said. But sometimes it can be a burden.</FONT></P>
<P><FONT face=Tahoma>Let's take return values for example. In most of the NLS API that does any kind of conversion, transformation,&nbsp;or retrieval, the pattern is simple:</FONT></P>
<UL>
<LI><FONT face=Tahoma>On success when NULL is passed for the destination buffer, return the required size, including the NULL character if the NULL character was in the source;</FONT> 
<LI><FONT face=Tahoma>On success when a destination buffer was passed, return the size of what was converted/transformed/retrieved, including the NULL character if the NULL character was in the source;</FONT> 
<LI><FONT face=Tahoma>On failure, return 0 and GetLastError will return the reason; the destination buffer, if specified, is usually not touched.</FONT></LI></UL>
<P><FONT face=Tahoma>It is simple, sure. And pretty consistently applied across most of the functions.</FONT></P>
<P><FONT face=Tahoma>Of course&nbsp;one problem with this pattern is that you have to call it at least twice to get the size to use, or else risk allocating too much. Another is that there is a performance hit to getting the exact size. And yet another is that to not touch the destination buffer, the function may have to allocate.</FONT></P>
<P><FONT face=Tahoma>So, when Shawn did the dev work on the <A href="http://msdn.microsoft.com/library/en-us/intl/nls_normalize_string.asp">NormalizeString</A> function, a different pattern was used:</FONT></P><FONT face=Tahoma>
<BLOCKQUOTE dir=ltr style="MARGIN-RIGHT: 0px">
<P><FONT size=2>On success, the function returns the length of the normalized string in the destination buffer.<BR><BR></FONT><FONT size=2>If the destination buffer is NULL or if <I>cwDstLength</I> is zero, the return value is the estimated buffer length required to do the actual conversion.<BR><BR></FONT><FONT size=2>If the string in the input buffer is null-terminated or if <I>cwSrcLength</I> is -1, then the string written to the destination buffer will be null-terminated and the returned count of characters will include the terminating null character. <BR><BR></FONT><FONT size=2>If a problem occurs, the function return will be less than or equal to zero. The application should call </FONT><A href="http://msdn.microsoft.com/library/en-us/debug/base/getlasterror.asp"><B><FONT size=2>GetLastError</FONT></B></A><FONT size=2>, which will return one of the following values:</FONT></P>
<P>
<TABLE width="75%" border=1>
<TBODY>
<TR>
<TD><FONT size=2>ERROR_SUCCESS</FONT></TD>
<TD><FONT size=2>No error; this occurs when the actual size of the output string is zero.</FONT></TD></TR>
<TR>
<TD><FONT size=2>ERROR_INSUFFICIENT_BUFFER</FONT></TD>
<TD><FONT size=2>Need a bigger destination buffer. The return value is the negative of a better estimated guess of the required length. Try the conversion again with a buffer of -(Return Value) size.</FONT></TD></TR>
<TR>
<TD><FONT size=2>ERROR_INVALID_PARAMETER</FONT></TD>
<TD><FONT size=2>Input pointers were incorrect or normalization form was incorrect.</FONT></TD></TR>
<TR>
<TD><FONT size=2>ERROR_NO_UNICODE_TRANSLATION</FONT></TD>
<TD><FONT size=2>Invalid Unicode was found in string. The return value is the negative of the index of the location of the error in the input string.</FONT></TD></TR>
<TR>
<TD><FONT size=2>ERROR_BADDB</FONT></TD>
<TD><FONT size=2>The configuration registry database is corrupt.</FONT></TD></TR></TBODY></TABLE></FONT></P></BLOCKQUOTE>
<P><FONT face=Tahoma>There is inded a lot&nbsp;that is different in there, and you will probably notice that if pretty aggressively tries to deal with the three problems I mentioned. In fact, there are really only two real problems with it that I can see:</FONT></P>
<UL>
<LI><FONT face=Tahoma>It is different, so that whole consistency thing is lost;</FONT> 
<LI><FONT face=Tahoma>It is incredibly complicated, so many&nbsp;developers will [unintentionally] use it incorrectly (and groups like the Shell folks will be highly motivated to write wrappers to try and simplify the interface any time they need to use it).</FONT></LI></UL>
<P><FONT face=Tahoma>Now if anyone decides that the documentation for this function is confusing, I think it is pretty obvious that it has more to do with the underlying functionality than the actual SDK topic. :-)</FONT></P>
<P><FONT face=Tahoma size=4><EM>Everything up until now has been an introduction to a completely different example of overloading meanings that is much, much worse!</EM></FONT></P>
<P><FONT face=Tahoma>Let's talk about the <A href="http://msdn.microsoft.com/library/en-us/gdi/fontext_1wmq.asp">LOGFONT structure</A>.</FONT></P>
<P><FONT face=Tahoma>It's most important characteristic (for our purposes) is that <STRONG>it is not an actual&nbsp;font</STRONG>. It is a descripion of characteristics of either an actual font (e.g. if it is returned by the <A href="http://msdn.microsoft.com/library/en-us/gdi/devcons_912s.asp">GetObject</A> function when it is passed an <FONT face="Courier New"><STRONG>HFONT</STRONG></FONT>) or what a developer might want from a font (e.g. if it is being passed to the <A href="http://msdn.microsoft.com/library/en-us/gdi/fontext_4rw4.asp">CreateFontIndirect</A> function, or to the <A href="http://msdn.microsoft.com/library/en-us/gdi/fontext_4mk8.asp">EnumFontFamiliesEx</A> function -- though for latter only a few members are looked at).</FONT></P>
<P><FONT face=Tahoma>And its one member that is most completely overloaded to the point of confusion is the <STRONG><FONT face="Courier New">lfHeight</FONT></STRONG> member:</FONT></P><FONT face=Tahoma>
<DL>
<DD>
<P><FONT size=2>Specifies the height, in logical units, of the font's character cell or character. The character height value (also known as the em height) is the character cell height value minus the internal-leading value. The font mapper interprets the value specified in <B>lfHeight</B> in the following manner. </FONT></P>
<TABLE width="75%" border=1>
<TBODY>
<TR>
<TH width="16%"><FONT size=2>Value</FONT></TH>
<TH width="84%"><FONT size=2>Meaning</FONT></TH></TR>
<TR>
<TD><FONT size=2>&gt; 0</FONT></TD>
<TD><FONT size=2>The font mapper transforms this value into device units and matches it against the cell height of the available fonts.</FONT></TD></TR>
<TR>
<TD><FONT size=2>0</FONT></TD>
<TD><FONT size=2>The font mapper uses a default height value when it searches for a match.</FONT></TD></TR>
<TR>
<TD><FONT size=2>&lt; 0</FONT></TD>
<TD><FONT size=2>The font mapper transforms this value into device units and matches its absolute value against the character height of the available fonts.</FONT></TD></TR></TBODY></TABLE><BR>
<P><FONT size=2>For all height comparisons, the font mapper looks for the largest font that does not exceed the requested size.<BR><BR></FONT><FONT size=2>This mapping occurs when the font is used for the first time.<BR><BR></FONT><FONT size=2>For the MM_TEXT mapping mode, you can use the following formula to specify a height for a font with a specified point size: </FONT><PRE><FONT size=2>lfHeight = -MulDiv(PointSize, GetDeviceCaps(hDC, LOGPIXELSY), 72);</FONT></PRE></DD></DL></FONT>
<P><FONT face=Tahoma>So basically, there are three different&nbsp;ways that this member can specify the height (depending on whether the 32-bit value in <FONT face="Courier New"><STRONG>lfHeight</STRONG></FONT> is greater than, less than, or equal to zero. None of which map to what most humans (developer or otherwise) would use to specify a font size.</FONT></P>
<P><FONT face=Tahoma>And, to add insult to injury, in attempting to translate between what those humans would want and what the member specifies, it gives a formula that most people do not understand that depends on a functionality that it does not explain (the&nbsp;<FONT face="Courier New"><STRONG>MM_TEXT</STRONG></FONT> mapping mode). You can find out what the MM_TEXT mapping mode is by looking at the <A href="http://msdn.microsoft.com/library/en-us/gdi/cordspac_3ox1.asp">GetMapMode</A> and <A href="http://msdn.microsoft.com/library/en-us/gdi/cordspac_3c6d.asp">SetMapMode</A> functions. Though they take an HDC and it may be confusing to many people what happens to fonts in different mapping modes since the font and the mapping mode are set in such disconnected contexts....</FONT></P>
<P><FONT face=Tahoma>But let's get back to those three different usages of the <FONT face="Courier New"><STRONG>lfHeight</STRONG></FONT> member. They also have descriptions that start with "The font mapper..." which would indicate they forgot that&nbsp;the <A href="http://msdn.microsoft.com/library/en-us/gdi/fontext_1wmq.asp">LOGFONT</A>&nbsp;is also used to describe a font after the mapping has occurred. Oops?</FONT></P>
<P><FONT face=Tahoma>Another oops along the same line -- there is no indication in the docs about which type of return is expected if you use <A href="http://msdn.microsoft.com/library/en-us/gdi/devcons_912s.asp">GetObject</A>&nbsp;with an HFONT. Or if the expectation is that the result would be inconsistent or not. Or how to definitively get the size in such a case.</FONT></P>
<P><FONT face=Tahoma>And then of course, two of them talk about device units (which are also never defined within the function). You can look at the topic <A href="http://msdn.microsoft.com/library/en-us/gdi/fontext_73hv.asp">Device vs. Design Units</A> to get some clarity around those, though it is of course completely unclear what insight talking about them here provides. How about, since the <A href="http://msdn.microsoft.com/library/en-us/gdi/fontext_1wmq.asp">LOGFONT</A>&nbsp;is in no way tied to a device, avoid mentioning them here entirely?</FONT></P>
<P><FONT face=Tahoma>Ok, never mind all&nbsp;that communal critiquing, Let's take </FONT><FONT face=Tahoma>the&nbsp;and take those apart one at a time:</FONT></P>
<P><FONT face=Tahoma>When it is zero, "The font mapper uses a default height value when it searches for a match." What default value? How is it determined? </FONT><FONT face=Tahoma>Hmmm... a quick look at the source is very suggestive of a size of 12pt being considered a default, at least since NT 4.0. Hopefully it is never returned when one is querying font information like in a <A href="http://msdn.microsoft.com/library/en-us/gdi/devcons_912s.asp">GetObject</A>&nbsp;call. :-)</FONT></P>
<P><FONT face=Tahoma>When it is less than zero, "The font mapper transforms this value into device units and matches its absolute value against the character height of the available fonts." Once again, an undefined phrase "character height" -- what is meant there? Maybe they mean the <A href="http://msdn.microsoft.com/library/en-us/gdi/fontext_7ss2.asp">TEXTMETRIC</A>/<A href="http://msdn.microsoft.com/library/en-us/gdi/fontext_2zqq.asp">NEWTEXTMETRIC</A>'s <FONT face="Courier New"><STRONG>tmHeight</STRONG></FONT> member, which "Specifies the height (ascent + descent) of characters." That kind of makes sense, right? Unfortunately,&nbsp;this&nbsp;would be incorrect -- the calculation in this case is based on the the UnitsPerEm mentioned in&nbsp;that <A href="http://msdn.microsoft.com/library/en-us/gdi/fontext_73hv.asp">Device vs. Design Units</A>&nbsp;topic, "the em square size for the font". And that topic even says how to get it -- by using the <FONT face="Courier New"><STRONG>ntmSizeEm</STRONG></FONT> member of the <A href="http://msdn.microsoft.com/library/en-us/gdi/fontext_2zqq.asp">NEWTEXTMETRIC</A>&nbsp;structure.</FONT></P>
<P><FONT face=Tahoma>When it is greater than zero, "The font mapper transforms this value into device units and matches it against the cell height of the available fonts." And of course the cell height is also not defined. Though this one&nbsp;actually <STRONG>is</STRONG>&nbsp;based on the <A href="http://msdn.microsoft.com/library/en-us/gdi/fontext_7ss2.asp">TEXTMETRIC</A>/<A href="http://msdn.microsoft.com/library/en-us/gdi/fontext_2zqq.asp">NEWTEXTMETRIC</A>'s <STRONG><FONT face="Courier New">tmHeight</FONT></STRONG> member, which "Specifies the height (ascent + descent) of characters"&nbsp;specified in the font.</FONT></P>
<P><FONT face=Tahoma>So&nbsp;given all of the above,&nbsp;at least this <FONT face="Courier New"><STRONG>lfHeight</STRONG></FONT> member can theoretically be figured out, too.</FONT></P>
<P><FONT face=Tahoma>Though&nbsp;it is not particularly intuitive, is it?</FONT></P>
<P><FONT face=Tahoma>On Friday, typography PM Judy came by my office to explain to me that this was the topic that her fellow typography PM Carolyn had mentioned was really confusing. It should be of no suprise to anyone that even people who work in typography find this member to be really confusing -- there is no one outside of a few people over in GDI who would not be confused at this very low level member that has been partially exposed in this not-quite-so-low-level structure.</FONT></P>
<P><FONT face=Tahoma>I mean, how often can we really expect that people will specify it correctly, except when they use the built-in specified formula that maps to point size of the font? And in that case why did they even bother to expose it any other way?</FONT></P>
<P><FONT face=Tahoma>It does help things like old time <A href="http://support.microsoft.com/kb/74299/">KB article 74299</A>, which actually explains the things I did above in more practical terms, and is still just as valid&nbsp;beyond NT 4.0, despite what the "Applies To" section claims.</FONT></P>
<P><FONT face=Tahoma>And it helps third parties like Dr. Dobbs come up with useful topics like <A href="http://www.ddj.com/dept/windows/184416581">Font Creation and Rounding Differences</A> when trying to understand why the <A href="http://msdn2.microsoft.com/en-us/library/ms253971.aspx">MulDiv function</A> is needed here (and the problems in the area help people understand why this one usage of MulDiv is easier to find than documentation on the function itself!).</FONT></P>
<P><FONT face=Tahoma>This would be a case where the managed world made it all a little easier, not just in the GDI+ classses around fonts but in helpful topics like <A href="http://msdn2.microsoft.com/en-US/library/xwf9s90b(VS.80).aspx">this one</A> on interrogating fonts....</FONT></P>
<P><FONT face=Tahoma>So, as bad as the documentation here may be, I think it is fair to blame the actual implementation for any actual confusion here....</FONT></P>
<P><FONT face=Tahoma></FONT>&nbsp;</P>
<P><FONT face=Tahoma color=#ff1493><EM>This post brought to you by</EM> "<FONT size=6>ཛྷ</FONT>" <EM>(<A href="http://www.fileformat.info/info/unicode/char/0f5c">U+0f5c</A>, a.k.a. TIBETAN LETTER DZHA <FONT size=1>-- a character that is not afraid to use&nbsp;its&nbsp;descender powers!</FONT>)</EM></FONT></P>
<hr/><p><a id="582204" href="#582204">#</a> <strong>Rainer Bauer</strong> on 24 Apr 2006 11:20 AM:</p><div style="margin-left: 1em">What annoyed me most when I came from Unix developement was the lacking documentation of error values in case a function fails.<br><br>Normally the documentation only says &quot;If the function fails the return value is xxx and extended error information can be obtained by callingGetLastError.&quot; But in most cases no documentation is provided why the function might fail and which error code is set in that case.<br><br>Rainer</div>
<p><a id="582240" href="#582240">#</a> <strong>josh</strong> on 24 Apr 2006 12:13 PM:</p><div style="margin-left: 1em">Also, NULL is not a character, at least not in C. &nbsp;I've seen code that terminated a string with something like *p = NULL; which is a little disorienting.</div>
<p><a id="582317" href="#582317">#</a> <strong>Mike</strong> on 24 Apr 2006 2:00 PM:</p><div style="margin-left: 1em">While the design of LOGFONT is definitely very busted it does make more sense when you think about in a historical context. &nbsp;Way back in the day (we're talking pre-Windows 3.0 here, maybe even pre-Windows itself) all fonts were bitmap fonts and came in explicit pixel-based sizes. &nbsp;You didn't have mapping modes (or if you did you tried really hard not to use them because you didn't want to take the perf hit of the extra math) so everything was done in pixels, i.e. MM_TEXT. &nbsp;And you didn't have any fancy-dancy notions like em-height vs cell height. &nbsp;I wouldn't be surprised if the guy that initially designed what eventually came to be LOGFONT didn't even know about such things.<br><br>So the description back then probably read something more like &quot;lfHeight is the height of the font&quot;, end of story. &nbsp;As computer typography got more capable and more complex things got more subtle and overloaded because at each step the Windows devs wanted to make things easy for app writers so they followed a policy of extending existing things rather than recreating everything from scratch.<br><br>Or to put it another way, the current design is what you get when you pile 20 years worth of app-compat hacks on top of each other.</div>
<hr/><p><em>referenced by</em></p><div style="margin-left: 1em"><p>2008/08/11 <a href="http://archives.miloush.net/michkap/archive/2008/08/11/8847467.html">The fault is ~60% functionality, ~40% documentation</a></p><p>2008/05/09 <a href="http://archives.miloush.net/michkap/archive/2008/05/09/8481353.html">It is okay to not be in favor of termination</a></p><p>2006/06/16 <a href="http://archives.miloush.net/michkap/archive/2006/06/16/634124.html">Neither GDI nor Uniscribe solve the ultimate font problem completely, either</a></p></div><p><em>go to <a id="newer" href="http://archives.miloush.net/michkap/archive/2006/04/25/582700.html" title="No cows were harmed in the writing of this blog post">newer</a> or <a id="older" href="http://archives.miloush.net/michkap/archive/2006/04/24/581628.html" title="Why I am not in favor of a FileSystemInfo.Compare method">older</a> post, or back to <a href="http://archives.miloush.net/michkap/archive/index.html">index</a> or <a href="http://archives.miloush.net/michkap/archive/index.html#2006-04">month</a> or <a href="http://archives.miloush.net/michkap/archive/index.html#2006-04-24">day</a></em></p></body>
<!-- Mirrored from archives.miloush.net/michkap/archive/2006/04/24/581700.html by HTTrack Website Copier/3.x [XR&CO'2014], Thu, 25 May 2017 00:42:39 GMT -->
</html>