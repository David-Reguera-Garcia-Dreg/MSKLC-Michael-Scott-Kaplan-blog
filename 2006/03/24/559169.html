<html>
<!-- Mirrored from archives.miloush.net/michkap/archive/2006/03/24/559169.html by HTTrack Website Copier/3.x [XR&CO'2014], Thu, 25 May 2017 00:42:40 GMT -->
<head><meta charset="utf-8" /><meta name="viewport" content="width=device-width" /><title>Getting all you can out of a keyboard layout, Part #3</title></head><body>
<h1>Getting all you can out of a keyboard layout, Part #3</h1>
<p><em>by Michael S. Kaplan, published on 2006/03/24 04:01 -05:00, original URI: http://blogs.msdn.com/b/michkap/archive/2006/03/24/559169.aspx</em></p>
<hr/> <!-- Archival Source: ProcessPostNew -->
<P><FONT face=Tahoma>Previous posts in this series: <A href="http://archives.miloush.net/michkap/archive/2006/03/23/558658.html"><FONT face=Tahoma>Part 0</FONT></A><FONT face=Tahoma>, </FONT><A href="http://archives.miloush.net/michkap/archive/2006/03/23/558674.html"><FONT face=Tahoma>Part 1</FONT></A>, and <A href="http://archives.miloush.net/michkap/archive/2006/03/24/558715.html">Part 2</A>.</FONT></P>
<P><FONT face=Tahoma>Ok, we are making some progress here, and we are at the very least no longer stomping on the user's own keyboard list.</FONT></P>
<P><FONT face=Tahoma>But we are ignoring dead keys and ligatures. Which, once again, is quite lame.</FONT></P>
<P><FONT face=Tahoma>The key here is to have a little more respect for the return value of <A href="http://msdn.microsoft.com/library/en-us/winui/winui/windowsuserinterface/userinput/keyboardinput/keyboardinputreference/keyboardinputfunctions/tounicodeex.asp">ToUnicodeEx</A>. Right now we do nothing with the resulting string unless the return value is 1. But there are three other possibilities:</FONT></P>
<UL>
<LI><FONT face=Tahoma>If it's a dead key, the result will be -1;</FONT> 
<LI><FONT face=Tahoma>If it's a ligature (by which I mean the <A href="http://archives.miloush.net/michkap/archive/2005/04/07/406060.html">keyboard definition</A>, a string of 2-4 UTF-16 code points);</FONT> 
<LI><FONT face=Tahoma>If it fails, the result is 0.</FONT></LI></UL>
<P><FONT face=Tahoma>Clearly the only case where we want to do nothing is when 0 is the return value; in all other cases we want to do something. So let's fix that....</FONT></P>
<P><FONT face=Tahoma>(As before, the older code is gray, the new code is black)</FONT></P><FONT face=Tahoma>
<P><FONT face="Courier New" color=#808080 size=1><STRONG>using System;<BR>using System.Text;<BR>using System.Windows.Forms;<BR>using System.Runtime.InteropServices;</STRONG></FONT></P>
<P><FONT face="Courier New" color=#808080 size=1><STRONG>namespace KeyboardLayouts {<BR>&nbsp;&nbsp;&nbsp; class Class1 {</STRONG></FONT></P>
<P><FONT face="Courier New" color=#808080 size=1><STRONG>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //&nbsp; You'll want to insert that enumeration here!</STRONG></FONT></P>
<P><FONT face="Courier New" color=#808080 size=1><STRONG>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; internal const uint KLF_NOTELLSHELL&nbsp; = 0x00000080;</STRONG></FONT></P>
<P><FONT face="Courier New" color=#808080 size=1><STRONG>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; [DllImport("user32.dll", CharSet=CharSet.Unicode, EntryPoint="MapVirtualKeyExW", ExactSpelling=true)]<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; internal static extern uint MapVirtualKeyEx(<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; uint uCode, <BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; uint uMapType, <BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; IntPtr dwhkl);</STRONG></FONT></P>
<P><FONT face="Courier New" color=#808080 size=1><STRONG>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; [DllImport("user32.dll", CharSet=CharSet.Unicode, EntryPoint="LoadKeyboardLayoutW", ExactSpelling=true)]<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; internal static extern IntPtr LoadKeyboardLayout(string pwszKLID, uint Flags);</STRONG></FONT></P>
<P><FONT face="Courier New" color=#808080 size=1><STRONG>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; [DllImport("user32.dll", ExactSpelling=true)]<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; internal static extern bool UnloadKeyboardLayout(IntPtr hkl);</STRONG></FONT></P>
<P><FONT face="Courier New" color=#808080 size=1><STRONG>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; [DllImport("user32.dll", CharSet=CharSet.Unicode, ExactSpelling=true)]<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; internal static extern int ToUnicodeEx(<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; uint wVirtKey,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; uint wScanCode,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; KeysEx[] lpKeyState,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; StringBuilder pwszBuff,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int cchBuff,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; uint wFlags,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; IntPtr dwhkl);</STRONG></FONT></P>
<P><FONT face="Courier New" color=#808080 size=1><STRONG>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; [DllImport("user32.dll", ExactSpelling=true)]<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; public static extern int GetKeyboardLayoutList(int nBuff, [Out, MarshalAs(UnmanagedType.LPArray)] IntPtr[] lpList);</STRONG></FONT></P>
<P><FONT face="Courier New" size=1><STRONG><FONT color=#808080>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; [STAThread]<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; static void Main(string[] args) {<BR></FONT><FONT color=#808080><FONT color=#808080>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int cKeyboards = GetKeyboardLayoutList(0, null);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; IntPtr[] rghkl = new IntPtr[cKeyboards];<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; GetKeyboardLayoutList(cKeyboards, rghkl);<BR></FONT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; IntPtr hkl = LoadKeyboardLayout(args[0], KLF_NOTELLSHELL);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if(hkl == IntPtr.Zero) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Console.WriteLine("Sorry, that keyboard does not seem to be valid.");<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; KeysEx[] lpKeyState = new KeysEx[256];</FONT></STRONG></FONT></P>
<P><FONT face="Courier New" color=#808080 size=1><STRONG>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for(uint sc = 0x01; sc &lt;= 0x7f; sc++) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; uint vk = MapVirtualKeyEx(sc, 1, hkl);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if(vk != 0) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; StringBuilder sb = new StringBuilder(10);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int rc = ToUnicodeEx(vk, sc, lpKeyState, sb, sb.Capacity, 0, hkl);<BR><FONT color=#000000>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if(rc &gt; 0) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; StringBuilder sbChar = new StringBuilder(5 * rc);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for(int ich = 0; ich &lt; rc; ich++) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; sbChar.Append(((ushort)sb.ToString()[ich]).ToString("x4"));<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; sbChar.Append(' ');<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Console.WriteLine("{0:x2}\t{1:x4}\t{2:x2}\t{3}\t{4}", <BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; sc,&nbsp;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; sbChar.ToString(0, sbChar.Length - 1),&nbsp;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; vk,&nbsp;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ((KeysEx)vk).ToString(),&nbsp;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ((Keys)vk).ToString());<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else if(rc &lt; 0) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Console.WriteLine("{0:x2}\t{1:x4}\t{2:x2}\t{3}\t{4}\t\t\tDEAD!!!", <BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; sc,&nbsp;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ((ushort)sb.ToString()[0]),&nbsp;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; vk,&nbsp;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ((KeysEx)vk).ToString(),&nbsp;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ((Keys)vk).ToString());</FONT></STRONG></FONT></P>
<P><FONT face="Courier New" color=#808080 size=1><STRONG><FONT color=#000000>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // It's a dead key; let's flush out whats stored in the keyboard state.<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ToUnicodeEx((uint)KeysEx.VK_SPACE, MapVirtualKeyEx((uint)KeysEx.VK_SPACE, 0, hkl), lpKeyState, sb, sb.Capacity, 0, hkl);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</FONT><BR></STRONG></FONT><FONT face="Courier New" size=1><STRONG>&nbsp;<FONT color=#808080>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; foreach(IntPtr i in rghkl) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if(hkl == i) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; hkl = IntPtr.Zero;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<BR></P></FONT></STRONG></FONT>
<P><FONT face="Courier New" size=1><STRONG><FONT color=#808080>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if(hkl != IntPtr.Zero) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; UnloadKeyboardLayout(hkl);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<BR>&nbsp;</FONT><FONT color=#808080>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<BR></FONT></STRONG></FONT><FONT face="Courier New" color=#808080 size=1><STRONG>&nbsp;&nbsp;&nbsp; }<BR>}</STRONG></FONT></P></FONT>
<P><FONT face=Tahoma>Now a few different things happened here. First, any time&nbsp;the return of <A href="http://msdn.microsoft.com/library/en-us/winui/winui/windowsuserinterface/userinput/keyboardinput/keyboardinputreference/keyboardinputfunctions/tounicodeex.asp">ToUnicodeEx</A>&nbsp;is&nbsp;greater than zero, all of the code points are dumped out.</FONT></P>
<P><FONT face=Tahoma>Secondly, any time it is less than zero, it is known to be a dead key, which as I point out in <A href="http://archives.miloush.net/michkap/archive/2004/12/17/323257.html">this post</A> are always limited to a single UTF-16 code unit. So we grab that one code unit and use it.</FONT></P>
<P><FONT face=Tahoma>Thirdly, in that dead key case a second call is made to clear out the buffer -- otherwise the next call will be contaminated by the dead key value and will return either a different character entirely or two separate characters. Neither of those situation is too terribly desirable, so the buffer is cleared out.</FONT></P>
<P><FONT face=Tahoma>(In an upcoming post I will explain why I chose VK_SPACE as the character for clearing out the buffer.)</FONT></P>
<P><FONT face=Tahoma>It is very important to pay attention to that return value and never look past it when the string is not null terminated (and there is no guarantee that it will be). In fact, let's look at the return values table from the documentation:</FONT></P>
<P><FONT face=Tahoma>
<TABLE width="70%" border=1>
<TBODY>
<TR>
<TD><FONT size=2>-1</FONT></TD>
<TD><FONT size=2>The specified virtual key is a dead-key character (accent or diacritic). This value is returned regardless of the keyboard layout, even if several characters have been typed and are stored in the keyboard state. If possible, even with Unicode keyboard layouts, the function has written a spacing version of the dead-key character to the buffer specified by <I>pwszBuff</I>. For example, the function writes the character SPACING ACUTE (0x00B4), rather than the character NON_SPACING ACUTE (0x0301).</FONT></TD></TR>
<TR>
<TD><FONT size=2>0</FONT></TD>
<TD><FONT size=2>The specified virtual key has no translation for the current state of the keyboard. Nothing was written to the buffer specified by <I>pwszBuff</I>.</FONT></TD></TR>
<TR>
<TD><FONT size=2>1</FONT></TD>
<TD><FONT size=2>One character was written to the buffer specified by <I>pwszBuff</I>.</FONT></TD></TR>
<TR>
<TD><FONT size=2>2 or more</FONT></TD>
<TD><FONT size=2>Two or more characters were written to the buffer specified by <I>pwszBuff</I>. The most common cause for this is that a dead-key character (accent or diacritic) stored in the keyboard layout could not be combined with the specified virtual key to form a single character. However, the buffer may contain more characters than the return value specifies. When this happens, any extra characters are invalid and should be ignored.</FONT></TD></TR></TBODY></TABLE></FONT></P>
<P><FONT face=Tahoma>Of course I am assuming people never mistype a dead key combination and thus tend to think of that "2 or more" case as being for ligatures -- certainly in the code provided the <STRONG>only</STRONG> case that applies is the ligature one (since it never combines with other characters!).</FONT></P>
<P><FONT face=Tahoma>Ok, we are making progress now -- dead keys and ligatures. But we are still missing some important pieces like:</FONT></P>
<UL>
<LI><FONT face=Tahoma>the base characters that go with the dead keys and the composite characters they create</FONT> 
<LI><FONT face=Tahoma>the easy shift states</FONT> 
<LI><FONT face=Tahoma>the CAPS LOCK key</FONT> 
<LI><FONT face=Tahoma>the harder shift states</FONT> 
<LI><FONT face=Tahoma>chained dead keys</FONT></LI></UL><FONT face=Tahoma>
<P><FONT face=Tahoma>Now note that those last two go well beyond what even MSKLC supports, but that's okay; I am not limited in this sample by the same things that might limit functionality in MSKLC. :-)</FONT></P>
<P>Obviously we'll need something a bit smarter in the way of algorithm for some of these; this will be happening too. Remember that the main point of this sample is to show off some of those lessons that can be gleaned from this stuff....</FONT></P>
<P><FONT face=Tahoma></FONT>&nbsp;</P>
<P><FONT face=Tahoma><FONT color=#ff1493><EM>This post brought to you by</EM> "3" </FONT><EM><FONT color=#ff1493><FONT face=Tahoma>(<A href="http://www.fileformat.info/info/unicode/char/0033">U+0033</A>, DIGIT THREE)<BR><FONT size=1>A Unicode character that is in the very small family of those whose VK value is the same as it's code point!</FONT></FONT></FONT></EM></FONT></P>
<hr/><p><a id="559801" href="#559801">#</a> <strong>Phylyp</strong> on 24 Mar 2006 6:41 AM:</p><div style="margin-left: 1em">Wow, code samples + a series! &nbsp; Looks like you're taking after Raymond :)</div>
<p><a id="559912" href="#559912">#</a> <strong>Michael S. Kaplan</strong> on 24 Mar 2006 10:15 AM:</p><div style="margin-left: 1em">Hi Phylyp,<br><br>That's high praise! Though I never think of myself as someone quite in Raymond's league. :-)</div>
<p><a id="560041" href="#560041">#</a> <strong>Martin Bohring</strong> on 24 Mar 2006 12:23 PM:</p><div style="margin-left: 1em">Hello Michael,<br>hey this series really provides good insight into the keyboard API's.<br>I only wish you had writtem this half a year ago<br>I would have saved me from a lot of hassles and dead ends (not keys).<br><br>But still those bits about harder shift states and death key chains sound interesting</div>
<p><a id="560078" href="#560078">#</a> <strong>Michael S. Kaplan</strong> on 24 Mar 2006 12:48 PM:</p><div style="margin-left: 1em">Hi Martin! <BR><BR>Ah, I suppose I could have dated them back a year ago and then people who discover the blog for the first time would kick themselves for not finding it when they needed it? :-) <BR><BR>Stay tuned, as I delve in deeper into the under-documented!</div>
<hr/><p><em>referenced by</em></p><div style="margin-left: 1em"><p>2015/08/07 <a href="http://archives.miloush.net/michkap/archive/2015/08/07/8770668856267196989.html">Can you tell me how Microsoft keyboard layouts define a ligature and by the way can it be changed?</a></p><p>2007/08/10 <a href="http://archives.miloush.net/michkap/archive/2007/08/10/4322536.html">I've been to the desert on a dead key with no name</a></p><p>2006/04/22 <a href="http://archives.miloush.net/michkap/archive/2006/04/22/581107.html">Getting all you can out of a keyboard layout, Part #10a</a></p><p>2006/04/13 <a href="http://archives.miloush.net/michkap/archive/2006/04/13/575500.html">Getting all you can out of a keyboard layout, Part #9b</a></p><p>2006/04/12 <a href="http://archives.miloush.net/michkap/archive/2006/04/12/575080.html">Getting all you can out of a keyboard layout, Part #9a</a></p><p>2006/04/10 <a href="http://archives.miloush.net/michkap/archive/2006/04/10/570570.html">Getting all you can out of a keyboard layout, Part #8</a></p><p>2006/04/06 <a href="http://archives.miloush.net/michkap/archive/2006/04/06/569632.html">Getting all you can out of a keyboard layout, Part #7</a></p><p>2006/03/31 <a href="http://archives.miloush.net/michkap/archive/2006/03/31/565407.html">Getting all you can out of a keyboard layout, Part #6</a></p><p>2006/03/28 <a href="http://archives.miloush.net/michkap/archive/2006/03/28/561541.html">Getting all you can out of a keyboard layout, Part #5</a></p><p>2006/03/27 <a href="http://archives.miloush.net/michkap/archive/2006/03/27/561353.html">Getting all you can out of a keyboard layout, Part #4</a></p></div><p><em>go to <a id="newer" href="http://archives.miloush.net/michkap/archive/2006/03/25/560416.html" title="I need my SPACE, symbolically speaking">newer</a> or <a id="older" href="http://archives.miloush.net/michkap/archive/2006/03/24/558715.html" title="Getting all you can out of a keyboard layout, Part #2">older</a> post, or back to <a href="http://archives.miloush.net/michkap/archive/index.html">index</a> or <a href="http://archives.miloush.net/michkap/archive/index.html#2006-03">month</a> or <a href="http://archives.miloush.net/michkap/archive/index.html#2006-03-24">day</a></em></p></body>
<!-- Mirrored from archives.miloush.net/michkap/archive/2006/03/24/559169.html by HTTrack Website Copier/3.x [XR&CO'2014], Thu, 25 May 2017 00:42:40 GMT -->
</html>