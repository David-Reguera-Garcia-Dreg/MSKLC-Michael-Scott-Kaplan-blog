<html>
<!-- Mirrored from archives.miloush.net/michkap/archive/2006/03/02/542489.html by HTTrack Website Copier/3.x [XR&CO'2014], Thu, 25 May 2017 00:42:40 GMT -->
<head><meta charset="utf-8" /><meta name="viewport" content="width=device-width" /><title>When macros obfuscate in a way that encourages bugs....</title></head><body>
<h1>When macros obfuscate in a way that encourages bugs....</h1>
<p><em>by Michael S. Kaplan, published on 2006/03/02 20:01 -05:00, original URI: http://blogs.msdn.com/b/michkap/archive/2006/03/02/542489.aspx</em></p>
<hr/> <!-- Archival Source: ProcessPostNew -->
<P><FONT face=Tahoma>This is not a specifically international issue but it is one that annoys me, which makes me feel like blogging about it....</FONT></P>
<P><FONT face=Tahoma>You may have seen C/C++ code that used something like this before:</FONT></P>
<BLOCKQUOTE dir=ltr style="MARGIN-RIGHT: 0px">
<P><FONT face="Courier New"><STRONG>#define ALLOC_MEMORY(dwBytes)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; \<BR>&nbsp;&nbsp;&nbsp; ( HeapAlloc( GetProcessHeap(),&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; \<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; HEAP_ZERO_MEMORY,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; \<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; dwBytes ) )</STRONG></FONT></P>
<P><FONT face=Tahoma><BR><FONT face="Courier New"><STRONG>#define FREE_MEMORY(hMem)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; \<BR>&nbsp;&nbsp;&nbsp; ( (hMem) ? (HeapFree( GetProcessHeap(), \<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; \<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (PVOID)hMem ))&nbsp;&nbsp;&nbsp; \<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; : 0 )</STRONG></FONT><BR></FONT></P></BLOCKQUOTE>
<P><FONT face=Tahoma>The intent of the macros is rather obvious -- avoid the minutae of how things are allocated in every call.</FONT></P>
<P><FONT face=Tahoma>Fine.</FONT></P>
<P><FONT face=Tahoma>The problem for me is in this FREE_MEMORY macro, which is doing a couple of things that annoy me. First of all, i</FONT><FONT face=Tahoma>t is checking for a NULL pointer to know whether it should free, without even so much as an ASSERT to try to track down these people who are trying to free something that does not have to be freed.</FONT></P>
<P><FONT face=Tahoma>But more importantly, it is not ZEROING OUT THE BUFFER it just freed (the very thing it checks for!)</FONT><FONT face=Tahoma>, which means that any type of double free bug is not found immediately, since if they attempt to free a block twice then it will just try and free it again.</FONT></P>
<P><FONT face=Tahoma>Doesn't this kind of "simplification" just obfuscate bugs?</FONT></P>
<P><FONT face=Tahoma>Now I have seen plenty of code that does this, and which adds in an extra FREE_MEMORY type call at the end of a function to "make sure resources are released."</FONT></P><FONT face=Tahoma>
<P><FONT face=Tahoma>And it just seems like a lazy and a potentially really bad practice to me. Sure, add the simplifying macro if you want -- but make sure the macro guards against side effects, and don't simplify it so much that you actually hide bugs.</P>
<P></FONT></FONT><FONT face=Tahoma>Ok, I will get off my soapbox now, back to your regularly scheduled blog.... :-)</FONT></P>
<hr/><p><a id="542586" href="#542586">#</a> <strong>Maurits [MSFT]</strong> on 2 Mar 2006 8:16 PM:</p><div style="margin-left: 1em">Also both of those macros use their argument twice. &nbsp;Any time a macro uses an argument twice, you run into DO_SOMETHING(*p++) issues where p is incremented twice.<br><br>If a macro can't do what it needs to do without referencing the argument only once, it's safer to use a function.</div>
<p><a id="542588" href="#542588">#</a> <strong>Maurits [MSFT]</strong> on 2 Mar 2006 8:17 PM:</p><div style="margin-left: 1em">Someday I'll learn how to count. ALLOC_MEMORY is fine in that respect, it just uses dwBytes once.</div>
<p><a id="542595" href="#542595">#</a> <strong>Maurits [MSFT]</strong> on 2 Mar 2006 8:31 PM:</p><div style="margin-left: 1em">/* let's define some constants */<br>#define NUM_BLOCKS 20<br>#define BLOCK_SIZE 1024<br><br>/* a nice static array here */<br>void* lotsa_memory[NUM_BLOCKS];<br><br>/* let's grab 20K of memory in bite-sized chunks */<br>for (int i = 0; i &lt; NUM_BLOCKS; i++)<br>{<br>__ lotsa_memory[i] = ALLOC_MEMORY(BLOCK_SIZE);<br>}<br><br>/* let's do some stuff... */<br>/* ... */<br>/* ... */<br>/* ok, done. Now how to free the memory? */<br><br>/* this would work */<br>for (int i = 0; i &lt; NUM_BLOCKS; i++)<br>{<br>__ FREE_MEMORY(lotsa_memory[i]);<br>}<br><br>/* and so would this */<br>int i = 0;<br>do { FREE_MEMORY(lotsa_memory[i]); } while (i++ &lt; NUM_BLOCKS);<br><br>/* but this is a big hairy BUG!! */<br>int i = 0;<br>do { FREE_MEMORY(lotsa_memory[i++]); } while (i &lt; NUM_BLOCKS);</div>
<p><a id="542597" href="#542597">#</a> <strong>Maurits [MSFT]</strong> on 2 Mar 2006 8:35 PM:</p><div style="margin-left: 1em">*ahem* actually the next-to-last-block should be...<br><br>/* and so would this */<br>int i = 0;<br>do { FREE_MEMORY(lotsa_memory[i]); } while (++i &lt; NUM_BLOCKS);<br>/* note pre-increment, not post-increment... stupid off-by-one errors */</div>
<p><a id="542728" href="#542728">#</a> <strong>Thomas Witt</strong> on 3 Mar 2006 12:08 AM:</p><div style="margin-left: 1em">While I do agree that there might be reasons to complain about FREE_MEMORY I think your complaint is ill founded. FREE_MEMORY's semantics with respect to null pointers are in line with the std library facillities in both C99 and C++03. free() in C as well as delete in C++ are both defined to be a no-op for null pointers. Given this I think FREE_MEMORY's behaviour is more than reasonable.<br><br>Furthermore AFAICS zeroing out the pointer would be exactly the wrong thing to do with respect to hiding bugs. It would in fact hide double free, what is by the way diagnosed by the underlying &nbsp;HeapFree call in MS's C library (the memory debugging facillities are pretty powerfull).<br><br>In my experience there is a widespread misconception on what the non nullness of a pointer conveys. There is practicly no information about the memory it points to as far as allocation state goes. It could be on the heap or on the stack and if on the heap it could be free'd already. Given this coding standards that require zeroing out pointers to heap memory that has been free'd add a false sense of safety. And are likely to hide issues that can be easily diagnosed by modern C-libraries.</div>
<p><a id="542772" href="#542772">#</a> <strong>Michael S. Kaplan</strong> on 3 Mar 2006 1:43 AM:</p><div style="margin-left: 1em">Hi Thomas,<br><br>All reasonable, though the part I had the most trouble with was combining that FREE_MEMORY with the idea of &quot;cleaning up at the end&quot; something that may have already been cleaned up. I am pretty sure that no one is in favor of architecting a double free....</div>
<hr/><p><em>go to <a id="newer" href="http://archives.miloush.net/michkap/archive/2006/03/03/542963.html" title="How To [NOT] detect that a locale is bidi">newer</a> or <a id="older" href="http://archives.miloush.net/michkap/archive/2006/03/02/542395.html" title="CompareString ignores case by lowercasing....">older</a> post, or back to <a href="http://archives.miloush.net/michkap/archive/index.html">index</a> or <a href="http://archives.miloush.net/michkap/archive/index.html#2006-03">month</a> or <a href="http://archives.miloush.net/michkap/archive/index.html#2006-03-02">day</a></em></p></body>
<!-- Mirrored from archives.miloush.net/michkap/archive/2006/03/02/542489.html by HTTrack Website Copier/3.x [XR&CO'2014], Thu, 25 May 2017 00:42:40 GMT -->
</html>