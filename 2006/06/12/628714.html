<html>
<!-- Mirrored from archives.miloush.net/michkap/archive/2006/06/12/628714.html by HTTrack Website Copier/3.x [XR&CO'2014], Thu, 25 May 2017 00:42:39 GMT -->
<head><meta charset="utf-8" /><meta name="viewport" content="width=device-width" /><title>Uniscribe from Visual Basic</title></head><body>
<h1>Uniscribe from Visual Basic</h1>
<p><em>by Michael S. Kaplan, published on 2006/06/12 18:15 -04:00, original URI: http://blogs.msdn.com/b/michkap/archive/2006/06/12/628714.aspx</em></p>
<hr/> <!-- Archival Source: ProcessPostNew -->
<P><FONT face=Tahoma>Over the past six weeks I have received eight different requests for information on how to get various bits of Uniscribe to work from Visual Basic, in VB5 or VB6.</FONT></P>
<P><FONT face=Tahoma>Although there is sample code to do this in <A href="http://i18nwithvb.com/">my book</A>, the book is out of print now (even though it was released less than six years ago, it is also three product versions ago, and the publisher seems to prefer to focus on newer stuff.</FONT></P>
<P><FONT face=Tahoma>In any case, provided here is the code mostly from the book that is used to call Uniscribe from VB in the "Light Edit" control sample that is a modified version of the one created originally by Matt Curland for his book (<A href="http://www.powervb.com/">Advanced Visual Basic 6: Power Techniques for Everyday Programs</A>).</FONT></P>
<P><FONT face=Tahoma>I included VB-ized versions of some of the Uniscribe structs not used in the UniscribeExtTextOutW wrapper that most of the code is made to support. But perhaps someone will find it useful anyway, so I left it in.</FONT></P>
<P><FONT face=Tahoma>I had mostly written a .NET version of the code but then in VS 2005 the TextRenderer class I talked about <STRONG><A href="http://archives.miloush.net/michkap/archive/2005/06/27/432986.html">here</A></STRONG> and <STRONG><A href="http://archives.miloush.net/michkap/archive/2005/06/27/433208.html">here</A></STRONG> made it less necessary -- since it is now built-in to .NET....</FONT></P>
<P><FONT face=Tahoma>If you want an in-depth explanation of everything I did for the light edit control to support Unicode input, clipboard, and rendering support, you'll have to find the book (I am hoarding my last copies, sorry!). But here is a nice bit of the Uniscribe sample....</FONT></P>
<BLOCKQUOTE dir=ltr style="MARGIN-RIGHT: 0px">
<BLOCKQUOTE dir=ltr style="MARGIN-RIGHT: 0px">
<P><FONT face="Consolas,Courier New" size=1><STRONG>'--------------------------------<BR>'&nbsp;&nbsp; Windows API enumerations<BR>Public Enum GCPCLASS<BR>&nbsp;&nbsp;&nbsp;&nbsp; GCPCLASS_LATIN = 1<BR>&nbsp;&nbsp;&nbsp;&nbsp; GCPCLASS_ARABIC = 2<BR>&nbsp;&nbsp;&nbsp;&nbsp; GCPCLASS_HEBREW = 2<BR>&nbsp;&nbsp;&nbsp;&nbsp; GCPCLASS_NEUTRAL = 3<BR>&nbsp;&nbsp;&nbsp;&nbsp; GCPCLASS_LOCALNUMBER = 4<BR>&nbsp;&nbsp;&nbsp;&nbsp; GCPCLASS_LATINNUMBER = 5<BR>&nbsp;&nbsp;&nbsp;&nbsp; GCPCLASS_LATINNUMERICTERMINATOR = 6<BR>&nbsp;&nbsp;&nbsp;&nbsp; GCPCLASS_LATINNUMERICSEPARATOR = 7<BR>&nbsp;&nbsp;&nbsp;&nbsp; GCPCLASS_NUMERICSEPARATOR = 8<BR>&nbsp;&nbsp;&nbsp;&nbsp; GCPCLASS_POSTBOUNDRTL = &amp;H10<BR>&nbsp;&nbsp;&nbsp;&nbsp; GCPCLASS_PREBOUNDLTR = &amp;H40<BR>&nbsp;&nbsp;&nbsp;&nbsp; GCPCLASS_PREBOUNDRTL = &amp;H80<BR>&nbsp;&nbsp;&nbsp;&nbsp; GCPCLASS_POSTBOUNDLTR = &amp;H20<BR>&nbsp;&nbsp;&nbsp;&nbsp; GCPGLYPH_LINKAFTER = &amp;H4000<BR>&nbsp;&nbsp;&nbsp;&nbsp; GCPGLYPH_LINKBEFORE = &amp;H8000<BR>End Enum</STRONG></FONT></P>
<P><FONT face="Consolas,Courier New" size=1><STRONG>'--------------------------------<BR>' Windows API types<BR>Public Type ABC<BR>&nbsp;&nbsp;&nbsp; abcA As Long<BR>&nbsp;&nbsp;&nbsp; abcB As Long<BR>&nbsp;&nbsp;&nbsp; abcC As Long<BR>End Type</STRONG></FONT></P>
<P><FONT face="Consolas,Courier New" size=1><STRONG>'--------------------------------<BR>' Uniscribe ENUMs<BR>Public Enum SCRIPT<BR>&nbsp;&nbsp;&nbsp; SCRIPT_UNDEFINED = 0<BR>End Enum</STRONG></FONT></P>
<P><FONT face="Consolas,Courier New" size=1><STRONG>Public Enum SCRIPT_JUSTIFY<BR>&nbsp;&nbsp;&nbsp; SCRIPT_JUSTIFY_NONE = 0<BR>&nbsp;&nbsp;&nbsp; SCRIPT_JUSTIFY_ARABIC_BLANK = 1<BR>&nbsp;&nbsp;&nbsp; SCRIPT_JUSTIFY_CHARACTER = 2<BR>&nbsp;&nbsp;&nbsp; SCRIPT_JUSTIFY_RESERVED1 = 3<BR>&nbsp;&nbsp;&nbsp; SCRIPT_JUSTIFY_BLANK = 4<BR>&nbsp;&nbsp;&nbsp; SCRIPT_JUSTIFY_RESERVED2 = 5<BR>&nbsp;&nbsp;&nbsp; SCRIPT_JUSTIFY_RESERVED3 = 6<BR>&nbsp;&nbsp;&nbsp; SCRIPT_JUSTIFY_ARABIC_NORMAL = 7<BR>&nbsp;&nbsp;&nbsp; SCRIPT_JUSTIFY_ARABIC_KASHIDA = 8<BR>&nbsp;&nbsp;&nbsp; SCRIPT_JUSTIFY_ARABIC_ALEF = 9<BR>&nbsp;&nbsp;&nbsp; SCRIPT_JUSTIFY_ARABIC_HA = 10<BR>&nbsp;&nbsp;&nbsp; SCRIPT_JUSTIFY_ARABIC_RA = 11<BR>&nbsp;&nbsp;&nbsp; SCRIPT_JUSTIFY_ARABIC_BA = 12<BR>&nbsp;&nbsp;&nbsp; SCRIPT_JUSTIFY_ARABIC_BARA = 13<BR>&nbsp;&nbsp;&nbsp; SCRIPT_JUSTIFY_ARABIC_SEEN = 14<BR>&nbsp;&nbsp;&nbsp; SCRIPT_JUSTIFY_RESERVED4 = 15<BR>End Enum</STRONG></FONT></P>
<P><FONT face="Consolas,Courier New" size=1><STRONG>Public Enum SSA_FLAGS<BR>&nbsp;&nbsp;&nbsp; SSA_PASSWORD = &amp;H1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ' Input string contains a single character to be duplicated iLength times<BR>&nbsp;&nbsp;&nbsp; SSA_TAB = &amp;H2&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ' Expand tabs<BR>&nbsp;&nbsp;&nbsp; SSA_CLIP = &amp;H4&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ' Clip string at iReqWidth<BR>&nbsp;&nbsp;&nbsp; SSA_FIT = &amp;H8&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ' Justify string to iReqWidth<BR>&nbsp;&nbsp;&nbsp; SSA_DZWG = &amp;H10&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ' Provide representation glyphs for control characters<BR>&nbsp;&nbsp;&nbsp; SSA_FALLBACK = &amp;H20&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ' Use fallback fonts<BR>&nbsp;&nbsp;&nbsp; SSA_BREAK = &amp;H40&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ' Return break flags (character and word stops)<BR>&nbsp;&nbsp;&nbsp; SSA_GLYPHS = &amp;H80&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ' Generate glyphs, positions and attributes<BR>&nbsp;&nbsp;&nbsp; SSA_RTL = &amp;H100&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ' Base embedding level 1<BR>&nbsp;&nbsp;&nbsp; SSA_GCP = &amp;H200&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ' Return missing glyphs and LogCLust with GetCharacterPlacement conventions<BR>&nbsp;&nbsp;&nbsp; SSA_HOTKEY = &amp;H400&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ' Replace '&amp;' with underline on subsequent codepoint<BR>&nbsp;&nbsp;&nbsp; SSA_METAFILE = &amp;H800&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ' Write items with ExtTextOutW Unicode calls, not glyphs<BR>&nbsp;&nbsp;&nbsp; SSA_LINK = &amp;H1000&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ' Apply FE font linking/association to non-complex text<BR>&nbsp;&nbsp;&nbsp; SSA_HIDEHOTKEY = &amp;H2000&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ' Remove first '&amp;' from displayed string<BR>&nbsp;&nbsp;&nbsp; SSA_HOTKEYONLY = &amp;H2400&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ' Display underline only.<BR>&nbsp;&nbsp;&nbsp; <BR>&nbsp;&nbsp;&nbsp; ' Internal flags<BR>&nbsp;&nbsp;&nbsp; SSA_PIDX = &amp;H10000000&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ' Internal<BR>&nbsp;&nbsp;&nbsp; SSA_LAYOUTRTL = &amp;H20000000&nbsp;&nbsp;&nbsp; ' Internal - Used when DC is mirrored<BR>&nbsp;&nbsp;&nbsp; SSA_DONTGLYPH = &amp;H40000000&nbsp;&nbsp;&nbsp; ' Internal - Used only by GDI during metafiling - Use ExtTextOutA for positioning<BR>End Enum</STRONG></FONT></P>
<P><FONT face="Consolas,Courier New" size=1><STRONG>Public Enum SCRIPT_IS_COMPLEX_FLAGS<BR>&nbsp;&nbsp;&nbsp; SIC_COMPLEX = 1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ' Treat complex script letters as complex<BR>&nbsp;&nbsp;&nbsp; SIC_ASCIIDIGIT = 2&nbsp;&nbsp; ' Treat digits U+0030 through U+0039 as copmplex<BR>&nbsp;&nbsp;&nbsp; SIC_NEUTRAL = 4&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ' Treat neutrals as complex<BR>End Enum</STRONG></FONT></P>
<P><FONT face="Consolas,Courier New" size=1><STRONG>Public Enum SCRIPT_DIGITSUBSTITUTE_FLAGS<BR>&nbsp;&nbsp;&nbsp; SCRIPT_DIGITSUBSTITUTE_CONTEXT = 0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ' Substitute to match preceeding letters<BR>&nbsp;&nbsp;&nbsp; SCRIPT_DIGITSUBSTITUTE_NONE = 1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ' No substitution<BR>&nbsp;&nbsp;&nbsp; SCRIPT_DIGITSUBSTITUTE_NATIONAL = 2&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ' Substitute with official national digits<BR>&nbsp;&nbsp;&nbsp; SCRIPT_DIGITSUBSTITUTE_TRADITIONAL = 3&nbsp;&nbsp; ' Substitute with traditional digits of the locale<BR>End Enum</STRONG></FONT></P>
<P><FONT face="Consolas,Courier New" size=1><STRONG>Public Enum SCRIPT_GET_CMAP_FLAGS<BR>&nbsp;&nbsp;&nbsp; SGCM_RTL = &amp;H1&amp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ' Return mirrored glyph for mirrorable Unicode codepoints<BR>End Enum</STRONG></FONT></P>
<P><FONT face="Consolas,Courier New" size=1><STRONG>'--------------------------------<BR>'&nbsp;&nbsp; Uniscribe Types</STRONG></FONT></P>
<P><FONT face="Consolas,Courier New" size=1><STRONG>' This is the C-friendly version of SCRIPT_DIGITSUBSTITUTE_VB<BR>' which will be packed properly<BR>Public Type SCRIPT_DIGITSUBSTITUTE<BR>&nbsp;&nbsp;&nbsp; NationalDigitLanguage As Integer<BR>&nbsp;&nbsp;&nbsp; TraditionalDigitLanguage As Integer<BR>&nbsp;&nbsp;&nbsp; DigitSubstitute As Byte<BR>&nbsp;&nbsp;&nbsp; dwReserved As Long<BR>End Type</STRONG></FONT></P>
<P><FONT face="Consolas,Courier New" size=1><STRONG>' This is the C-friendly version of SCRIPT_CONTROL_VB<BR>' which will be packed properly<BR>Public Type SCRIPT_CONTROL<BR>&nbsp;&nbsp;&nbsp; uDefaultLanguage As Integer<BR>&nbsp;&nbsp;&nbsp; fBitFields As Byte<BR>&nbsp;&nbsp;&nbsp; fReserved As Integer<BR>End Type</STRONG></FONT></P>
<P><FONT face="Consolas,Courier New" size=1><STRONG>' This is the C-friendly version of SCRIPT_STATE_VB<BR>' which will be packed properly<BR>Public Type SCRIPT_STATE<BR>&nbsp;&nbsp;&nbsp; fBitFields1 As Byte<BR>&nbsp;&nbsp;&nbsp; fBitFields2 As Byte<BR>End Type</STRONG></FONT></P>
<P><FONT face="Consolas,Courier New" size=1><STRONG>' This is the C-friendly version of SCRIPT_VISATTR_VB<BR>' which will be packed properly<BR>Public Type SCRIPT_VISATTR<BR>&nbsp;&nbsp;&nbsp; uJustification As SCRIPT_JUSTIFY<BR>&nbsp;&nbsp;&nbsp; fBitFields1 As Byte<BR>&nbsp;&nbsp;&nbsp; fBitFields2 As Byte<BR>End Type</STRONG></FONT></P>
<P><FONT face="Consolas,Courier New" size=1><STRONG>' This is the C-friendly version of SCRIPT_ANALYSIS_VB<BR>' which will be packed properly<BR>Public Type SCRIPT_ANALYSIS<BR>&nbsp;&nbsp;&nbsp; fBitFields1 As Byte<BR>&nbsp;&nbsp;&nbsp; fBitFields2 As Byte<BR>&nbsp;&nbsp;&nbsp; s As SCRIPT_STATE<BR>End Type</STRONG></FONT></P>
<P><FONT face="Consolas,Courier New" size=1><STRONG>' This is the C-friendly version of SCRIPT_LOGATTR_VB<BR>' which will be packed properly<BR>Public Type SCRIPT_LOGATTR<BR>&nbsp;&nbsp;&nbsp; fBitFields As Byte<BR>End Type</STRONG></FONT></P>
<P><FONT face="Consolas,Courier New" size=1><STRONG>Public Type SCRIPT_CACHE<BR>&nbsp;&nbsp;&nbsp; p As Long<BR>End Type</STRONG></FONT></P>
<P><FONT face="Consolas,Courier New" size=1><STRONG>Public Type SCRIPT_FONTPROPERTIES<BR>&nbsp;&nbsp;&nbsp; cBytes As Long<BR>&nbsp;&nbsp;&nbsp; wgBlank As Integer<BR>&nbsp;&nbsp;&nbsp; wgDefault As Integer<BR>&nbsp;&nbsp;&nbsp; wgInvalid As Integer<BR>&nbsp;&nbsp;&nbsp; wgKashida As Integer<BR>&nbsp;&nbsp;&nbsp; iKashidaWidth As Long<BR>End Type</STRONG></FONT></P>
<P><FONT face="Consolas,Courier New" size=1><STRONG>' UNDONE: This struscture may not work well<BR>' for using SCRIPT_PROPERTIES because it may<BR>' not be aligned properly. Why oh why did they<BR>' have to use bitfields?<BR>Public Type SCRIPT_PROPERTIES<BR>&nbsp;&nbsp;&nbsp; langid As Integer<BR>&nbsp;&nbsp;&nbsp; fBitFields(1 To 3) As Byte<BR>End Type</STRONG></FONT></P>
<P><FONT face="Consolas,Courier New" size=1><STRONG>Public Type SCRIPT_ITEM<BR>&nbsp;&nbsp;&nbsp; iCharPos As Long<BR>&nbsp;&nbsp;&nbsp; a As SCRIPT_ANALYSIS<BR>End Type</STRONG></FONT></P>
<P><FONT face="Consolas,Courier New" size=1><STRONG>Public Type GOFFSET<BR>&nbsp;&nbsp;&nbsp; du As Long<BR>&nbsp;&nbsp;&nbsp; dv As Long<BR>End Type</STRONG></FONT></P>
<P><FONT face="Consolas,Courier New" size=1><STRONG>Public Type SCRIPT_TABDEF<BR>&nbsp;&nbsp;&nbsp; cTabStops As Long<BR>&nbsp;&nbsp;&nbsp; iScale As Long<BR>&nbsp;&nbsp;&nbsp; pTabStops() As Long<BR>&nbsp;&nbsp;&nbsp; iTabOrigin As Long<BR>End Type</STRONG></FONT></P>
<P><FONT face="Consolas,Courier New" size=1><STRONG>' We do not use this struct since we have to pass it ByVal<BR>' some times and ByRef other times. All it is a pointer to a<BR>' BLOB of data in memory, anyway, so we will use a Long<BR>Public Type SCRIPT_STRING_ANALYSIS<BR>&nbsp;&nbsp;&nbsp; p As Long<BR>End Type</STRONG></FONT></P>
<P><FONT face="Consolas,Courier New" size=1><STRONG>'--------------------------------<BR>'&nbsp;&nbsp; VB friendly versions of Uniscribe Types</STRONG></FONT></P>
<P><FONT face="Consolas,Courier New" size=1><STRONG>' You will have to use SCRIPT_CONTROL to call the<BR>' API to make sure the structure is packed properly<BR>Public Type SCRIPT_CONTROL_VB<BR>&nbsp;&nbsp;&nbsp; uDefaultLanguage As Long&nbsp;&nbsp;&nbsp; '&nbsp; :16<BR>&nbsp;&nbsp;&nbsp; fContextDigits As Byte&nbsp; ' As Long&nbsp;&nbsp; :1<BR>&nbsp;&nbsp;&nbsp; fInvertPreBoundDir As Byte&nbsp; ' As Long&nbsp;&nbsp; :1<BR>&nbsp;&nbsp;&nbsp; fInvertPostBoundDir As Byte ' As Long&nbsp;&nbsp; :1<BR>&nbsp;&nbsp;&nbsp; fLinkStringBefore As Byte&nbsp;&nbsp; ' As Long&nbsp;&nbsp; :1<BR>&nbsp;&nbsp;&nbsp; fLinkStringAfter As Byte&nbsp;&nbsp;&nbsp; ' As Long&nbsp;&nbsp; :1<BR>&nbsp;&nbsp;&nbsp; fNeutralOverride As Byte&nbsp;&nbsp;&nbsp; ' As Long&nbsp;&nbsp; :1<BR>&nbsp;&nbsp;&nbsp; fNumericOverride As Byte&nbsp;&nbsp;&nbsp; ' As Long&nbsp;&nbsp; :1<BR>&nbsp;&nbsp;&nbsp; fLegacyBidiClass As Byte&nbsp;&nbsp;&nbsp; ' As Long&nbsp;&nbsp; :1<BR>&nbsp;&nbsp;&nbsp; fReserved As Byte&nbsp;&nbsp; ' As Long&nbsp;&nbsp; :8<BR>End Type</STRONG></FONT></P>
<P><FONT face="Consolas,Courier New" size=1><STRONG>' You will have to use SCRIPT_STATE to call the<BR>' API to make sure the structure is packed properly<BR>Public Type SCRIPT_STATE_VB<BR>&nbsp;&nbsp;&nbsp; uBidiLevel As Integer&nbsp;&nbsp; ':5<BR>&nbsp;&nbsp;&nbsp; fOverrideDirection As Integer&nbsp;&nbsp; ':1<BR>&nbsp;&nbsp;&nbsp; fInhibitSymSwap As Integer&nbsp; ':1<BR>&nbsp;&nbsp;&nbsp; fCharShape As Integer&nbsp;&nbsp; ':1<BR>&nbsp;&nbsp;&nbsp; fDigitSubstitute As Integer ':1<BR>&nbsp;&nbsp;&nbsp; fInhibitLigate As Integer&nbsp;&nbsp; ':1<BR>&nbsp;&nbsp;&nbsp; fDisplayZWG As Integer&nbsp; ':1<BR>&nbsp;&nbsp;&nbsp; fArabicNumContext As Integer&nbsp;&nbsp;&nbsp; ':1<BR>&nbsp;&nbsp;&nbsp; fGcpClusters As Integer ':1<BR>&nbsp;&nbsp;&nbsp; fReserved As Integer&nbsp;&nbsp;&nbsp; ':1<BR>&nbsp;&nbsp;&nbsp; fEngineReserved As Integer&nbsp; ':2<BR>End Type</STRONG></FONT></P>
<P><FONT face="Consolas,Courier New" size=1><STRONG>' You will have to use SCRIPT_VISATTR to call the<BR>' API to make sure the structure is packed properly<BR>Public Type SCRIPT_VISATTR_VB<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; uJustification As SCRIPT_JUSTIFY ':4<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; fClusterStart As Integer ':1<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; fDiacritic As Integer&nbsp;&nbsp;&nbsp; ':1<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; fZeroWidth As Integer&nbsp;&nbsp;&nbsp; ':1<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; fReserved As Integer ':1<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; fShapeReserved As Integer&nbsp;&nbsp;&nbsp; ':8<BR>End Type</STRONG></FONT></P>
<P><FONT face="Consolas,Courier New" size=1><STRONG>' You will have to use SCRIPT_ANALYSIS to call the<BR>' API to make sure the structure is packed properly<BR>Public Type SCRIPT_ANALYSIS_VB<BR>&nbsp;&nbsp;&nbsp; eScript As Integer&nbsp; ':10<BR>&nbsp;&nbsp;&nbsp; fRTL As Integer ':1<BR>&nbsp;&nbsp;&nbsp; fLayoutRTL As Integer&nbsp;&nbsp; ':1<BR>&nbsp;&nbsp;&nbsp; fLinkBefore As Integer&nbsp; ':1<BR>&nbsp;&nbsp;&nbsp; fLinkAfter As Integer&nbsp;&nbsp; ':1<BR>&nbsp;&nbsp;&nbsp; fLogicalOrder As Integer&nbsp;&nbsp;&nbsp; ':1<BR>&nbsp;&nbsp;&nbsp; fNoGlyphIndex As Integer&nbsp;&nbsp;&nbsp; ':1<BR>&nbsp;&nbsp;&nbsp; s As SCRIPT_STATE<BR>End Type</STRONG></FONT></P>
<P><FONT face="Consolas,Courier New" size=1><STRONG>' You will have to use SCRIPT_LOGATTR to call the<BR>' API to make sure the structure is packed properly<BR>Public Type SCRIPT_LOGATTR_VB<BR>&nbsp;&nbsp;&nbsp; fSoftBreak As Byte&nbsp; ':1<BR>&nbsp;&nbsp;&nbsp; fWhiteSpace As Byte ':1<BR>&nbsp;&nbsp;&nbsp; fCharStop As Byte&nbsp;&nbsp; ':1<BR>&nbsp;&nbsp;&nbsp; fWordStop As Byte&nbsp;&nbsp; ':1<BR>&nbsp;&nbsp;&nbsp; fInvalid As Byte&nbsp;&nbsp;&nbsp; ':1<BR>&nbsp;&nbsp;&nbsp; fReserved As Byte&nbsp;&nbsp; ':3<BR>End Type</STRONG></FONT></P>
<P><FONT face="Consolas,Courier New" size=1><STRONG>' You will have to use SCRIPT_PROPERTIES to call the<BR>' API to make sure the structure is packed properly<BR>Public Type SCRIPT_PROPERTIES_VB<BR>&nbsp;&nbsp;&nbsp; langid As Long&nbsp; ':16<BR>&nbsp;&nbsp;&nbsp; fNumeric As Long&nbsp;&nbsp;&nbsp; ':1<BR>&nbsp;&nbsp;&nbsp; fComplex As Long&nbsp;&nbsp;&nbsp; ':1<BR>&nbsp;&nbsp;&nbsp; fNeedsWordBreaking As Long&nbsp; ':1<BR>&nbsp;&nbsp;&nbsp; fNeedsCaretInfo As Long ':1<BR>&nbsp;&nbsp;&nbsp; bCharSet As Long&nbsp;&nbsp;&nbsp; ':8<BR>&nbsp;&nbsp;&nbsp; fControl As Long&nbsp;&nbsp;&nbsp; ':1<BR>&nbsp;&nbsp;&nbsp; fPrivateUseArea&nbsp; As Long&nbsp; ':1<BR>&nbsp;&nbsp;&nbsp; fNeedsCharacterJustify As Long&nbsp; ':1<BR>&nbsp;&nbsp;&nbsp; fInvalidGlyph As Long&nbsp;&nbsp; ':1<BR>&nbsp;&nbsp;&nbsp; fInvalidLogAttr As Long ':1<BR>&nbsp;&nbsp;&nbsp; fCDM As Long&nbsp;&nbsp;&nbsp; ':1<BR>&nbsp;&nbsp;&nbsp; <BR>&nbsp;&nbsp;&nbsp; ' Added in later versions of UNISCRIBE (usp10.h)<BR>&nbsp;&nbsp;&nbsp; fAmbiguousCharSet As Long&nbsp;&nbsp; ':1<BR>&nbsp;&nbsp;&nbsp; fClusterSizeVaries As Long&nbsp; ':1<BR>&nbsp;&nbsp;&nbsp; fRejectInvalid As Long&nbsp; ':1<BR>End Type</STRONG></FONT></P>
<P><FONT face="Consolas,Courier New" size=1><STRONG>'--------------------------------<BR>'&nbsp;&nbsp; Uniscribe APIs<BR>Declare Function ScriptApplyDigitSubstitution Lib "usp10.dll" ( _<BR>&nbsp;psds As SCRIPT_DIGITSUBSTITUTE, _<BR>&nbsp;psc As SCRIPT_CONTROL, _<BR>&nbsp;pss As SCRIPT_STATE _<BR>&nbsp;) As Long<BR>&nbsp;<BR>Declare Function ScriptApplyLogicalWidth Lib "usp10.dll" ( _<BR>&nbsp;piDx() As Long, _<BR>&nbsp;ByVal cChars As Long, _<BR>&nbsp;ByVal cGlyphs As Long, _<BR>&nbsp;pwLogClust() As Integer, _<BR>&nbsp;psva As SCRIPT_VISATTR, _<BR>&nbsp;piAdvance() As Long, _<BR>&nbsp;pSA As SCRIPT_ANALYSIS, _<BR>&nbsp;pABC As ABC, _<BR>&nbsp;piJustify As Long _<BR>&nbsp;) As Long</STRONG></FONT></P>
<P><FONT face="Consolas,Courier New" size=1><STRONG>Declare Function ScriptBreak Lib "usp10.dll" ( _<BR>&nbsp;pwcChars As Long, _<BR>&nbsp;ByVal cChars As Long, _<BR>&nbsp;pSA As SCRIPT_ANALYSIS, _<BR>&nbsp;psla As SCRIPT_LOGATTR _<BR>&nbsp;) As Long<BR>&nbsp;<BR>Declare Function ScriptCPtoX Lib "usp10.dll" ( _<BR>&nbsp;ByVal iCP As Long, _<BR>&nbsp;ByVal fTrailing As Long, _<BR>&nbsp;ByVal cChars As Long, _<BR>&nbsp;ByVal cGlyphs As Long, _<BR>&nbsp;pwLogClust As Integer, _<BR>&nbsp;psva As SCRIPT_VISATTR, _<BR>&nbsp;piAdvance As Long, _<BR>&nbsp;pSA As SCRIPT_ANALYSIS, _<BR>&nbsp;piX As Long _<BR>&nbsp;) As Long</STRONG></FONT></P>
<P><FONT face="Consolas,Courier New" size=1><STRONG>Declare Function ScriptCacheGetHeight Lib "usp10.dll" ( _<BR>&nbsp;ByVal hdc As Long, _<BR>&nbsp;psc As SCRIPT_CACHE, _<BR>&nbsp;tmHeight As Long _<BR>&nbsp;) As Long<BR>&nbsp;<BR>Declare Function ScriptFreeCache Lib "usp10.dll" ( _<BR>&nbsp;psc As SCRIPT_CACHE _<BR>&nbsp;) As Long<BR>&nbsp;<BR>Declare Function ScriptGetCMap Lib "usp10.dll" ( _<BR>&nbsp;ByVal hdc As Long, _<BR>&nbsp;psc As SCRIPT_CACHE, _<BR>&nbsp;ByVal pwcInChars As Long, _<BR>&nbsp;ByVal cChars As Long, _<BR>&nbsp;ByVal dwFlags As SCRIPT_GET_CMAP_FLAGS, _<BR>&nbsp;pwOutGlyphs() As Integer _<BR>&nbsp;) As Long</STRONG></FONT></P>
<P><FONT face="Consolas,Courier New" size=1><STRONG>Declare Function ScriptGetFontProperties Lib "usp10.dll" ( _<BR>&nbsp;ByVal hdc As Long, _<BR>&nbsp;psc As SCRIPT_CACHE, _<BR>&nbsp;sfp As SCRIPT_FONTPROPERTIES _<BR>&nbsp;) As Long<BR>&nbsp;<BR>Declare Function ScriptGetGlyphABCWidth Lib "usp10.dll" ( _<BR>&nbsp;ByVal hdc As Long, _<BR>&nbsp;psc As SCRIPT_CACHE, _<BR>&nbsp;ByVal wGlyph As Integer, _<BR>&nbsp;pABC As ABC _<BR>&nbsp;) As Long</STRONG></FONT></P>
<P><FONT face="Consolas,Courier New" size=1><STRONG>Declare Function ScriptGetLogicalWidths Lib "usp10.dll" ( _<BR>&nbsp;pSA As SCRIPT_ANALYSIS, _<BR>&nbsp;ByVal cChars As Long, _<BR>&nbsp;ByVal cGlyphs As Long, _<BR>&nbsp;piGlyphWidth() As Long, _<BR>&nbsp;pwLogClust() As Integer, _<BR>&nbsp;psva As SCRIPT_VISATTR, _<BR>&nbsp;piDx As Long _<BR>&nbsp;) As Long</STRONG></FONT></P>
<P><FONT face="Consolas,Courier New" size=1><STRONG>Declare Function ScriptGetProperties Lib "usp10.dll" ( _<BR>&nbsp;ppSp As SCRIPT_PROPERTIES, _<BR>&nbsp;piNumScripts As Long _<BR>&nbsp;) As Long<BR>&nbsp;<BR>Declare Function ScriptIsComplex Lib "usp10.dll" ( _<BR>&nbsp;ByVal pwcInChars As Long, _<BR>&nbsp;ByVal cInChars As Long, _<BR>&nbsp;ByVal dwFlags As SCRIPT_IS_COMPLEX_FLAGS _<BR>&nbsp;) As Long</STRONG></FONT></P>
<P><FONT face="Consolas,Courier New" size=1><STRONG>Declare Function ScriptItemize Lib "usp10.dll" ( _<BR>&nbsp;ByVal pwcInChars As Long, _<BR>&nbsp;ByVal cInChars As Long, _<BR>&nbsp;ByVal cMaxItems As Long, _<BR>&nbsp;psControl As SCRIPT_CONTROL, _<BR>&nbsp;psState As SCRIPT_STATE, _<BR>&nbsp;pItems() As SCRIPT_ITEM, _<BR>&nbsp;pcItems As Long _<BR>&nbsp;) As Long</STRONG></FONT></P>
<P><FONT face="Consolas,Courier New" size=1><STRONG>Declare Function ScriptJustify Lib "usp10.dll" ( _<BR>&nbsp;psva As SCRIPT_VISATTR, _<BR>&nbsp;piAdvance() As Long, _<BR>&nbsp;ByVal cGlyphs As Long, _<BR>&nbsp;ByVal iDx As Long, _<BR>&nbsp;ByVal iMinKashida As Long, _<BR>&nbsp;piJustify() As Long _<BR>&nbsp;) As Long</STRONG></FONT></P>
<P><FONT face="Consolas,Courier New" size=1><STRONG>Declare Function ScriptLayout Lib "usp10.dll" ( _<BR>&nbsp;ByVal cRuns As Long, _<BR>&nbsp;pbLevel() As Byte, _<BR>&nbsp;piVisualToLogical() As Long, _<BR>&nbsp;piLogicalToVisual() As Long _<BR>&nbsp;) As Long</STRONG></FONT></P>
<P><FONT face="Consolas,Courier New" size=1><STRONG>Declare Function ScriptPlace Lib "usp10.dll" ( _<BR>&nbsp;ByVal hdc As Long, _<BR>&nbsp;psc As SCRIPT_CACHE, _<BR>&nbsp;pwGlyphs() As Integer, _<BR>&nbsp;ByVal cGlyphs As Long, _<BR>&nbsp;psva As SCRIPT_VISATTR, _<BR>&nbsp;pSA As SCRIPT_ANALYSIS, _<BR>&nbsp;piAdvance() As Long, _<BR>&nbsp;pGoffset As GOFFSET, _<BR>&nbsp;pABC As ABC _<BR>&nbsp;) As Long</STRONG></FONT></P>
<P><FONT face="Consolas,Courier New" size=1><STRONG>Declare Function ScriptRecordDigitSubstitution Lib "usp10.dll" ( _<BR>&nbsp;ByVal Locale As Long, _<BR>&nbsp;psds As SCRIPT_DIGITSUBSTITUTE _<BR>&nbsp;) As Long</STRONG></FONT></P>
<P><FONT face="Consolas,Courier New" size=1><STRONG>Declare Function ScriptShape Lib "usp10.dll" ( _<BR>&nbsp;ByVal hdc As Long, _<BR>&nbsp;psc As SCRIPT_CACHE, _<BR>&nbsp;ByVal pwcChars As Long, _<BR>&nbsp;ByVal cChars As Long, _<BR>&nbsp;ByVal cMaxGlyphs As Long, _<BR>&nbsp;pas As SCRIPT_ANALYSIS, _<BR>&nbsp;pwOutGlyphs() As Integer, _<BR>&nbsp;pwLogClust() As Integer, _<BR>&nbsp;psva As SCRIPT_VISATTR, _<BR>&nbsp;pcGlyphs As Long _<BR>&nbsp;) As Long</STRONG></FONT></P>
<P><FONT face="Consolas,Courier New" size=1><STRONG>Declare Function ScriptTextOut Lib "usp10.dll" ( _<BR>&nbsp;ByVal hdc As Long, _<BR>&nbsp;psc As SCRIPT_CACHE, _<BR>&nbsp;ByVal x As Long, _<BR>&nbsp;ByVal y As Long, _<BR>&nbsp;ByVal fuOptions As ETOFlags, _<BR>&nbsp;lprc As RECT, _<BR>&nbsp;pSA As SCRIPT_ANALYSIS, _<BR>&nbsp;ByVal pwcReserved As Long, _<BR>&nbsp;ByVal iReserved As Long, _<BR>&nbsp;pwGlyphs() As Integer, _<BR>&nbsp;ByVal cGlyphs As Long, _<BR>&nbsp;piAdvance() As Long, _<BR>&nbsp;piJustify As Any, _<BR>&nbsp;pGoffset As GOFFSET _<BR>&nbsp;) As Long</STRONG></FONT></P>
<P><FONT face="Consolas,Courier New" size=1><STRONG>Declare Function ScriptXtoCP Lib "usp10.dll" ( _<BR>&nbsp;ByVal iX As Long, _<BR>&nbsp;ByVal cChars As Long, _<BR>&nbsp;ByVal cGlyphs As Long, _<BR>&nbsp;pwLogClust() As Integer, _<BR>&nbsp;psva As SCRIPT_VISATTR, _<BR>&nbsp;piAdvance() As Long, _<BR>&nbsp;pSA As SCRIPT_ANALYSIS, _<BR>&nbsp;piCP As Long, _<BR>&nbsp;piTrailing As Long _<BR>&nbsp;) As Long</STRONG></FONT></P>
<P><FONT face="Consolas,Courier New" size=1><STRONG>'--------------------------------<BR>'&nbsp;&nbsp; Uniscribe Script* APIs<BR>Declare Function ScriptStringAnalyse Lib "usp10.dll" ( _<BR>&nbsp;ByVal hdc As Long, _<BR>&nbsp;ByVal pString As Long, _<BR>&nbsp;ByVal cString As Long, _<BR>&nbsp;ByVal cGlyphs As Long, _<BR>&nbsp;ByVal iCharset As Long, _<BR>&nbsp;ByVal dwFlags As SSA_FLAGS, _<BR>&nbsp;ByVal iReqWidth As Long, _<BR>&nbsp;ByRef psControl As Any, _<BR>&nbsp;ByRef psState As Any, _<BR>&nbsp;ByRef piDx As Long, _<BR>&nbsp;ByRef pTabdef As Any, _<BR>&nbsp;ByRef pbInClass As GCPCLASS, _<BR>&nbsp;ByRef pssa As Long _<BR>&nbsp;) As Long<BR>&nbsp;<BR>Declare Function ScriptStringCPtoX Lib "usp10.dll" ( _<BR>&nbsp;ByVal ssa As Long, _<BR>&nbsp;ByVal iCP As Long, _<BR>&nbsp;ByVal fTrailing As Long, _<BR>&nbsp;pX As Long _<BR>&nbsp;) As Long</STRONG></FONT></P>
<P><FONT face="Consolas,Courier New" size=1><STRONG>Declare Function ScriptStringFree Lib "usp10.dll" ( _<BR>&nbsp;ByRef pssa As Long _<BR>&nbsp;) As Long</STRONG></FONT></P>
<P><FONT face="Consolas,Courier New" size=1><STRONG>Declare Function ScriptStringGetLogicalWidths Lib "usp10.dll" ( _<BR>&nbsp;ByVal ssa As Long, _<BR>&nbsp;piDx() As Long _<BR>&nbsp;) As Long<BR>&nbsp;<BR>Declare Function ScriptStringGetOrder Lib "usp10.dll" ( _<BR>&nbsp;ByVal ssa As Long, _<BR>&nbsp;puOrder As Long _<BR>&nbsp;) As Long<BR>&nbsp;<BR>Declare Function ScriptStringOut Lib "usp10.dll" ( _<BR>&nbsp;ByVal ssa As Long, _<BR>&nbsp;ByVal iX As Long, _<BR>&nbsp;ByVal iY As Long, _<BR>&nbsp;ByVal uOptions As ETOFlags, _<BR>&nbsp;prc As RECT, _<BR>&nbsp;ByVal iMinSel As Long, _<BR>&nbsp;ByVal iMaxSel As Long, _<BR>&nbsp;ByVal fDisabled As BOOL _<BR>&nbsp;) As Long</STRONG></FONT></P>
<P><FONT face="Consolas,Courier New" size=1><STRONG>Declare Function ScriptString_pcOutChars Lib "usp10.dll" ( _<BR>&nbsp;ByVal ssa As Long _<BR>&nbsp;) As Long</STRONG></FONT></P>
<P><FONT face="Consolas,Courier New" size=1><STRONG>Declare Function ScriptString_pLogAttr Lib "usp10.dll" ( _<BR>&nbsp;ByVal ssa As Long _<BR>&nbsp;) As Long</STRONG></FONT></P>
<P><FONT face="Consolas,Courier New" size=1><STRONG>Declare Function ScriptString_pSize Lib "usp10.dll" ( _<BR>&nbsp;ByVal ssa As Long _<BR>&nbsp;) As Long</STRONG></FONT></P>
<P><FONT face="Consolas,Courier New" size=1><STRONG>Declare Function ScriptStringValidate Lib "usp10.dll" ( _<BR>&nbsp;ByVal ssa As Long _<BR>&nbsp;) As Long</STRONG></FONT></P>
<P><FONT face="Consolas,Courier New" size=1><STRONG>Declare Function ScriptStringXtoCP Lib "usp10.dll" ( _<BR>&nbsp;ByVal ssa As Long, _<BR>&nbsp;ByVal iX As Long, _<BR>&nbsp;piCh As Long, _<BR>&nbsp;piTrailing As Long _<BR>&nbsp;) As Long</STRONG></FONT></P>
<P><FONT face="Consolas,Courier New" size=1><STRONG>'---------------------<BR>'&nbsp;&nbsp; Wrappers around several Uniscribe functions that allow slightly<BR>'&nbsp;&nbsp; more friendly VB interaction<BR>'<BR>'&nbsp;&nbsp; ScriptStringFreeC<BR>'&nbsp;&nbsp; ScriptString_pcOutCharsC<BR>'&nbsp;&nbsp; ScriptString_pSizeC<BR>'&nbsp;&nbsp; ScriptString_pLogAttrC<BR>'&nbsp;&nbsp; ScriptStringAnalyseC<BR>'&nbsp;&nbsp; ScriptStringCPtoXC<BR>'&nbsp;&nbsp; ScriptStringXtoCPC<BR>'<BR>'&nbsp;&nbsp; ScriptIsComplex<BR>'---------------------<BR>Public Function ScriptStringFreeC(ssa As Long) As Long<BR>&nbsp;&nbsp;&nbsp; If ssa &lt;&gt; 0 Then<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ScriptStringFreeC = ScriptStringFree(ssa)<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ssa = 0&amp;<BR>&nbsp;&nbsp;&nbsp; End If<BR>End Function</STRONG></FONT></P>
<P><FONT face="Consolas,Courier New" size=1><STRONG>&nbsp;Public Function ScriptString_pcOutCharsC(ssa As Long) As Long<BR>Dim pcch As Long<BR>&nbsp;&nbsp;&nbsp; pcch = ScriptString_pcOutChars(ssa)<BR>&nbsp;&nbsp;&nbsp; If pcch &lt;&gt; 0 Then<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; CopyMemory ScriptString_pcOutCharsC, ByVal pcch, Len(pcch)<BR>&nbsp;&nbsp;&nbsp; End If<BR>End Function<BR>Public Function ScriptString_pSizeC(ssa As Long) As OleTypes.Size<BR>Dim psiz As Long<BR>&nbsp;&nbsp;&nbsp; psiz = ScriptString_pSize(ssa)<BR>&nbsp;&nbsp;&nbsp; If psiz &lt;&gt; 0 Then<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; CopyMemory ScriptString_pSizeC, ByVal psiz, Len(ScriptString_pSizeC)<BR>&nbsp;&nbsp;&nbsp; End If<BR>End Function<BR>Public Sub ScriptString_pLogAttrC(ssa As Long, cch As Long, rgsla() As SCRIPT_LOGATTR_VB)<BR>Dim prgtsla As Long<BR>Dim rgtsla() As SCRIPT_LOGATTR<BR>Dim itsla As Long<BR>Dim byt As Byte<BR>&nbsp;&nbsp;&nbsp; <BR>&nbsp;&nbsp;&nbsp; ' Call Uniscribe to get the LogAttr info<BR>&nbsp;&nbsp;&nbsp; prgtsla = ScriptString_pLogAttr(ssa)<BR>&nbsp;&nbsp;&nbsp; <BR>&nbsp;&nbsp;&nbsp; If prgtsla &lt;&gt; 0 Then<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ' Success! Lets put the pointer into a struct and prepare some memory<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ReDim rgtsla(0 To cch - 1)<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; CopyMemory rgtsla(0), ByVal prgtsla, CLng(Len(rgtsla(0)) * cch)<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ReDim rgsla(0 To cch - 1)<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ' Convert the unfriendly C type into a friendly VB type that can be used elsewhere<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; For itsla = 0 To cch - 1<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; byt = rgtsla(itsla).fBitFields<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; With rgsla(itsla)<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .fSoftBreak = RightShift((byt And &amp;H1), 0)<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .fWhiteSpace = RightShift((byt And &amp;H2), 1)<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .fCharStop = RightShift((byt And &amp;H4), 2)<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .fWordStop = RightShift((byt And &amp;H8), 3)<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .fInvalid = RightShift((byt And &amp;H10), 4)<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .fReserved = RightShift((byt And &amp;HE0), 5) ' &amp;HE0 = (2 ^ 5 Or 2 ^ 6 Or 2 ^ 7)<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; End With<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Next itsla<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Erase rgtsla<BR>&nbsp;&nbsp;&nbsp; End If<BR>End Sub<BR>Public Function ScriptStringAnalyseC( _ <BR>&nbsp; hdc As Long, stAnalyse As String, cch As Long, _ <BR>&nbsp; ByVal dwFlags As SSA_FLAGS, iReqWidth As Long,&nbsp; _ <BR>&nbsp; Optional vSCV As Variant, Optional vSSV As Variant, _ <BR>&nbsp; Optional vST As Variant) As Long<BR>Dim ssa As Long<BR>Dim sc As SCRIPT_CONTROL<BR>Dim ss As SCRIPT_STATE<BR>Dim st As SCRIPT_TABDEF<BR>&nbsp;&nbsp;&nbsp; If Not IsMissing(vSCV) Then<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; sc.uDefaultLanguage = vSCV.uDefaultLanguage<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; sc.fBitFields = _<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; LeftShift(vSCV.fContextDigits, 0) Or _<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; LeftShift(vSCV.fInvertPreBoundDir, 1) Or _<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; LeftShift(vSCV.fInvertPostBoundDir, 2) Or _<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; LeftShift(vSCV.fLinkStringBefore, 3) Or _<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; LeftShift(vSCV.fLinkStringAfter, 4) Or _<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; LeftShift(vSCV.fNeutralOverride, 5) Or _<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; LeftShift(vSCV.fNumericOverride, 6) Or _<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; LeftShift(vSCV.fLegacyBidiClass, 7)<BR>&nbsp;&nbsp;&nbsp; End If<BR>&nbsp;&nbsp;&nbsp; <BR>&nbsp;&nbsp;&nbsp; If Not IsMissing(vSSV) Then<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ss.fBitFields1 = _<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; LeftShift(vSSV.uBidiLevel, 4) Or _<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; LeftShift(vSSV.fOverrideDirection, 5) Or _<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; LeftShift(vSSV.fInhibitSymSwap, 6) Or _<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; LeftShift(vSSV.fCharShape, 7)<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ss.fBitFields2 = _<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; LeftShift(vSSV.fDigitSubstitute, 0) Or _<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; LeftShift(vSSV.fInhibitLigate, 1) Or _<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; LeftShift(vSSV.fDisplayZWG, 2) Or _<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; LeftShift(vSSV.fArabicNumContext, 3) Or _<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; LeftShift(vSSV.fGcpClusters, 4)<BR>&nbsp;&nbsp;&nbsp; End If<BR>&nbsp;&nbsp;&nbsp; <BR>&nbsp;&nbsp;&nbsp; If Not IsMissing(vST) And ((dwFlags And SSA_TAB) = SSA_TAB) Then<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; st.cTabStops = vST.cTabStops<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; st.iScale = vST.iScale<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; st.pTabStops = vST.pTabStops<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; st.iTabOrigin = vST.iTabOrigin<BR>&nbsp;&nbsp;&nbsp; End If<BR>&nbsp;&nbsp;&nbsp; <BR>&nbsp;&nbsp;&nbsp; If ScriptStringAnalyse(hdc, StrPtr(stAnalyse), cch, 0, -1, dwFlags, iReqWidth, sc, ss, ByVal 0&amp;, st, ByVal 0&amp;, ssa) = S_OK Then<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ScriptStringAnalyseC = ssa<BR>&nbsp;&nbsp;&nbsp; End If<BR>End Function<BR>Public Function ScriptStringCPtoXC(ssa As Long, iCP As Long, fTrailing As BOOL) As Long<BR>Dim pX As Long<BR>&nbsp;&nbsp;&nbsp; If ScriptStringCPtoX(ssa, iCP, fTrailing, pX) = S_OK Then<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ScriptStringCPtoXC = pX<BR>&nbsp;&nbsp;&nbsp; End If<BR>End Function<BR>Public Function ScriptStringXtoCPC(ssa As Long, ByVal iX As Long, piTrailing As BOOL) As Long<BR>Dim piCh As Long<BR>&nbsp;&nbsp;&nbsp; If ScriptStringXtoCP(ssa, iX, piCh, piTrailing) = S_OK Then<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ScriptStringXtoCPC = piCh<BR>&nbsp;&nbsp;&nbsp; End If<BR>End Function<BR>Public Function ScriptIsComplexC(stIn As String, Optional Flags As SCRIPT_IS_COMPLEX_FLAGS) As Boolean<BR>Dim hr As Long<BR>&nbsp;&nbsp;&nbsp; <BR>&nbsp;&nbsp;&nbsp; hr = ScriptIsComplex(StrPtr(stIn), Len(stIn), Flags)<BR>&nbsp;&nbsp;&nbsp; If hr = S_OK Then<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ScriptIsComplexC = True<BR>&nbsp;&nbsp;&nbsp; ElseIf hr = S_FALSE Then<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ScriptIsComplexC = False<BR>&nbsp;&nbsp;&nbsp; Else<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Err.Raise hr<BR>&nbsp;&nbsp;&nbsp; End If<BR>End Function<BR>Public Function ScriptRecordDigitSubstitutionC(Locale As Long) As SCRIPT_DIGITSUBSTITUTE<BR>Dim psds As SCRIPT_DIGITSUBSTITUTE</STRONG></FONT></P>
<P><FONT face="Consolas,Courier New" size=1><STRONG>&nbsp;&nbsp;&nbsp; If ScriptRecordDigitSubstitution(Locale, psds) = S_OK Then<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ScriptRecordDigitSubstitutionC = psds<BR>&nbsp;&nbsp;&nbsp; End If<BR>End Function</STRONG></FONT></P>
<P><FONT face="Consolas,Courier New" size=1><STRONG>'---------------------<BR>'&nbsp;&nbsp; IchNext/IchPrev<BR>'<BR>'&nbsp;&nbsp; Takes a SCRIPT_STRING_ANALYSIS and a character position and<BR>'&nbsp;&nbsp; returns the next or previous character position or word position, taking<BR>'&nbsp;&nbsp; Uniscribe "clusters" into account<BR>'---------------------<BR>Public Function IchNext(ssa As Long, ByVal ich As Long, fWord As Boolean) As Long<BR>Dim cch As Long<BR>Dim rgsla() As SCRIPT_LOGATTR_VB<BR>&nbsp;&nbsp;&nbsp; cch = ScriptString_pcOutCharsC(ssa)<BR>&nbsp;&nbsp;&nbsp; Call ScriptString_pLogAttrC(ssa, cch, rgsla())<BR>&nbsp;&nbsp;&nbsp; Do Until ich &gt;= cch - 1<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ich = ich + 1<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; If (rgsla(ich).fCharStop And Not fWord) Then Exit Do&nbsp;&nbsp;&nbsp; ' We are at the end of a character<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; If (rgsla(ich).fWordStop And fWord) Then Exit Do&nbsp;&nbsp;&nbsp; ' We are at the end of a word<BR>&nbsp;&nbsp;&nbsp; Loop<BR>&nbsp;&nbsp;&nbsp; If ich &gt; cch - 1 Then ich = cch ' Take care of the boundary cases<BR>&nbsp;&nbsp;&nbsp; IchNext = ich<BR>End Function<BR>Public Function IchPrev(ssa As Long, ByVal ich As Long, fWord As Boolean) As Long<BR>Dim cch As Long<BR>Dim rgsla() As SCRIPT_LOGATTR_VB<BR>&nbsp;&nbsp;&nbsp; If ich &gt; 0 Then ' Make sure we are at the beginning of the string already<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cch = ScriptString_pcOutCharsC(ssa)<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Call ScriptString_pLogAttrC(ssa, cch, rgsla())<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Do Until ich &lt;= 0<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; If (rgsla(ich).fCharStop And Not fWord) Then Exit Do&nbsp;&nbsp;&nbsp; ' We are at the end of a character<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; If (rgsla(ich).fWordStop And fWord) Then Exit Do&nbsp;&nbsp;&nbsp; ' We are at the end of a word<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ich = ich - 1<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Loop<BR>&nbsp;&nbsp;&nbsp; End If<BR>&nbsp;&nbsp;&nbsp; If ich &lt; 0 Then ich = 0 ' Take care of the boundary cases<BR>&nbsp;&nbsp;&nbsp; IchPrev = ich<BR>End Function</STRONG></FONT></P>
<P><FONT face="Consolas,Courier New" size=1><STRONG>'---------------------<BR>'&nbsp;&nbsp; IchBreakSpot<BR>'<BR>'&nbsp;&nbsp; Find the appropriate place to break for this line. Here<BR>'&nbsp;&nbsp; is the algorithm used:<BR>'<BR>'&nbsp;&nbsp; 1) If all text will fit or no line breaking is specified, then output the whole string<BR>'&nbsp;&nbsp; 2) If #1 is not true, find the first hard break within the text that could fit on the line<BR>'&nbsp;&nbsp; 3) If #2 could not be found, then look for the last softbreak or whitespace within the text that could fit on the line.<BR>'&nbsp;&nbsp; 4) If #3 is a whitespace, then break AFTER the character<BR>'&nbsp;&nbsp; 5) If #3 is a soft break, than break before the character<BR>'---------------------<BR>Public Function IchBreakSpot(st As String, rgsla() As SCRIPT_LOGATTR_VB, cch As Long, Optional fNoLineBreaks As Boolean = False) As Long<BR>Dim ich As Long<BR>&nbsp;&nbsp;&nbsp; <BR>&nbsp;&nbsp;&nbsp; ' First check for a hard break<BR>&nbsp;&nbsp;&nbsp; ich = InStr(1, st, vbCrLf, vbBinaryCompare) - 1<BR>&nbsp;&nbsp;&nbsp; If ich &gt;= 0 And ich &lt;= cch - 1 Then<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ' Use the hard break that was found<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; IchBreakSpot = ich<BR>&nbsp;&nbsp;&nbsp; ElseIf Len(st) &gt; cch Then<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ' There are more characters then there is space to output, on this line<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ' at least. So walk the string backwards, looking for a break character.<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; For ich = cch - 1 To 0 Step -1<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; With rgsla(ich)<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ' Check to see if its a soft break char or a white space char<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; If .fWhiteSpace Or .fSoftBreak Then<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; If .fWhiteSpace Then<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ' White space means break AFTER this character<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; IchBreakSpot = ich<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ElseIf ich &gt; 0 Then<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ' Its a softbreak. If we have the characters to spare,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ' subtract one because we should be breaking BEFORE<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ' the character, not AFTER.<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; IchBreakSpot = ich - 1<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Else<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ' There are not enough chars to go after. This probably should<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ' never happen, but we may as well make sure.<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; IchBreakSpot = 0<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; End If<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Exit For<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; End If<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; End With<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Next ich<BR>&nbsp;&nbsp;&nbsp; End If<BR>&nbsp;&nbsp;&nbsp; <BR>&nbsp;&nbsp;&nbsp; ' Assume cch is where its at if it has never been set<BR>&nbsp;&nbsp;&nbsp; If IchBreakSpot = 0 Then IchBreakSpot = cch<BR>End Function</STRONG></FONT></P>
<P><FONT face="Consolas,Courier New" size=1><STRONG>'---------------------<BR>'&nbsp;&nbsp; UniscribeExtTextOutW<BR>'<BR>'&nbsp;&nbsp; The Uniscribe-aware version of ExtTextOutW<BR>'---------------------<BR>Public Function UniscribeExtTextOutW(hdc As Long, wOptions As ETOFlags, lpRect As RECT, ByVal st As String, Optional x1 As Long = 0, Optional x2 As Long = 0) As Long<BR>On Error Resume Next<BR>Dim ssa As Long<BR>Dim xWidth As Long<BR>Dim cch As Long<BR>Dim ichBreak As Long<BR>Dim siz As Size<BR>Dim rgsla() As SCRIPT_LOGATTR_VB<BR>Dim rct As RECT<BR>&nbsp;&nbsp;&nbsp; <BR>&nbsp;&nbsp;&nbsp; ' deep copy the rect since may be modifying it<BR>&nbsp;&nbsp;&nbsp; rct.Left = lpRect.Left<BR>&nbsp;&nbsp;&nbsp; rct.Right = lpRect.Right<BR>&nbsp;&nbsp;&nbsp; rct.Top = lpRect.Top<BR>&nbsp;&nbsp;&nbsp; rct.Bottom = lpRect.Bottom<BR>&nbsp;&nbsp;&nbsp; <BR>&nbsp;&nbsp;&nbsp; xWidth = rct.Right - rct.Left<BR>&nbsp;&nbsp;&nbsp; <BR>&nbsp;&nbsp;&nbsp; ' Keep going till all of the string is done<BR>&nbsp;&nbsp;&nbsp; Do Until Len(st) = 0<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ssa = ScriptStringAnalyseC(hdc, st, Len(st), SSA_GLYPHS Or SSA_FALLBACK Or SSA_CLIP Or SSA_BREAK, xWidth)<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; If ssa &lt;&gt; 0 Then<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cch = ScriptString_pcOutCharsC(ssa)<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Call ScriptString_pLogAttrC(ssa, cch, rgsla())<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ' Get the appropriate break point for this line (see comments in<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ' IchBreakSpot for a better understanding of "appropriate"<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ' CONSIDER: MULTILINE: To support multiple lines, the fNoLineBreaks flag<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ' below would have to be set to False. The rest of the function depends on it!<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ichBreak = IchBreakSpot(st, rgsla(), cch, True)</STRONG></FONT></P>
<P><FONT face="Consolas,Courier New" size=1><STRONG>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ' Free up the analysis, we need to do it again with the new break info<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Call ScriptStringFreeC(ssa)<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ' reanalyze the string<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ssa = ScriptStringAnalyseC(hdc, st, ichBreak, SSA_GLYPHS Or SSA_FALLBACK Or SSA_CLIP Or SSA_BREAK, xWidth)<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; If ssa &lt;&gt; 0 Then<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; siz = ScriptString_pSizeC(ssa)<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cch = ScriptString_pcOutCharsC(ssa)<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ' Output the string, now that we have done all the preparation<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Call ScriptStringOut(ssa, rct.Left, rct.Top, wOptions, rct, x1, x2, BOOL_FALSE)<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ' Remove the portion of the string that has been output and adjust the rect<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ' for the next line<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; st = Mid$(st, cch + 1)<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rct.Top = rct.Top + siz.cy<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; End If<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ' Free up the analysis, we need to (so we can do the next one)!<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Call ScriptStringFreeC(ssa)<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; End If<BR>&nbsp;&nbsp;&nbsp; Loop<BR>End Function<BR><BR>'-----------------------<BR>' LeftShift<BR>'<BR>'&nbsp;&nbsp; Since VB does not have a left shift operator<BR>'&nbsp;&nbsp; LeftShift(8,2) is equivalent to 8 &lt;&lt; 2<BR>'-----------------------<BR>Public Function LeftShift(ByVal lNum As Long, ByVal lShift As Long) As Long<BR>&nbsp;&nbsp;&nbsp; LeftShift = lNum * (2 ^ lShift)<BR>End Function</STRONG></FONT></P>
<P><FONT face="Consolas,Courier New" size=1><STRONG>'-----------------------<BR>' RightShift<BR>'<BR>'&nbsp;&nbsp; Since VB does not have a right shift operator<BR>'&nbsp;&nbsp; RightShift(8,2) is equivalent to 8 &gt;&gt; 2<BR>'-----------------------<BR>Public Function RightShift(ByVal lNum As Long, ByVal lShift As Long) As Long<BR>&nbsp;&nbsp;&nbsp; RightShift = lNum \ (2 ^ lShift)<BR>End Function</STRONG></FONT></P></BLOCKQUOTE></BLOCKQUOTE>
<P><FONT face=Tahoma></FONT>&nbsp;</P>
<hr/><p><a id="633854" href="#633854">#</a> <strong>sherif omran</strong> on 16 Jun 2006 4:47 AM:</p><div style="margin-left: 1em">the code is nice, but not complete and has many faulty points, one shouldnt directly use the functions written without thinking.</div>
<p><a id="634018" href="#634018">#</a> <strong>Michael S. Kaplan</strong> on 16 Jun 2006 8:52 AM:</p><div style="margin-left: 1em">Hi Sherif --<br><br>Well, that is why the book with a full-featured sample control with source is very handy? But I am not republishing the book here, I am answering a specific request that has come in several times.... and I have to trust if someone has been trying to call Uniscribe but failing that one has at least been thinking about it. :-)<br><br>There are interesting Uniscribe samples in the wild (including some I link to) and the principles for calling Unicode Win32 API functions from VB is also covered territory.</div>
<p><a id="659772" href="#659772">#</a> <strong>sherif omran</strong> on 8 Jul 2006 3:56 AM:</p><div style="margin-left: 1em">The book you talk about is out of print, there is totally no print of it in europe. I could correct the errors in this code and use scriptstringout, but the Question is:<br><br>(1) how can one define the font to be used for printing?<br><br>(2) how do you get the width of the printed string so that one can print a pointer at the end.<br><br>(3) how can you change the color of a part of the string?<br><br>waiting your reply,<br>kind regards,<br>Sherif </div>
<p><a id="660014" href="#660014">#</a> <strong>Sherif Omran</strong> on 8 Jul 2006 8:48 AM:</p><div style="margin-left: 1em">I can buy from you the cd for 20$ and i dont need the book.</div>
<p><a id="660122" href="#660122">#</a> <strong>Michael S. Kaplan</strong> on 8 Jul 2006 12:15 PM:</p><div style="margin-left: 1em">You are assuming that they give me CDs to just sell? They are in little sleeves at the back of the book....</div>
<p><a id="660462" href="#660462">#</a> <strong>Sherif Omran</strong> on 9 Jul 2006 3:23 AM:</p><div style="margin-left: 1em">OK, <br><br>what is the possible solution?<br> <br>You dont want to help or give a code, and the book doesnot exist any more. What can you offer?<br>Can you offer me a pdf version of the book?<br><br>If you can't offer me the book or the cd, please dont tell me the book again.<br><br>can you send me some examples of changing the color of a part of the string? <br><br></div>
<p><a id="660564" href="#660564">#</a> <strong>Michael S. Kaplan</strong> on 9 Jul 2006 8:40 AM:</p><div style="margin-left: 1em">I do not have a PDF copy to send, either. And I have not been in the habit of sending around free code to people's email addresses on demand, either. <BR><BR>The book does exist and can be found from time to time on various book sites (for example, there are two copies on amazon.com right now). Perhaps the price seems a bit steep, though I'll point out that compared to my hourly consulting rates when I did consult, it is a bargain (esp, since you are getting much more than an hour's work from me!). <BR><BR>I talked about ways to deal with color in different pieces of the string in Uniscribe (as well as other shaping issues) back in December <A href="http://archives.miloush.net/michkap/archive/2005/12/19/505309.html"><STRONG>here</STRONG></A>, and that way should work from VB as well. <BR><BR>Though on the whole this area (to be successful) requires someone who really understands how both Uniscribe works and how to use VB as a tool to write code that it was not necessarily intended to do -- ala Matt Curland's book (one you definitely want on your shelf if you are going down that road). <BR><BR>But I am sorry to say that accosting an author six years after they wrote a book for not doing the work for you is not the way to make things happen -- I do not even run a copy of VB6 on any of my machines at the moment....</div>
<p><a id="660565" href="#660565">#</a> <strong>Michael S. Kaplan</strong> on 9 Jul 2006 8:44 AM:</p><div style="margin-left: 1em">Looking at the first comment you posted: <BR><BR><EM><FONT size=2>"one shouldnt directly use the functions written without thinking" </FONT></EM><BR><BR>This is true of ANY and ALL code one runs, but especially true about any code that calls Uniscribe directly!</div>
<p><a id="665888" href="#665888">#</a> <strong>Sherif Omran</strong> on 14 Jul 2006 1:50 PM:</p><div style="margin-left: 1em">When i contacted James, he was extreemly keen to help, and when i contacted you.. hah .. you are keen to sell the air and this doesnt return a fruit.<br></div>
<p><a id="665896" href="#665896">#</a> <strong>Michael S. Kaplan</strong> on 14 Jul 2006 1:59 PM:</p><div style="margin-left: 1em">Hmmm. Ok.</div>
<hr/><p><em>go to <a id="newer" href="http://archives.miloush.net/michkap/archive/2006/06/13/629737.html" title="66 Percent">newer</a> or <a id="older" href="http://archives.miloush.net/michkap/archive/2006/06/12/627185.html" title="More problems with the Shell&#39;s &#39;ultimate font&#39; solutions">older</a> post, or back to <a href="http://archives.miloush.net/michkap/archive/index.html">index</a> or <a href="http://archives.miloush.net/michkap/archive/index.html#2006-06">month</a> or <a href="http://archives.miloush.net/michkap/archive/index.html#2006-06-12">day</a></em></p></body>
<!-- Mirrored from archives.miloush.net/michkap/archive/2006/06/12/628714.html by HTTrack Website Copier/3.x [XR&CO'2014], Thu, 25 May 2017 00:42:39 GMT -->
</html>