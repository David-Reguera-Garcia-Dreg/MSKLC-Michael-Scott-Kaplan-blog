<html>
<!-- Mirrored from archives.miloush.net/michkap/archive/2006/08/01/685351.html by HTTrack Website Copier/3.x [XR&CO'2014], Thu, 25 May 2017 00:42:39 GMT -->
<head><meta charset="utf-8" /><meta name="viewport" content="width=device-width" /><title>Sometimes, ignoring case is stupid</title></head><body>
<h1>Sometimes, ignoring case is stupid</h1>
<p><em>by Michael S. Kaplan, published on 2006/08/01 09:01 -07:00, original URI: http://blogs.msdn.com/michkap/archive/2006/08/01/685351.aspx</em></p>
<hr/> <!-- Archival Source: ProcessPostOld -->
<FONT face=Tahoma>
<P>I talked about some of this once before in <STRONG><A href="http://archives.miloush.net/michkap/archive/2006/03/02/542395.html">CompareString ignores case by lowercasing....</A></STRONG>, as you may recall. </P>
<P>There are some people who think of ignoring case as required to keep things from sorting in the 'ASCII order' -- by which I mean </P>
<P>&nbsp;&nbsp;&nbsp;ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz </P>
<P>But this really is not true -- and (for example) file names will never sort that way in Explorer. </P>
<P>The difference is between </P>
<P>&nbsp;&nbsp;&nbsp;AaBbCcDdEeFfGgHhIiJjKkLlMmNnOoPpQqRrSsTtUuVvWwXxYyZz </P>
<P>and</P>
<P>&nbsp;&nbsp;&nbsp;AabBcCDdeEfFgGHhIijJkKlLMmNnOopPqQRrSstTuUvVWwXxyYzZ</P>
<P>!</P>
<P>In other words, what we are talking about when it comes to comparisons and ignoring case, we are talking about IGNORING case and giving no deterministic order between items that only differ in case.</P>
<P>Other people (for example the Shell) just sort of implicitly assume that the way that they order files should use NORM_IGNORECASE since NTFS, FAT, and FAT32 all&nbsp;ignore case. </P>
<P>Though I am forced to point again to <STRONG><A href="http://archives.miloush.net/michkap/archive/2006/03/02/542395.html">this article</A></STRONG> to hopefully help people to realize that the argument is flawed. Or perhaps a moment to think about the difference between <STRONG><A href="http://archives.miloush.net/michkap/archive/2006/04/29/586726.html">'Which comes first?' vs. 'Are they equal?'</A></STRONG> will make it clearer. </P>
<P>The bottom line is that if one chooses to make the answer to an IDENTITY question a case-insensitive one, that in no way means that the question of ORDERING of items also needs to be made case insensitive. In fact, if they are being done as two separate operations than it is likely better if they are not done the same way at all. </P>
<P>So why not do two separate operations in two separate ways? :-)</P>
<P>Others argue that the performance is improved if there are less things to look for, though in practice this does not tend to be an issue. The reason for this is that case is never an issue unless two elements have identical primary weights (which is unusual in most situations), and if that happens then the "case winner" is stored, and <STRONG>subsequent case differences are ignored</STRONG>. Just like as if you passed the flag anyway.</P>
<P>The bottom line is that people actually do kind of like determinism, a certain way that patterns will behave in a consistent manner. And if you don't ignore case, things can be ordered a bit more deterministically!</P>
<P><EM><FONT size=2>Some of the wittier readers might think of the other ignore flags like NORM_IGNOREKANA and NORM_IGNOREWIDTH and realize that the same issues apply to them as well. But NORM_IGNORECASE is kind of special due to the confusion about filesystems and their case insensitivity and such.</FONT></EM></P>
<P>Now all of the above are referring to <A href="http://msdn.microsoft.com/library/en-us/winui/winui/windowsuserinterface/resources/strings/stringreference/stringfunctions/comparestring.asp">CompareString</A> and its managed analogues. I'll talk about where sort keys fit into this another time....</P>
<P>&nbsp;</P>
<P><FONT color=#ff1493><EM>This post brought to you by</EM> <STRONG><FONT size=6>ï¾˜</FONT></STRONG> <EM>(<A href="http://www.fileformat.info/info/unicode/char/ff98">U+ff98</A>, a.k.a. HALFWIDTH KATAKANA LETTER RI)</EM></FONT></P></FONT>
<hr/><p><a id="685841" href="#685841">#</a> <strong>Dean Harding</strong> on Tuesday, August 01, 2006 8:02 PM:</p><div style="margin-left: 1em">I suppose people get that misconception because they're used to strcmp vs. stricmp for example. Since they basically do an ordinal sort, vs. a lower-case-then-ordinal sort...</div>
<p><a id="686421" href="#686421">#</a> <strong>Adam</strong> on Wednesday, August 02, 2006 9:24 AM:</p><div style="margin-left: 1em">OK, I've read through the previous links, and I still don't get it.<br><br>From <a rel="nofollow" target="_new" href="http://archives.miloush.net/michkap/archive/2005/11/22/495033.html">http://blogs.msdn.com/michkap/archive/2005/11/22/495033.aspx</a><br><br>&quot;The world of the less lexicographic and more linguistic CompareString and mythical EqualString functions is a very different one. [...] This is hardest on CompareString where with those weights there are so many different levels of difference, with some levels trumping other levels. Therefore, any difference between the two strings is an interesting bit of trivia unless no greater difference is found later on. [...] And this is where the fictional EqualString function would have it easier -- because like its binary/ordinal cousins it would be able to return after any difference is found, of any weight.&quot;<br><br>If, _for a given collation_ (e.g. English, case insensitive), you're asking &quot;Which comes first?&quot; and &quot;Are they equal?&quot;, surely &quot;Are they equal?&quot; should return true _if and only if_ &quot;Which comes first?&quot; is &quot;neither&quot;.<br><br>How is it supposed to work otherwise? How are you defining identity for things that can be ordered, if not by how they are ordered?<br><br><br>And what is the difference between the two &quot;aa...zz&quot; strings you posted? If you're looking at them case-insensitively, surely they're identical? No?<br><br>/very confused.<br></div>
<p><a id="686486" href="#686486">#</a> <strong>Michael S. Kaplan</strong> on Wednesday, August 02, 2006 10:29 AM:</p><div style="margin-left: 1em">Hi Adam, <br><br>The primary issue is that there is never anything to lose in having a deterministic ordering that says that &quot;aa&quot; always comes before &quot;AA&quot;, even if they are in some context basically equal. And there is much to lose in having the behavior be random here -- having a consistent ordering is never a bad thing.</div>
<p><a id="686510" href="#686510">#</a> <strong>Adam</strong> on Wednesday, August 02, 2006 10:55 AM:</p><div style="margin-left: 1em">Whoa!<br><br>I thought you were trying to get at the difference being that although some things &quot;ordered the same&quot;, they might not be considered identical. i.e. &quot;AA&quot; and &quot;aa&quot; would return 0 from CompareString(), but EqualString() might return false. I mean, that almost kind of makes sense. They go &quot;in the same position in a list&quot;, but they're not &quot;exactly the same&quot;.<br><br>But you're saying instead that two things which are &quot;identical&quot; can have a well-defined order? But ... but ... but ... that's absurd!<br><br>OK, maybe not absurd. But ... things which are identical are indistinguishable from each other. That's the meaning of identity. Isn't it? How ...? Wha ...?<br><br>Even more confused! Brain ... melting ...<br><br>(Although the original post is now starting to make a bit more sense now I know which way round the equality/comparison disconnect you're talking about is.)</div>
<p><a id="686545" href="#686545">#</a> <strong>Michael S. Kaplan</strong> on Wednesday, August 02, 2006 11:30 AM:</p><div style="margin-left: 1em">Actually, what I am saying is that although you might consider two things to be equivalent, you still want their order to be fixed if they can appear to be a bit different.<br><br>Because a list like <br><br>AA<br>aa<br>aA<br>aA<br>Aa<br><br>looks much better as<br><br>aa<br>aA<br>aA<br>Aa<br>AA<br><br>and so on....</div>
<p><a id="686547" href="#686547">#</a> <strong>Adam</strong> on Wednesday, August 02, 2006 11:30 AM:</p><div style="margin-left: 1em">Also, would you be kind enough to give an example of lossage that might occur if the ordering of identical strings is not determined by their content?[0] I'm having a hard time thinking of one.<br><br><br>[0] I keep rereading that sentence and my brain keeps telling me there's an error in it. I'm pretty sure it's not spelling or grammar, and the warning from my brain is the kind I get when I've gone back to a post and edited half a sentence, but not updated the other half to match. I think it's just confused about what it thinks &quot;identity&quot; means/is supposed to mean. :-/<br></div>
<p><a id="686550" href="#686550">#</a> <strong>Michael S. Kaplan</strong> on Wednesday, August 02, 2006 11:34 AM:</p><div style="margin-left: 1em">Think of it is that if you order a list as if it were case sensitive, then you will consider all of these items to be almost identical, and they will sort NEAR each other.<br><br>When ordering a list, there is no need to lose these small distinctions. It is only when asking the generic question of &quot;ARE YOU EQUAL TO ____?&quot; that one might need to be less discriminating, based on specific rules....</div>
<p><a id="686554" href="#686554">#</a> <strong>Michael S. Kaplan</strong> on Wednesday, August 02, 2006 11:36 AM:</p><div style="margin-left: 1em">Adam -- <BR><BR>Also note that the same problem extended to the NORM_IGNORENOSPACE flag is the cause for <STRONG><A href="http://archives.miloush.net/michkap/archive/2004/11/30/272207.html">this</A></STRONG> (related) problem....</div>
<p><a id="686563" href="#686563">#</a> <strong>Adam</strong> on Wednesday, August 02, 2006 11:43 AM:</p><div style="margin-left: 1em">Hmmm....maybe. Although if I'd wanted some kind of &quot;fixed order&quot; when sorting a list with equal items, I'd likely have used a stable sort to maintain the original order of things that are equal. Except that a stable sort will no longer work with this behaviour. (Depending on your definition of &quot;work&quot;, of course)<br></div>
<p><a id="686581" href="#686581">#</a> <strong>Michael S. Kaplan</strong> on Wednesday, August 02, 2006 11:51 AM:</p><div style="margin-left: 1em">Well, a stable sort will only work if everything was in the right order in the first place -- and if items are added randomly, this will not be the case. <br><br>And as I showed in the Korean example in that link above, equal is not always what you want here -- esp. when you have over 100 characters that are &quot;equal&quot; in some sense....</div>
<p><a id="686629" href="#686629">#</a> <strong>Adam</strong> on Wednesday, August 02, 2006 12:32 PM:</p><div style="margin-left: 1em">So, and I think I've got this now, EqualString(), when &quot;ignoring case&quot;, _does_ ignore case, and will tell you if two strings _are_ equal to each other. However, this does not mean that CompareString() will say there is no difference between them because it doesn't _ignore_ case, it just does something different with it.<br><br>Hang on - in an English locale, &quot;A&quot; and &quot;a&quot; _are_ next to each other anyway, aren't they? Isn't the situation you describe just a case-*sensitive* sort in an English locale? So, what's the difference between ignoring case and not ignoring case in such a scenario? Isn't CompareString() just ignoring the ignore case flag?<br><br><br>Sorry - is there some kind of primer I should be reading to get all this? The posts you linked to (and the posts they linked to) have great insights on individual facets of this, but ... this feels like a book-length subject. Can you recommend one?<br></div>
<p><a id="686756" href="#686756">#</a> <strong>Michael S. Kaplan</strong> on Wednesday, August 02, 2006 3:05 PM:</p><div style="margin-left: 1em">I do not know of a book, but there is this blog. :-)</div>
<p><a id="686978" href="#686978">#</a> <strong>Adam</strong> on Wednesday, August 02, 2006 6:28 PM:</p><div style="margin-left: 1em">:-)<br><br>But I feel guilty about taking up your time with this. One or two questions seems &quot;reasonable&quot;. 5 or 6 seems intrusive, and makes me think that this must surely have been written down somewhere before.<br><br>But, if that comment can be taken as an invitation - my last question is really intriguing me now. What is the difference between the case-sensitive and case-insensitive versions of StringCompare() &nbsp;in an English locale?<br><br>An example - given the string &quot;ABABabab&quot;, I'd expect the following results from StringCompare() in an English locale:<br><br>&quot;en&quot; locale, case sensitive &quot;AAaaBBbb&quot; (stable)<br>&quot;en&quot; locale, case insensitive &quot;aAaABbbB&quot; (unstable)<br><br>For comparison with the old &quot;C&quot; locale:<br><br>&quot;C&quot; locale, codepoint sensitive: &quot;AABBaabb&quot; (stable)<br>&quot;C&quot; locale, case insensitive: &quot;AaaAbBbB&quot; (unstable)<br><br>However, you seem to claim (in your 11:30 post) that &quot;en, case insensitive&quot; should be the same as what I think &quot;en, case sensitive&quot; would be. So, what's the point in the case-sensitivity flag? What am I missing?<br></div>
<p><a id="687031" href="#687031">#</a> <strong>Michael S. Kaplan</strong> on Wednesday, August 02, 2006 7:22 PM:</p><div style="margin-left: 1em">I tell people when they are annoying me, you haven't hit that limit. :-)<br><br>Note that we sort the opposite way in Windows (lowercase first), other than that the difference is that either *a* and *A* have a specific order, or they do not. There is no in between.<br><br>(the stable/unstable issue is a separate one which has more to do with whether re-sorting the list one just sorted can change the order by flipping some of these &quot;identical&quot; entries)</div>
<p><a id="687037" href="#687037">#</a> <strong>Dean Harding</strong> on Wednesday, August 02, 2006 7:41 PM:</p><div style="margin-left: 1em">Adam: I think you're right. In case-insensitive, &quot;A&quot; and &quot;a&quot; will appear next to each other, but you don't know which one will come first. In case-sensitive, &quot;A&quot; and &quot;a&quot; still come next to each other, but &quot;a&quot; will always come before &quot;A&quot;.<br><br>In C-locale, the &quot;case-sensitive&quot; strcmp will sort &quot;a&quot; next to &quot;Z&quot; (or is it the other way around?)</div>
<p><a id="687040" href="#687040">#</a> <strong>Michael S. Kaplan</strong> on Wednesday, August 02, 2006 7:46 PM:</p><div style="margin-left: 1em">The other way around. :-)<br><br>ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz</div>
<p><a id="687336" href="#687336">#</a> <strong>Adam</strong> on Thursday, August 03, 2006 3:33 AM:</p><div style="margin-left: 1em">Dean - that was my point. If I've understood Michael correctly, in a case-insensitive comparison you _do_ know which will come first! The order is well-defined - leaving me to wonder what the NORM_IGNORECASE flag is for. What _does_ it do if there is apparently no difference between a case-sensitive and case-insensitive sort?<br></div>
<p><a id="687395" href="#687395">#</a> <strong>Michael S. Kaplan</strong> on Thursday, August 03, 2006 5:15 AM:</p><div style="margin-left: 1em">Hi Adam -- <br><br>I explain it quite literally in that first link -- NORM_IGNORECASE gives you no deterministic ordering between them. You simply do not know.<br><br>There is a clear difference between the two -- case sensitive is deterministic and case in-sensitive is random.</div>
<p><a id="687425" href="#687425">#</a> <strong>Adam</strong> on Thursday, August 03, 2006 6:50 AM:</p><div style="margin-left: 1em">Huh? Isn't that the opposite of what you said in your 10:30AM post?<br><br>So are you saying now that EqualString() _would_ return true if and only if CompareString() returns 0, if they were both passed the NORM_IGNORECASE flag? (Or they were both _not_ passed the flag?)<br><br>(Which is what I originally asked, but you said was not the case. Didn't you? Are we just going round in circles now?)<br></div>
<p><a id="687444" href="#687444">#</a> <strong>Michael S. Kaplan</strong> on Thursday, August 03, 2006 7:23 AM:</p><div style="margin-left: 1em">Actually, no -- I never said really anything about EqualString in the comments, since the function does not exist.<br><br>If you mean the post that gives the two different ways five strings might be ordererd, the first one has NORM_IGNORECASE passed; the second one does not have it passed.<br><br>What I have been saying in terms of a summary is:<br><br>DETERMINING ORDER -- do not pass the NORM_IGNORECASE flag<br><br>VERIFYING IDENTITY -- pass the NORM_IGNORECASE flag.<br><br>I never said the function would behave differently; I am saying that the caller should CALL them differently. And thus the the post title &quot;Sometimes, ignoring case is stupid.&quot;</div>
<p><a id="687496" href="#687496">#</a> <strong>Adam</strong> on Thursday, August 03, 2006 8:54 AM:</p><div style="margin-left: 1em">Ahhhhhhhhh............! That makes sense now!<br><br>Sorry - reading through the back articles, particularly the one I quoted in my first post, I got the impression that there was a fundamental difference between how order and identity is determined, due to an (probably incorrectly perceived by me) implication that EqualString() would be inherently faster than CompareString().<br><br>(I'm aware that EqualString() doesn't exist - hence &quot;would&quot; instead of &quot;does&quot; in my last post)<br><br>Right - yes - if you use different ordering criteria for determining identity than you do for actually ordering things, then yes, of course your definition of &quot;the same&quot; will be different in each case.<br><br><br>I'm still not sure *why* you'd use different collation criteria for determining identity and order, but now that I get what you're actually saying I at least have a chance of figuring that one out! :-)<br><br>Sorry for the misunderstanding.<br><br><br>(p.s. Is it just me, or does your 2005/11/22 post I originally linked to imply that the mythical EqualString() would be inherently faster than CompareString() given the same collation options?)<br></div>
<p><a id="687519" href="#687519">#</a> <strong>Michael S. Kaplan</strong> on Thursday, August 03, 2006 9:36 AM:</p><div style="margin-left: 1em">EqualString would be faster, as the question it answers takes less effort. :-) <br><br>For the real example of why you would want the two operations different, see that Korean post I linked to -- people consider the behasvior to be broken if you *don't* make the two operations separate.....</div>
<hr/><p><em>referenced by</em></p><div style="margin-left: 1em"><p>2011/05/10 <a href="http://archives.miloush.net/michkap/archive/2011/05/10/10162158.html">On Compare â‰  Equals, and the Relevance of both</a></p></div><p><em>go to <a id="newer" href="http://archives.miloush.net/michkap/archive/2006/08/02/686384.html" title="Hang on just a [Hansel]Minute!">newer</a> or <a id="older" href="http://archives.miloush.net/michkap/archive/2006/08/01/684909.html" title="32 bit vs. 64 bit HKLs?">older</a> post, or back to <a href="http://archives.miloush.net/michkap/archive/index.html">index</a> or <a href="http://archives.miloush.net/michkap/archive/index.html#2006-08">month</a> or <a href="http://archives.miloush.net/michkap/archive/index.html#2006-08-01">day</a></em></p></body>
<!-- Mirrored from archives.miloush.net/michkap/archive/2006/08/01/685351.html by HTTrack Website Copier/3.x [XR&CO'2014], Thu, 25 May 2017 00:42:39 GMT -->
</html>