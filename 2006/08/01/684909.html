<html>
<!-- Mirrored from archives.miloush.net/michkap/archive/2006/08/01/684909.html by HTTrack Website Copier/3.x [XR&CO'2014], Thu, 25 May 2017 00:42:39 GMT -->
<head><meta charset="utf-8" /><meta name="viewport" content="width=device-width" /><title>32 bit vs. 64 bit HKLs?</title></head><body>
<h1>32 bit vs. 64 bit HKLs?</h1>
<p><em>by Michael S. Kaplan, published on 2006/08/01 03:05 -04:00, original URI: http://blogs.msdn.com/b/michkap/archive/2006/08/01/684909.aspx</em></p>
<hr/> <!-- Archival Source: ProcessPostNew -->
<FONT face=Tahoma>
<P>The question from Josh went something like this: </P>
<BLOCKQUOTE dir=ltr style="MARGIN-RIGHT: 0px">
<BLOCKQUOTE dir=ltr style="MARGIN-RIGHT: 0px">
<P><FONT face="Times New Roman" size=2>The 64 bit version of ToUnicodeEx is apparently sensitive to the high-order DWORD of the HKL parameter. I noticed this with the Turkish F keyboard which has an HKL of 0xfffffffff014041f in a 64-bit process. Attempting to send 0x00000000f014041f into ToUnicodeEx results in an empty string returned.</FONT></P>
<P><FONT face="Times New Roman" size=2>My problem is that I have HKLs coming to me from both 32 and 64 bit applications, and I need to know what I should be doing to turn the 32-bit HKL into the equivalent 64-bit HKL. It looks like the high order DWORD on a 64-bit HKL is only ever 0 or MAXDWORD, but it isn’t clear to me when it should be one vs. the other.</FONT></P></BLOCKQUOTE></BLOCKQUOTE>
<P>We ended up with&nbsp;a theory (though I was initially thinking of it more like a bug, to be honest), but the theory was one&nbsp;that Hiro confirmed a couple of days later. </P>
<P>Does anyone reading this know what is going on here? Or why I was thinking of it more as a bug? Or what other KLID values like the MSKLC-generated ones like "A0000409" might produce in the way of the HKLs on 64-bit in this case?</P>
<P>&nbsp;</P>
<P><FONT color=#ff1493><EM>This post brought to you by</EM> <FONT face="Microsoft Himalaya" size=8>ཇ</FONT> <EM>(<A href="http://www.fileformat.info/info/unicode/char/0f47">U+0f47</A>, a.k.a. TIBETAN LETTER JA)</EM></FONT></P></FONT>
<hr/><p><a id="685007" href="#685007">#</a> <strong>SDiZ</strong> on 1 Aug 2006 4:08 AM:</p><div style="margin-left: 1em">Sign-extended?<br>I would treat that as a bug.</div>
<p><a id="685162" href="#685162">#</a> <strong>Igor Tandetnik</strong> on 1 Aug 2006 7:46 AM:</p><div style="margin-left: 1em">I believe it's by design. See<br><br><a rel="nofollow" target="_new" href="http://msdn.microsoft.com/library/en-us/dnmidl/html/midl64b.asp">http://msdn.microsoft.com/library/en-us/dnmidl/html/midl64b.asp</a><br><br>&quot;USER and GDI handles are sign extended 32b values&quot; section.</div>
<p><a id="685265" href="#685265">#</a> <strong>Michael S. Kaplan</strong> on 1 Aug 2006 10:24 AM:</p><div style="margin-left: 1em">Hi Igor, <br><br>Heh, you stole my thunder on the explanatory text. :-) <br><br>It is indeed by design. Though speaking personally, I would have done it a bit differently had it been up to me (obviously it wasn't!).</div>
<p><a id="685274" href="#685274">#</a> <strong>Michael S. Kaplan</strong> on 1 Aug 2006 10:29 AM:</p><div style="margin-left: 1em">From the link: <BR><BR>-------------------------------------- <BR><STRONG>USER and GDI handles are sign extended 32b values</STRONG> <BR>To facilitate the porting, a decision has been made that these system handles should stay as 32b values, sign extended to 64b on the 64b platform. That is, the individual handle types are still based on the HANDLE type, which maps to void *, and so the size of the handle is the size of the pointer, i.e. 4 bytes on 32b and 8 bytes on 64b. However, the actual value of the handle on the 64b platform, (i.e. the meaningful bits), fits within the lower 32b, while the upper bits just carry the sign. <BR><BR>This should make it easy to port the majority of the application code. Handling of the special values, like –1, should be fairly transparent. It also should agree nicely with all the cases where the handles had been remoted with the help of the IDL definitions from the public file wtypes.idl. However, care needs to be taken when remoting the handles was done via a DWORD, as the upper long should be properly sign extended on the 64b side. The app should use HandleToLong() and LongToHandle() macros (inline functions) to do the casting right. <BR><BR>So, in general we can have the following situations: <BR><BR>A handle like HWND, HMENU, HPALETTE, HBITMAP etc was sent as its own type (that is specified with HMENU, etc. as the type of the argument) – do nothing, ole32.dll code handles situation as appropriate <BR>A handle was sent as a DWORD – you can: <BR>leave it as such and cast the wire value to handle using LongToHandle() <BR>change the argument to long or LONG_PTR; this is possible in some cases only, <BR>When designing a new interface, in order of preference: use the types themselves, use context handles or use a LONG64 argument to hack through. <BR>Going back to specifics of porting the legacy code, the following system handles fall into the nice 32b compatible category. <BR><BR>The USER handles: HWND, HMENU, HICON, HCURSOR, HDWP, HHOOK, HACCEL, HWINSTA, HDESK, HKL, HMONITOR, HWINEVENTHOOK. <BR><BR>The GDI handles: HBITMAP, HPALETTE, HMETAFILE, HENHMETAFILE, HMETAFILEPICT, HBRUSH, HFONT, HDC, HRGN .<BR>--------------------------------------</div>
<p><a id="685378" href="#685378">#</a> <strong>Mihai</strong> on 1 Aug 2006 12:19 PM:</p><div style="margin-left: 1em">Ok, is clear this is cause by signed extension.<br>But I think is a bug, because the doc sais:<br>&quot;The low word contains a Language Identifier for the input language and the high word contains a device handle to the physical layout of the keyboard&quot;<br><br>Another theory is that the ffff is not because of the sign, but because is Turkish F keyboard.<br>For the Turkish Q keyboard it will be 0xqqqqqqqqf014041f :-)<br></div>
<p><a id="685445" href="#685445">#</a> <strong>Michael S. Kaplan</strong> on 1 Aug 2006 1:38 PM:</p><div style="margin-left: 1em">Well, that part is a doc bug, at least. :-)<br><br>It is clear that you have to convert it from a signed 64bit pointer to a signed 32bit pointer prior to doing the operations on the HKL if you need to do any....</div>
<hr/><p><em>referenced by</em></p><div style="margin-left: 1em"><p>2010/05/04 <a href="http://archives.miloush.net/michkap/archive/2010/05/04/10003033.html">The wacky world of WOW64 keyoards, un-leashed, un-locked, un-something-or-other</a></p><p>2008/09/29 <a href="http://archives.miloush.net/michkap/archive/2008/09/29/8968315.html">What a tangled web we weave when a KLID from an HKL we must receive</a></p><p>2006/08/07 <a href="http://archives.miloush.net/michkap/archive/2006/08/07/690989.html">Fixing a bug in the documentation</a></p></div><p><em>go to <a id="newer" href="http://archives.miloush.net/michkap/archive/2006/08/01/685351.html" title="Sometimes, ignoring case is stupid">newer</a> or <a id="older" href="http://archives.miloush.net/michkap/archive/2006/07/31/684908.html" title="What is it about an autograph?">older</a> post, or back to <a href="http://archives.miloush.net/michkap/archive/index.html">index</a> or <a href="http://archives.miloush.net/michkap/archive/index.html#2006-08">month</a> or <a href="http://archives.miloush.net/michkap/archive/index.html#2006-08-01">day</a></em></p></body>
<!-- Mirrored from archives.miloush.net/michkap/archive/2006/08/01/684909.html by HTTrack Website Copier/3.x [XR&CO'2014], Thu, 25 May 2017 00:42:39 GMT -->
</html>