<html>
<!-- Mirrored from archives.miloush.net/michkap/archive/2006/02/02/523189.html by HTTrack Website Copier/3.x [XR&CO'2014], Thu, 25 May 2017 00:42:40 GMT -->
<head><meta charset="utf-8" /><meta name="viewport" content="width=device-width" /><title>Another interview question</title></head><body>
<h1>Another interview question</h1>
<p><em>by Michael S. Kaplan, published on 2006/02/02 07:14 -08:00, original URI: http://blogs.msdn.com/michkap/archive/2006/02/02/523189.aspx</em></p>
<hr/> <!-- Archival Source: ProcessPostOld -->
<p><font face=Tahoma>Earlier today, in response to my post <a HREF="http://archives.miloush.net/michkap/archive/2006/02/02/522919.html"><strong>What is equal to some may not be equal to others</strong></a>, Christian Kaiser <a HREF="http://archives.miloush.net/michkap/archive/2006/02/02/522919.html#522990">asked me</a>:</font></p>
<blockquote dir=ltr style="MARGIN-RIGHT: 0px">
<p><font face="Times New Roman" size=2><em>Do you see a faster way to do a string comparison than to use CompareString(), just like NOTEPAD's programmer's idea, but correct?</em></font></p></blockquote>
<p><font face=Tahoma>It is a very interesting question, especially in light of the fact that this issue is being addressed in Windows Vista. So I thought I would open it up as one of those "interview questions" I ask from time to time.</font></p>
<p><font face=Tahoma>I will temporarily moderate all responses so no one gives it a way too soon. I can't offer the best response a job, but we are still hiring so if someone wanted an interview I could offer to try to start someone through the process of contacting HR, etc.... :-)</font></p>
<p><font face=Tahoma>Ok, on your mark, get set, go!</font></p>
<hr/><p><a id="523218" href="#523218">#</a> <strong>Jeff Parker</strong> on Thursday, February 02, 2006 10:46 AM:</p><div style="margin-left: 1em">Hmm, the only thing that comes to mind right away is creating some dynamic regular expression to do the comparison. You can get really creative on regular expresions.</div>
<p><a id="523226" href="#523226">#</a> <strong>Michael S. Kaplan</strong> on Thursday, February 02, 2006 11:03 AM:</p><div style="margin-left: 1em">Ok, sounds like a fair high level description -- though it is unclear how such a thing would be constructed..... more info needed, Jeff!</div>
<p><a id="523242" href="#523242">#</a> <strong>Maurits</strong> on Thursday, February 02, 2006 11:28 AM:</p><div style="margin-left: 1em">A faster way than CompareString()??  In general, no, or else CompareString would just *use* the faster way.  It sure would be nice if we could see the source to CompareString, to see how what we're trying to beat works.<br/><br/>But if you're going for speed...<br/><br/>Hmmm... given strings s1 and s2....<br/><br/>First, compare the pointers (s1 == s2 or ReferenceEquals) to see if they point to the same string.  This is a cheap check, and if you get lucky, that's all you have to do.  Some string storage libraries actually go out of their way to share memory for strings with significant overlap, so this may actually work.<br/><br/>Likewise, memcmp the byte arrays pointed to by s1 and s2.  This is also relatively cheap of a check (though not as cheap as s1==s2), and if you get lucky, that's all you have to do.  If you have a cheap way to check the lengths of the arrays, and they don't match, you can skip this check. (If the lengths are different, the strings could STILL be equal due to ligature unfolding and zero-width-joiners and that sort of thing.)<br/><br/>Beyond that you have to walk the strings and do equivalence lookups and case mappings and ligature expansions (shudder) which is best handled by CompareString(), no?<br/><br/>Worst-case this is slightly slower than CompareString(), but best-case this is MUCH faster.</div>
<p><a id="523248" href="#523248">#</a> <strong>Maurits</strong> on Thursday, February 02, 2006 11:34 AM:</p><div style="margin-left: 1em">Hey what happened to my line breaks?  OK, future posts will use "\n" to signify a line break.\n\n<br/>Like that.\n</div>
<p><a id="523250" href="#523250">#</a> <strong>Michael S. Kaplan</strong> on Thursday, February 02, 2006 11:35 AM:</p><div style="margin-left: 1em">Heh -- I am not really expecting a faster way that CompareString -- but a way that gives the same linguistic functionality while supporfting the find/replace semantic is the goal, I suppose.... :-)<br/><br/>The trouble is of course knowing how to do the comparison itself.... wihout requiring an impossible number of them, right?</div>
<p><a id="523276" href="#523276">#</a> <strong>Maurits</strong> on Thursday, February 02, 2006 12:08 PM:</p><div style="margin-left: 1em">Oh, I see... the question is, given a text string t and a search phrase s, find the first occurence of s in t.  But in such a way that Unicode normalization is respected.\n<br/>\n<br/>The naive way of course is to do something like<br/>int firstoccurenceof<br/>for (i = 0; i &lt; s.length; i++)\n<br/>{\n<br/>\tfor (j = 0; j &lt; s.length - i; j++)\n<br/>\t{\n<br/>\t\tif (CompareString(substring(s, i, j), t, ...) == CSTR_EQUAL)\n<br/>\t\t{\n<br/>\t\t\treturn i;\n<br/>\t\t}\n<br/>\t}\n<br/>}\n<br/>\n<br/>but this takes O(nn) CompareString calls, which take on average O(nm) time each... resulting in an unacceptable O(mnnn) overall execution time.  YUCK.\n<br/>\n<br/>One solution is probably to normalize both s and t first, then do\n<br/>\n<br/>for (i = 0; i &lt; s.length - t.length + 1; i++)\n<br/>{\n<br/>\tif (CompareString(substring(s, i, t.length), t, ...) == CSTR_EQUAL)\n<br/>\t{\n<br/>\t\treturn i;\n<br/>\t}\n<br/>}\n<br/>\n<br/>This takes a much better O(n) CompareString calls, each of which takes O(mn) time for an overal O(mnn) time.\n<br/>\n<br/>Care would need to be taken to map the &quot;i&quot; returned by this function to where-it-belongs-in-the-original-string.\n<br/>\n<br/>Consider a string like &quot;formul&#230;&quot; - if someone searches this for &quot;e&quot;, it should succeed... but what to do with the success?</div>
<p><a id="523279" href="#523279">#</a> <strong>Maurits</strong> on Thursday, February 02, 2006 12:09 PM:</p><div style="margin-left: 1em">Oh, reverse the meanings of &quot;s&quot; and &quot;t&quot; in the code samples.  s = &quot;formul&#230;&quot; (normalized to &quot;formulae&quot;) and t = &quot;e&quot;</div>
<p><a id="523281" href="#523281">#</a> <strong>Maurits</strong> on Thursday, February 02, 2006 12:10 PM:</p><div style="margin-left: 1em">Oh, and the improved algorithm takes a much better O(n) CompareString calls, each of which takes O(mm) time for an overal O(mmn) time.</div>
<p><a id="523306" href="#523306">#</a> <strong>Maurits</strong> on Thursday, February 02, 2006 12:28 PM:</p><div style="margin-left: 1em">Someday I'll learn to count.  CompareString() takes O(n + m) time, not O(nm) time.  (Technically O(max(n, m)) time, but that's the same as O(n + m))<br/><br/>So the first algorithm with O(mn) calls of O(m + n) each takes O(mmn + mnn) time.  For small values of m this is O(nn).  For m and n about equal this is O(nnn).<br/><br/>The second algorithm with O(n - m) calls of O(m) each takes O(mn - mm).  For small values of m this is O(n).  For m and n about equal this is O(n)!<br/><br/>Not every day you can go from an O(nnn) algorithm to an O(n) algorithm.</div>
<p><a id="523349" href="#523349">#</a> <strong>Michael S. Kaplan</strong> on Thursday, February 02, 2006 1:10 PM:</p><div style="margin-left: 1em">There is also that issue with compressions, and expansions, neither of which can be normalized out....<br/><br/>Though if neither string has expansions (or if you use FoldString to expand the ligatures), and if the local in question has no compressions, then this should do.<br/><br/>(if only those weren't such big ifs!)</div>
<p><a id="523371" href="#523371">#</a> <strong>Maurits</strong> on Thursday, February 02, 2006 1:28 PM:</p><div style="margin-left: 1em">What are compressions and expansions?  You mean things like æ => ae, and å (one code point) => å (two code points?)<br/><br/>My intention was to expand these out in both strings, prior to doing the search (as part of "normalization", which is perhaps not the best term to have used!)<br/><br/>The details get a little fuzzy though, because I need to be able to reverse-map found indexes to the original string, and it's not so obvious to me how that should best be done.<br/><br/>So in pseudocode:<br/>sExpanded = expand(s)<br/>tExpanded = expand(t)<br/>iExpanded = find(sExpanded, tExpanded) // tExpanded is at position i in sExpanded<br/>i = some_magic_happens_here(iExpanded, sExpanded, s)<br/><br/>find() is implemented as above...<br/>for some_magic_happens_here, I think I would have to walk both s and sExpanded, keeping in sync, until I had gone i steps along sExpanded.  Then i is wherever-I-happen-to-be in s.<br/><br/>This will probably going a character at a time in s, and eating larger and larger bits of sExpanded until they're no longer equal (by CompareString's standards.)<br/><br/>When I get to where I need to be in sExpanded, I return where I am in s, and hey-presto, that's the beginning of the selection.<br/><br/>Returning the end of the selection involves similar magic.</div>
<p><a id="523385" href="#523385">#</a> <strong>Maurits</strong> on Thursday, February 02, 2006 1:37 PM:</p><div style="margin-left: 1em">All right, what's with the line breaks?  I don't see a pattern.</div>
<p><a id="523386" href="#523386">#</a> <strong>Michael S. Kaplan</strong> on Thursday, February 02, 2006 1:37 PM:</p><div style="margin-left: 1em">The expansions are indeed like that -- we have a table of them, and it is exposed through FoldString (though locale specific diferences are not, which is a problem for things like Icelandic -- muh harder to keep track of where you are in the string!).<br/><br/>Compressions are also things like ch in Spanish or dzs in Hungarian -- I have called these &quot;sort elements&quot; as they are treated like a single letter for collation purposes. So it is not just the canonical equivalence cases, which canas you mention be normalized out....</div>
<p><a id="523389" href="#523389">#</a> <strong>Michael S. Kaplan</strong> on Thursday, February 02, 2006 1:38 PM:</p><div style="margin-left: 1em">The official issue with line breaks is one for which I have determined the pattern.<br/><br/>I will post about it later today. :-)</div>
<p><a id="523404" href="#523404">#</a> <strong>Maurits</strong> on Thursday, February 02, 2006 1:55 PM:</p><div style="margin-left: 1em">Oh, I see... let me see if I understand the user expectation in a reasonable fashion.<br/><br/>So a search for &quot;es&quot; should succed in &#198;sop (though what the selection would look like is a harder question) because &#198; expands to AE.<br/><br/>But a search for &quot;hi&quot; should fail in Chile (in a Spanish locale) because Ch is a unit, and cannot be broken up.<br/><br/>So I need to modify the algorithm to check if I'm in the middle of a sort element while stepping through s, and if I am, skip CompareString calls.<br/><br/>Also I need to make sure t doesn't end in the middle of a sort element (in s.)  So a search for &quot;uc&quot; should also fail in &quot;chaucha&quot;<br/><br/>Or maybe that's pushing the bounds of user expectations?</div>
<p><a id="523412" href="#523412">#</a> <strong>Maurits</strong> on Thursday, February 02, 2006 2:10 PM:</p><div style="margin-left: 1em">No, I can't go along with that.  I think user expectation is that &quot;uc&quot; should succeed in &quot;chaucha&quot;, and &quot;es&quot; should succeed in &#198;sop, and I might even go so far as to suggest that &quot;se&quot; should succeed in gr&#252;&#223;en.<br/><br/>Simply ignoring sort elements should Just Work (TM), no?</div>
<p><a id="523425" href="#523425">#</a> <strong>Maurits</strong> on Thursday, February 02, 2006 2:23 PM:</p><div style="margin-left: 1em">... by which I mean, as long as I'm careful not to step over the &quot;h&quot; in Chile, it shouldn't matter that &quot;Ch&quot; is a sort element as far as CompareString is concerned... because CompareString will treat &quot;Ch&quot; as a sort element equally in both strings, and when I'm checking the &quot;h&quot; part it won't see the &quot;c&quot;.</div>
<p><a id="523471" href="#523471">#</a> <strong>Michael S. Kaplan</strong> on Thursday, February 02, 2006 3:16 PM:</p><div style="margin-left: 1em">Some of those things do not work as users MIGHT expect *today*, though -- expectations here are unclear.<br/><br/>cf: <a rel="nofollow" target="_new" href="http://archives.miloush.net/michkap/archive/2005/03/11/394359.html">http://blogs.msdn.com/michkap/archive/2005/03/11/394359.aspx</a><br/>cf: <a rel="nofollow" target="_new" href="http://archives.miloush.net/michkap/archive/2006/01/23/515987.html">http://blogs.msdn.com/michkap/archive/2006/01/23/515987.aspx</a><br/><br/>It makes expected &quot;find&quot; semantics more difficult to contemplate sometimes. :-)</div>
<p><a id="523541" href="#523541">#</a> <strong>Maurits</strong> on Thursday, February 02, 2006 4:27 PM:</p><div style="margin-left: 1em">As an interviewee, then, I would propose making the sort element behavior an option...<br/><br/>Match fractional sort elements ON:<br/>isin(uc, chaucha) = true<br/>isin(z, dzs) = true<br/>isin(ch, chaucha) = true<br/>isin(dzs, dzs) = true<br/><br/>Match fractional sort elements OFF:<br/>isin(uc, chaucha) = false<br/>isin(z, dzs) = false<br/>isin(ch, chaucha) = true<br/>isin(dzs, dzs) = true<br/><br/>... and then proceed to demonstrate the implementation of both options.</div>
<p><a id="523680" href="#523680">#</a> <strong>Robert</strong> on Thursday, February 02, 2006 7:52 PM:</p><div style="margin-left: 1em">Some time ago I implemented a FindString function which in most cases takes only O(n) time (around 1.5*n CompareString calls most of which return immediately). In the end I didn't use it because I wasn't sure whether the relevant statement in the CompareString documentation can be relied on in a strict sense: "If the two strings are of different lengths, they are compared up to the length of the shortest one. If they are equal to that point, then the return value will indicate that the longer string is greater."
More specifically, the function fails for TCHAR strings that are lexically before any of their substrings (from the beginning). For example, when looking for "á" = {U+00E1}, the function will not find the "á" = {U+0061, U+0301} representation, if it sorts before "a" = {U+0061} in the specified locale. In other words: The function assumes that CompareString(lcid, flags, string, m, string, n never returns CSTR_GREATER_THAN if m <= n and the strings agree in the first m TCHARs.

LPTSTR FindString(    // Return value: pointer to matched substring of text, or null pointer
    LCID Locale,      // locale identifier for CompareString
    DWORD dwCmpFlags, // CompareString flags
	LPCTSTR text,     // text to be searched
	int ltext,        // number of TCHARs in text, or negative number if null terminated
	LPCTSTR str,      // string to look for
	int lstr,         // number of TCHARs in string, or negative number if null terminated
	int *lsubstr      // pointer to int that receives the number of TCHARs in the substring
)
{
    int i, j;         // start/end index of substring being analyzed

    i = 0;
    // for i=0..end, compare text.SubString(i, end) with str
    do {
        switch (CompareString(Locale, dwCmpFlags, &text[i],
            ltext < 0 ? ltext : ltext-i, str, lstr))
        {
            case 0:
                return 0;
            case CSTR_LESS_THAN:
                continue;
        }
        j = i;
        // if greater: for j=i..end, compare text.SubString(i, j) with str
        do {
            switch (CompareString(Locale, dwCmpFlags, &text[i],
                j-i, str, lstr))
            {
                case 0:
                    return 0;
                case CSTR_LESS_THAN:
                    continue;
                case CSTR_EQUAL:
                    if (lsubstr) *lsubstr = j-i;
                    return (LPTSTR)&text[i];
            }
            // if greater: break to outer loop
            break;
        } while (ltext < 0 ? text[j++] : j++ < ltext);
    } while (ltext < 0 ? text[i++] : i++ < ltext);

    SetLastError(ERROR_SUCCESS);
    return 0;
}</div>
<p><a id="523692" href="#523692">#</a> <strong>Michael S. Kaplan</strong> on Thursday, February 02, 2006 8:05 PM:</p><div style="margin-left: 1em">The docs about string length are actually wrong, sorry!<br/><br/>Your function, slightly more readable:<br/><br/>LPTSTR FindString( // Return value: pointer to matched substring of text, or null pointer <br/>LCID Locale, // locale identifier for CompareString <br/>DWORD dwCmpFlags, // CompareString flags <br/>LPCTSTR text, // text to be searched <br/>int ltext, // number of TCHARs in text, or negative number if null terminated <br/>LPCTSTR str, // string to look for <br/>int lstr, // number of TCHARs in string, or negative number if null terminated <br/>int *lsubstr // pointer to int that receives the number of TCHARs in the substring <br/>) <br/>{ <br/>int i, j; // start/end index of substring being analyzed <br/><br/>i = 0; <br/>// for i=0..end, compare text.SubString(i, end) with str <br/>do { <br/>switch (CompareString(Locale, dwCmpFlags, &amp;text[i], <br/>ltext &lt; 0 ? ltext : ltext-i, str, lstr)) <br/>{ <br/>case 0: <br/>return 0; <br/>case CSTR_LESS_THAN: <br/>continue; <br/>} <br/>j = i; <br/>// if greater: for j=i..end, compare text.SubString(i, j) with str <br/>do { <br/>switch (CompareString(Locale, dwCmpFlags, &amp;text[i], <br/>j-i, str, lstr)) <br/>{ <br/>case 0: <br/>return 0; <br/>case CSTR_LESS_THAN: <br/>continue; <br/>case CSTR_EQUAL: <br/>if (lsubstr) *lsubstr = j-i; <br/>return (LPTSTR)&amp;text[i]; <br/>} <br/>// if greater: break to outer loop <br/>break; <br/>} while (ltext &lt; 0 ? text[j++] : j++ &lt; ltext); <br/>} while (ltext &lt; 0 ? text[i++] : i++ &lt; ltext); <br/><br/>SetLastError(ERROR_SUCCESS); <br/>return 0; <br/>} <br/></div>
<p><a id="523694" href="#523694">#</a> <strong>Ben</strong> on Thursday, February 02, 2006 8:10 PM:</p><div style="margin-left: 1em">Robert:  You are right that CompareString makes it hard to tell if something is a prefix.  That's why they created FindNLSString() for Vista.  The FIND_STARTWITH flag implements prefix matching correctly.</div>
<p><a id="523805" href="#523805">#</a> <strong>Michael S. Kaplan</strong> on Thursday, February 02, 2006 11:49 PM:</p><div style="margin-left: 1em">Ben, that is very true -- and this is one of those operations that is much easier on the inside of the function than the outside! :-)</div>
<p><a id="523923" href="#523923">#</a> <strong>Eric</strong> on Friday, February 03, 2006 4:40 AM:</p><div style="margin-left: 1em">I have to dissapoint you, Maurits. Ch is no longe a valid letter in the Spanish alphabet. It used to be, but 10 years ago (or something like that, I have really bad memory) they decided to split them apart. So if you are looking for "hi" in "Chile", it should find it (with starting index 1).<br/>Same goes to the rest of our (ex) double consonants ("ll" and "rr").</div>
<p><a id="524015" href="#524015">#</a> <strong>Michael S. Kaplan</strong> on Friday, February 03, 2006 7:58 AM:</p><div style="margin-left: 1em">Hi Eric --<br/><br/>It is true that unless you use the 'traditional spansh' LCID that ch and the others will not be compressions. But Windows handles this correctly and it is easier to understand the concept with examples.... :-)</div>
<p><a id="524087" href="#524087">#</a> <strong>Petr Kadlec</strong> on Friday, February 03, 2006 10:19 AM:</p><div style="margin-left: 1em">Eric+Maurits: If you are looking for another example, we still have Ch as a single digraph in Czech, and I hope we won't dicard it anytime soon. ;-)</div>
<p><a id="524126" href="#524126">#</a> <strong>Maurits</strong> on Friday, February 03, 2006 11:10 AM:</p><div style="margin-left: 1em">Is Cz a compression in Czech too?</div>
<p><a id="524178" href="#524178">#</a> <strong>Maurits</strong> on Friday, February 03, 2006 12:10 PM:</p><div style="margin-left: 1em">(posting this again as the first attempt met with an error, and was not visible after re-visiting the thread)<br/><br/>To answer my own question... no, it isn't...<br/><br/>Wikipedia has a list of potential digraphs and trigraphs, from which many Hungarian compressions are conspicuously absent:<br/><br/><a rel="nofollow" target="_new" href="http://en.wikipedia.org/wiki/Digraph_(orthography)">http://en.wikipedia.org/wiki/Digraph_%28orthography%29</a><br/><a rel="nofollow" target="_new" href="http://en.wikipedia.org/wiki/Trigraph_(orthography)">http://en.wikipedia.org/wiki/Trigraph_%28orthography%29</a><br/><br/>The &quot;schtschj&quot; octograph (German equivalent for Russian щь) is also mentioned, but perhaps with tongue slightly in cheek :)</div>
<p><a id="526037" href="#526037">#</a> <strong>Maurits</strong> on Monday, February 06, 2006 4:53 PM:</p><div style="margin-left: 1em">Alright, I'm beginning to see the &quot;don't match partial compressions&quot; side of the argument.</div>
<hr/><p><em>referenced by</em></p><div style="margin-left: 1em"><p>2006/07/15 <a href="http://archives.miloush.net/michkap/archive/2006/07/15/666717.html">How long is that non-Unicode string?</a></p></div><p><em>go to <a id="newer" href="http://archives.miloush.net/michkap/archive/2006/02/03/524026.html" title="Explaining the problem with comments on the blog">newer</a> or <a id="older" href="http://archives.miloush.net/michkap/archive/2006/02/02/522919.html" title="What is equal to some may not be equal to others">older</a> post, or back to <a href="http://archives.miloush.net/michkap/archive/index.html">index</a> or <a href="http://archives.miloush.net/michkap/archive/index.html#2006-02">month</a> or <a href="http://archives.miloush.net/michkap/archive/index.html#2006-02-02">day</a></em></p></body>
<!-- Mirrored from archives.miloush.net/michkap/archive/2006/02/02/523189.html by HTTrack Website Copier/3.x [XR&CO'2014], Thu, 25 May 2017 00:42:40 GMT -->
</html>