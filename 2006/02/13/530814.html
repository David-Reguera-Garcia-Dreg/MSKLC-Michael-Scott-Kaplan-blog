<html>
<!-- Mirrored from archives.miloush.net/michkap/archive/2006/02/13/530814.html by HTTrack Website Copier/3.x [XR&CO'2014], Thu, 25 May 2017 00:42:40 GMT -->
<head><meta charset="utf-8" /><meta name="viewport" content="width=device-width" /><title>Getting all of the localized names of a font</title></head><body>
<h1>Getting all of the localized names of a font</h1>
<p><em>by Michael S. Kaplan, published on 2006/02/13 06:31 -05:00, original URI: http://blogs.msdn.com/b/michkap/archive/2006/02/13/530814.aspx</em></p>
<hr/> <!-- Archival Source: ProcessPostNew -->
<P><FONT face=Tahoma><A href="http://greggman.com/">Greg Tavares</A> asked in the Suggestion Box:</FONT></P>
<BLOCKQUOTE dir=ltr style="MARGIN-RIGHT: 0px">
<P><EM><FONT face="Times New Roman" size=2>I am desparately trying to figure out how to get both the English names of fonts AND the localized names through the Win32 API. </FONT></EM></P>
<P><EM><FONT face="Times New Roman" size=2>I'm on Japanese Windows XP. &nbsp;I call EnumFontFamiliesEx. &nbsp;By default I get the localized font names. &nbsp;I also want the English names. &nbsp;I tried calling SetThreadLocale() as well as _wsetlocale() before calling EnumFontFamiliesEx but neither seemed to have any effect. </FONT></EM></P>
<P><EM><FONT face="Times New Roman" size=2>Could you please pass me a clue? &nbsp;I'd be forever in your debt.</FONT></EM></P></BLOCKQUOTE>
<P><FONT face=Tahoma>Keep in mind that I did mention previously in <A href="http://archives.miloush.net/michkap/archive/2005/02/26/380867.html"><STRONG>East Asian Font Names</STRONG></A> that both the English names and the localized ones would work (keeping in mind the limitations I pointed out in <STRONG><A href="http://archives.miloush.net/michkap/archive/2005/12/12/502463.html">Ready... Set... Reboot Redux</A></STRONG>, of course!).</FONT></P>
<P><FONT face=Tahoma>But there really is no Win32 API function to retrieve all of those names, unfortunately. Which means you are a little stuck here, unless you dig into the <A href="http://www.microsoft.com/typography/otspec/">OpenType Specification</A>, of course....</FONT></P>
<P><FONT face=Tahoma>Now I have never really done very much with the OpenType format (with the exception of a port of the code in <A href="http://support.microsoft.com/kb/241358/">MS Knowledge&nbsp;Base article 241358</A> for MSLU's GetGlyphOutlineW wrapper),&nbsp;so I decided to dig in and see how much work it would be. Here follows the code I put together, it should qualify as a very strong clue (though of course you won't be in my debt, Greg. This was fun!).</FONT></P>
<P><FONT face=Tahoma>If there are people who know more about fonts out there (just about anyone in typography, I would imagine!) who want to point out my most blatant errors, I would be happy. :-)</FONT></P>
<P><FONT face=Tahoma size=2><EM>(Disclaimer: I looked at no internal information and no external samples to write this, and I did it all in a few hours when I probably should have been sleeping; you could almost certainly do better from alternate sources of information!)</EM></FONT></P>
<BLOCKQUOTE dir=ltr style="MARGIN-RIGHT: 0px">
<P><FONT face=Tahoma><FONT face="Courier New"><FONT size=2><STRONG>#define _UNICODE<BR>#define UNICODE<BR>#include &lt;stdio.h&gt;<BR>#include &lt;windows.h&gt;</STRONG></FONT></FONT></FONT></P>
<P><FONT face=Tahoma><FONT face="Courier New"><FONT size=2><STRONG>struct NAMERECORD {<BR>&nbsp; USHORT platformID;<BR>&nbsp; USHORT encodingID;<BR>&nbsp; USHORT languageID;<BR>&nbsp; USHORT nameID;<BR>&nbsp; USHORT length;<BR>&nbsp; USHORT offset;<BR>};</STRONG></FONT></FONT></FONT></P>
<P><FONT face=Tahoma><FONT face="Courier New"><FONT size=2><STRONG>#define SWAPBYTES(w)&nbsp; ( ((USHORT)((w)[0]) &lt;&lt; 8) | (w)[1])</STRONG></FONT></FONT></FONT></P>
<P><FONT face=Tahoma><FONT face="Courier New"><FONT size=2><STRONG>void main() {<BR>&nbsp; CHOOSEFONT cf = {0}; <BR>&nbsp; LOGFONT lf; <BR>&nbsp; HFONT hfont; <BR>&nbsp;<BR>&nbsp; cf.lStructSize = sizeof(CHOOSEFONT); <BR>&nbsp; cf.lpLogFont = &amp;lf; <BR>&nbsp; cf.Flags = CF_SCREENFONTS | CF_TTONLY | CF_NOSCRIPTSEL;&nbsp;<BR>&nbsp; cf.nFontType = SCREEN_FONTTYPE; <BR>&nbsp;<BR>&nbsp; ChooseFont(&amp;cf); <BR>&nbsp; <BR>&nbsp; hfont = CreateFontIndirect(cf.lpLogFont); <BR>&nbsp; if(hfont) {<BR>&nbsp;&nbsp;&nbsp; HDC hdc = ::CreateDC(L"Display", NULL, NULL, NULL);<BR>&nbsp;&nbsp;&nbsp; if(hdc) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; HFONT hfontOld = (HFONT)::SelectObject(hdc, hfont);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if(hfontOld) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DWORD dw;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; dw = ::GetFontData(hdc, 'eman', 0, NULL, 0);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if(dw != GDI_ERROR) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; LPBYTE lpv = (BYTE *)malloc(dw);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; UINT offset = 0;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if(lpv) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; dw = ::GetFontData(hdc, 'eman', 0, lpv, dw);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if(dw != GDI_ERROR) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; USHORT format, count, stringOffset;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; NAMERECORD * rgNR;</STRONG></FONT></FONT></FONT></P>
<P><FONT face=Tahoma><FONT face="Courier New"><FONT size=2><STRONG>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; format = SWAPBYTES(&amp;lpv[offset]);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; offset += sizeof(USHORT);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; count = SWAPBYTES(&amp;lpv[offset]);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; offset += sizeof(USHORT);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; stringOffset = SWAPBYTES(&amp;lpv[offset]);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; offset += sizeof(USHORT);</STRONG></FONT></FONT></FONT></P>
<P><FONT face=Tahoma><FONT face="Courier New"><FONT size=2><STRONG>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rgNR = (struct NAMERECORD *)calloc(count, sizeof(NAMERECORD));</STRONG></FONT></FONT></FONT></P>
<P><FONT face=Tahoma><FONT face="Courier New"><FONT size=2><STRONG>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for(int i = 0; i &lt; count; i++) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rgNR[i].platformID = SWAPBYTES(&amp;lpv[offset]);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;offset += sizeof(USHORT);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rgNR[i].encodingID = SWAPBYTES(&amp;lpv[offset]);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;offset += sizeof(USHORT);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rgNR[i].languageID = SWAPBYTES(&amp;lpv[offset]);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;offset += sizeof(USHORT);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rgNR[i].nameID&nbsp;&nbsp; = SWAPBYTES(&amp;lpv[offset]);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;offset += sizeof(USHORT);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rgNR[i].length&nbsp;&nbsp; = SWAPBYTES(&amp;lpv[offset]);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;offset += sizeof(USHORT);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rgNR[i].offset&nbsp;&nbsp; = SWAPBYTES(&amp;lpv[offset]);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;offset += sizeof(USHORT);</STRONG></FONT></FONT></FONT></P>
<P><FONT face=Tahoma><FONT face="Courier New"><FONT size=2><STRONG>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // The name string is at<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // lpv + stringOffset + rgNR[i].offset<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // The name string length is rgNR[i].length</STRONG></FONT></FONT></FONT></P>
<P><FONT face=Tahoma><FONT face="Courier New"><FONT size=2><STRONG>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // The bytes in both cases must each be run<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //&nbsp;through something like the SWAPBYTES macro<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // because all font information is big endian<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// regardless of endian-ness of the platform).</STRONG></FONT></FONT></FONT></P>
<P><FONT face=Tahoma><FONT face="Courier New"><FONT size=2><STRONG>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // <BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // INSERT CODE TO DO SOMETHING WITH&nbsp;NAMES HERE<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //&nbsp;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; free(rgNR);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; free(lpv);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ::SelectObject(hdc, hfontOld);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ::DeleteDC(hdc);<BR>&nbsp;&nbsp;&nbsp; }<BR>&nbsp;&nbsp;&nbsp; ::DeleteObject(hfont);<BR>&nbsp; }<BR>}</STRONG></FONT></FONT></FONT><FONT face=Tahoma><FONT face="Courier New"></P></BLOCKQUOTE>
<P><FONT face=Tahoma>For meanings of the platform IDs, encoding IDs, language IDs, and name IDs, see The <A href="http://www.microsoft.com/typography/otspec/">OpenType Specification's</A> page about <A href="http://www.microsoft.com/typography/otspec/name.htm">the Naming Table</A>.</FONT></P>
<P><FONT face=Tahoma>The localized version(s) of these strings can be&nbsp;found by looking for the appropriate language ID.</FONT></P></FONT></FONT>
<P><FONT face=Tahoma>I was not tempted to write an EnumFontFamilesExEx, at least not enough to actually write it. But by picking the right name ID etc. it should be possible for the very ambitious.... :-)</FONT></P>
<P><FONT face=Tahoma></FONT>&nbsp;</P>
<P><FONT face=Tahoma color=#ff1493><EM>This post brought to you by</EM> "<FONT size=6>ゴ</FONT>" <EM>(<A href="http://www.fileformat.info/info/unicode/char/30b4">U+30b4</A>, a.k.a. KATAKANA LETTER GO)<FONT size=1><BR></FONT><FONT size=2>(The first letter in ゴシック, a.k.a. Gothic, used by the MS Gothic (ＭＳ ゴシック) font)</FONT></EM></FONT></P>
<hr/><p><strong>Joe</strong> on 29 May 2009 2:58 AM:</p><div style="margin-left: 1em"><p>How can we get the PostScript name of a font, if we have only the Windows menu name of the font? Is there any way to &nbsp;get it using win32 API? </p></div>
<hr/><p><em>referenced by</em></p><div style="margin-left: 1em"><p>2011/09/13 <a href="http://archives.miloush.net/michkap/archive/2011/09/13/10209739.html">"It was an honest mistake -- I'm not running NT4; I'm just in Hong Kong!"</a></p><p>2008/07/11 <a href="http://archives.miloush.net/michkap/archive/2008/07/11/8720555.html">On installing and removing fonts, Part 4: The easiest part is the addition!</a></p><p>2008/07/03 <a href="http://archives.miloush.net/michkap/archive/2008/07/03/8682763.html">On installing and removing fonts, Part 1: Do I know you, or some version of you at least?</a></p><p>2008/07/01 <a href="http://archives.miloush.net/michkap/archive/2008/07/01/8674304.html">Is that character in the font or isn't it?</a></p><p>2007/09/24 <a href="http://archives.miloush.net/michkap/archive/2007/09/24/5082103.html">Documented, schmockumented! It's still kind of cool....</a></p><p>2007/07/07 <a href="http://archives.miloush.net/michkap/archive/2007/07/07/3746794.html">TTC indexes, the easy way...</a></p><p>2007/06/22 <a href="http://archives.miloush.net/michkap/archive/2007/06/22/3452969.html">TTC indexes, the hard way...</a></p><p>2007/03/26 <a href="http://archives.miloush.net/michkap/archive/2007/03/26/1952689.html">Hello, Mr. TrueType Font. Do you support Bengali?</a></p><p>2007/01/22 <a href="http://archives.miloush.net/michkap/archive/2007/01/22/1505420.html">Getting all of the localized names of a font[.NET]</a></p><p>2006/10/21 <a href="http://archives.miloush.net/michkap/archive/2006/10/21/852382.html">Is Font.FontFamily localized?</a></p></div><p><em>go to <a id="newer" href="http://archives.miloush.net/michkap/archive/2006/02/13/531110.html" title="Don&#39;t change the font, dammit!">newer</a> or <a id="older" href="http://archives.miloush.net/michkap/archive/2006/02/12/530658.html" title="x is like a box of chocolates....">older</a> post, or back to <a href="http://archives.miloush.net/michkap/archive/index.html">index</a> or <a href="http://archives.miloush.net/michkap/archive/index.html#2006-02">month</a> or <a href="http://archives.miloush.net/michkap/archive/index.html#2006-02-13">day</a></em></p></body>
<!-- Mirrored from archives.miloush.net/michkap/archive/2006/02/13/530814.html by HTTrack Website Copier/3.x [XR&CO'2014], Thu, 25 May 2017 00:42:40 GMT -->
</html>