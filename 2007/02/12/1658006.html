<html>
<!-- Mirrored from archives.miloush.net/michkap/archive/2007/02/12/1658006.html by HTTrack Website Copier/3.x [XR&CO'2014], Thu, 25 May 2017 00:42:38 GMT -->
<head><meta charset="utf-8" /><meta name="viewport" content="width=device-width" /><title>What's wrong with this code?</title></head><body>
<h1>What's wrong with this code?</h1>
<p><em>by Michael S. Kaplan, published on 2007/02/12 03:01 -05:00, original URI: http://blogs.msdn.com/b/michkap/archive/2007/02/12/1658006.aspx</em></p>
<hr/> <!-- Archival Source: ProcessPostNew -->
<P>Ok, another one of those 'what's wrong with this code?' posts, for your coding pleasure....</P>
<P>I won't even say what the code is supposed to do, but it should be fairly obvious what is being attempted (unsuccessfully) here, on&nbsp;several levels:</P>
<BLOCKQUOTE>
<BLOCKQUOTE><FONT face="Consolas,Lucida Console,Courier New,Courier" size=2><B>
<P>private static string VirtualCodeToString(int virtualCode, uint scanCode) {<BR>&nbsp;&nbsp;&nbsp; string resultingString = string.Empty;<BR>&nbsp;&nbsp;&nbsp; byte[] keyboardState = new byte[256];<BR><BR>&nbsp;&nbsp;&nbsp; NativeMethods.GetKeyboardState(keyboardState);<BR><BR>&nbsp;&nbsp;&nbsp; IntPtr foregroundWindow = NativeMethods.GetForegroundWindow();<BR>&nbsp;&nbsp;&nbsp; uint processId;<BR>&nbsp;&nbsp;&nbsp; uint threadId = NativeMethods.GetWindowThreadProcessId(foregroundWindow, out processId);<BR>&nbsp;&nbsp;&nbsp; StringBuilder actualKeyBuffer = new StringBuilder(2);<BR>&nbsp;&nbsp;&nbsp; int retVal = NativeMethods.ToUnicodeEx(<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (uint)virtualCode,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; scanCode,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; keyboardState,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; actualKeyBuffer,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 2,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; NativeMethods.GetKeyboardLayout(threadId));<BR><BR>&nbsp;&nbsp;&nbsp; if (retVal == 1) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; actualKeyBuffer.Length = 1;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; resultingString = actualKeyBuffer.ToString();<BR>&nbsp;&nbsp;&nbsp; }<BR><BR>&nbsp;&nbsp;&nbsp; return resultingString;<BR>}<BR><BR>[DllImport("user32.dll")]<BR>internal static extern bool GetKeyboardState(byte[] lpKeyState);<BR><BR>[DllImport("user32.dll")]<BR>internal static extern IntPtr GetForegroundWindow();<BR><BR>[DllImport("user32.dll")]<BR>internal static extern uint GetWindowThreadProcessId(IntPtr hWnd, out uint lpdwProcessId);<BR><BR>[DllImport("user32.dll")]<BR>internal static extern int ToUnicodeEx(uint wVirtKey,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; uint wScanCode,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; byte[] lpKeyState,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; [MarshalAs(UnmanagedType.LPWStr)] StringBuilder pwszBuff,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int cchBuff,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; uint wFlags,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; IntPtr dwhkl);</P></B></FONT></BLOCKQUOTE></BLOCKQUOTE>
<P>The one hint I will give is that the actual code one would need to accomplish what this code is trying to do is&nbsp;pretty complex, if you want to cover all&nbsp;supported scenarios. So&nbsp;I am not asking anyone to try to write the full. correct code here. I am mainly looking for people to point out the bad practices and&nbsp;flaws as if one was reviewing this code either on any version of Windows or on any non-Win9x based version (your choice!). </P>
<P>I might do the full correct version of the code in a future post, if there is interest and if I can get over my fear of supporting a budding&nbsp;industry of keyloggers. :-)</P>
<P>Okay? Ready, set, go!</P>
<P mce_keep="true">&nbsp;</P>
<P mce_keep="true"><FONT color=#ff00ff><EM>This post brought to you by</EM>&nbsp;<FONT size=5>Ã©</FONT> <EM>(<A class="" href="http://www.fileformat.info/info/unicode/char/00e9" mce_href="http://www.fileformat.info/info/unicode/char/00e9">U+00e9</A>, a.k.a. LATIN SMALL LETTER E WITH ACUTE)</EM></FONT></P>
<hr/><p><strong>Michael S. Kaplan</strong> on 12 Feb 2007 12:06 PM:</p><div style="margin-left: 1em"><p>Several people guessing via the contact link, but no one feels comfortable leaving their guesses in a comment yet. </p>
<p>Interesting....</p>
</div>
<p><strong>Mihai</strong> on 12 Feb 2007 12:22 PM:</p><div style="margin-left: 1em"><p>Trying to get a character from the info available normally in a WM_KEYDOWN message (virtual-key code, and scan code).</p>
<p>There are many ways for this to fail, the main ones being lack of &quot;historical info&quot; (was a dead-key pressed before?) and IMEs.</p></div>
<p><strong>Michael S. Kaplan</strong> on 12 Feb 2007 1:02 PM:</p><div style="margin-left: 1em"><p>Ok, good start... now what else is going to be a problem here? :-)</p>
</div>
<p><strong>Mihai</strong> on 12 Feb 2007 1:26 PM:</p><div style="margin-left: 1em"><p>There are so many problems, I don't even know which one do you want to single out :-)</p>
<p>Here is round two:</p>
<p>1. The keyboard state is a &quot;per task&quot; thing.</p>
<p>So the code calls GetKeyboardState to retrieve the keyboard state of the current thread, then uses it using the GetKeyboardLayout of another thread.</p>
<p>2. ToUnicodeEx can return more than 2 characters, so the buffer is too small.</p>
<p>3. The buffer filled by ToUnicodeEx is might be non-null terminated. Doc: &quot;However, this buffer may be returned without being null-terminated even though the variable name suggests that it is null-terminated.&quot;</p>
<p>4. The return -1 from ToUnicodeEx is not treated. From the doc &quot;If possible, even with Unicode keyboard layouts, the function has written a spacing version of the dead-key character to the buffer specified by pwszBuff.&quot;</p></div>
<p><strong>Michael S. Kaplan</strong> on 12 Feb 2007 2:54 PM:</p><div style="margin-left: 1em"><p>These are also good, though the exact consequences of #1 are also worthy of some discussion, as well as what one might want to think of doing with the issue in #4.</p>
</div>
<p><strong>Jon</strong> on 16 Feb 2007 2:28 PM:</p><div style="margin-left: 1em"><p>The worst problem: if you call this in a subclass procedure when processing WM_KEYDOWN (which is only reasonable), with an international key which is a dead char and is obtained with AltGr (Ctrl+Alt), such as the Swedish '~' key, this will screw up the dead char state.</p>
<p>For this not to happen, you need to call ToUnicode() twice (!!).</p>
<p>Yes, I know, ToUnicode() is not suppose to know about the deadchar state - well, not only it knows it, but it changes it. I've been just debugging my keyboard handling code (I sell a vi/vim emulator for Visual Studio, SQL Server, Word and Outlook) because a poor fellow Swedish programmer couldn't write any more destructors, and tracked it down to this, on XP SP2.</p>
<p>Ah, how I hate the windows input model :) I wrote a blog post about this a while ago, titled &quot;What's broken in the WM_KEYDOWN/WM_CHAR input model&quot;, which is #2 on Google both for WM_CHAR and WM_KEYDOWN (don't ask me why):</p>
<p> &nbsp;<a rel="nofollow" target="_new" href="http://blog.ngedit.com/2005/06/13/whats-broken-in-the-wm_keydownwm_char-input-model/">http://blog.ngedit.com/2005/06/13/whats-broken-in-the-wm_keydownwm_char-input-model/</a></p>
<p>Exercise for the reader: write code to determine, when receiving a WM_KEYDOWN or WM_SYSKEYDOWN, whether this will be accompanied by a WM_CHAR afterwards or not. It seems simple, doesn't it? This is necessary if you want to provide reliable user-configurable remapping of all keypresses that doesn't depend on timers.</p>
<p>Believe me, this is the start of the road to hell. On US keyboards, it's only &quot;very complex&quot;. If you add intl keyboards into the mix, you will suffer without limits, and end up discovering the dirty secrets of ToUnicode() and much more...</p>
<p>I'm preparing another article called &quot;The Ultimate WM_CHAR/WM_KEYDOWN Chart from Hell&quot;, I'm sure it will be very popular. And maybe I can get that spot #1 before MSDN on both keywords.</p>
<p>Michael, congratulations on a great blog and a lot of useful info. Great that someone at Microsoft cares about the stuff, but I must say it certainly seems you are one of a very few.</p></div>
<hr/><p><em>go to <a id="newer" href="http://archives.miloush.net/michkap/archive/2007/02/13/1670097.html" title="What&#39;s wrong with the Ukrainian keyboard layout, anyway?">newer</a> or <a id="older" href="http://archives.miloush.net/michkap/archive/2007/02/11/1657463.html" title="MSKLC can&#39;t do everything, even in the 1.4 version">older</a> post, or back to <a href="http://archives.miloush.net/michkap/archive/index.html">index</a> or <a href="http://archives.miloush.net/michkap/archive/index.html#2007-02">month</a> or <a href="http://archives.miloush.net/michkap/archive/index.html#2007-02-12">day</a></em></p></body>
<!-- Mirrored from archives.miloush.net/michkap/archive/2007/02/12/1658006.html by HTTrack Website Copier/3.x [XR&CO'2014], Thu, 25 May 2017 00:42:38 GMT -->
</html>