<html>
<!-- Mirrored from archives.miloush.net/michkap/archive/2007/03/25/1948887.html by HTTrack Website Copier/3.x [XR&CO'2014], Thu, 25 May 2017 00:42:38 GMT -->
<head><meta charset="utf-8" /><meta name="viewport" content="width=device-width" /><title>What's the problem with MapVirtualKey[Ex], on CE and otherwise?</title></head><body>
<h1>What's the problem with MapVirtualKey[Ex], on CE and otherwise?</h1>
<p><em>by Michael S. Kaplan, published on 2007/03/25 19:32 -04:00, original URI: http://blogs.msdn.com/b/michkap/archive/2007/03/25/1948887.aspx</em></p>
<hr/> <!-- Archival Source: ProcessPostNew -->
<p>Also over in the microsoft.public.win32.programmer.international newsgroup, Norman Diamond (who is clearly doing a lot of stuff with CE these days!) asked:</p> <blockquote> <p><em><font face="Times New Roman">In Windows Mobile 5 (Windows CE 5), when calling MapVirtualKey with the second parameter set to 2,<br></font></em><a href="http://msdn2.microsoft.com/en-us/library/ms911789.aspx"><em><font face="Times New Roman">http://msdn2.microsoft.com/en-us/library/ms911789.aspx</font></em></a><br><font face="Times New Roman"><em>says:<br><br></em>*&nbsp; uCode is a virtual-key code and is translated into an unshifted character<br>*&nbsp; value in the low-order word of the return value. Dead keys (diacritics)<br>*&nbsp; are indicated by setting the top bit of the return value. If there is no<br>*&nbsp; translation, the function returns 0.<br><br><em>The fact is that when uCode is virtual-key code 0x27 (VK_RIGHT), MapVirtualKey doesn't return 0, it returns 0x27.<br><br>So even my programming to produce a reverse translation table (since Windows CE lacks the misnamed VkScanEx API) gets screwed, and applications that use it get screwed.<br><br>Although I'm reading MSDN in English, most of the target environments are other foreign languages and the character code to VK code mapping is not constant.&nbsp; I need the correct table.&nbsp; How can I compute it?</em></font></p></blockquote> <p>Well, it has been&nbsp;many years since I have done any CE programming at all (the last time is when I was working as a contract PM in CE Services, over six years ago!).&nbsp;But I'll speak of the things I know of, and then make some informed guesses as to the rest.... :-)</p> <p>First, there is the piece of this doc that is a bug -- even in <a href="http://msdn2.microsoft.com/library/ms646306.aspx">the non-CE case</a>.</p> <p>The claim they always make is that for one of the mappings, "<i>uCode</i> is a virtual-key code and is translated into an unshifted character value in the low-order word of the return value."</p> <p>Well, perhaps I am on drugs for thinking of this, but for me the definition of an <strong>unshifted character</strong> in this context is <em>the character that is produced when you hit the key without any of the shift keys</em>.</p> <p>Beyond that, in a quick test here:</p> <blockquote><b><font face="Consolas,Lucida Console,Courier New,Courier"> <p>using System;<br>using System.Runtime.InteropServices; <br><br>namespace Testing {<br>&nbsp;&nbsp;&nbsp; class MappingIsScrewy {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; [DllImport("user32.dll", CharSet=CharSet.Unicode, ExactSpelling=true)]<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; internal static extern IntPtr LoadKeyboardLayoutW(string pwszKLID, uint Flags);&nbsp;<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; [DllImport("user32.dll", ExactSpelling=true)]<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; internal static extern bool UnloadKeyboardLayout(IntPtr dwhkl);&nbsp;<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; [DllImport("user32.dll", CharSet=CharSet.Unicode, ExactSpelling=true)]<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; internal static extern uint MapVirtualKeyExW(uint uCode, uint uMapType, IntPtr dwhkl);&nbsp;<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; [STAThread]<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; static void Main(string[] args) {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; IntPtr hkl = LoadKeyboardLayoutW("00000419", 0);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Console.WriteLine(hkl.ToString("x8"));<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Console.WriteLine(MapVirtualKeyExW(0x41, 2, hkl).ToString("x8"));<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Console.WriteLine(MapVirtualKeyExW(0x27, 2, hkl).ToString("x8"));<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Console.WriteLine(UnloadKeyboardLayout(hkl));<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>&nbsp;&nbsp;&nbsp; }<br>}</p></font></b></blockquote> <p>The console output of this code will be:</p> <blockquote><b><font face="Consolas,Lucida Console,Courier New,Courier"> <p>04190419<br>00000041<br>00000000<br>True</p></font></b></blockquote> <p>This is&nbsp;an uppercase letter being returned on that second line. And an uppercase A (<a href="http://www.fileformat.info/info/unicode/char/0041">U+0041</a>), no less, when VK_A (0x41) is passed. Even though the Russian keyboard actually puts a <a href="http://www.fileformat.info/info/unicode/char/0444">U+0444</a> (CYRILLIC SMALL LETTER EF) at VK_A.</p> <p>Thus&nbsp;<a href="http://msdn2.microsoft.com/library/ms646306.aspx">MapVirtualKey</a> and <a href="http://msdn2.microsoft.com/library/ms646307.aspx">MapVirtualKeyEx</a> both will return the uppercase character on Windows, and furthermore even if you call <a href="http://msdn2.microsoft.com/library/ms646307.aspx">MapVirtualKeyEx</a> with the HKL of a non-English keyboard, the uppercase "A" is still being returned.&nbsp;</p> <p>Which probably just means the VK is being returned. This does seem to limit the usefulness of <a href="http://msdn2.microsoft.com/library/ms646307.aspx">MapVirtualKeyEx</a>.</p> <p><a href="http://www.microsoft.com/globaldev/tools/msklc.mspx">MSKLC</a> never ran across a problem here as it only used mapping type 3 -- <code>MAPVK_VSC_TO_VK_EX</code>, not mapping type 2 -- <code>MAPVK_VK_TO_CHAR</code>. The more useful function for us was always&nbsp;<a href="http://msdn2.microsoft.com/library/ms646322.aspx">ToUnicodeEx</a>, since the tool is only ever interested in the actual character (including the shift state when applicable). It also understands properly the notion of "unshifted character". :-)</p> <p>Oh well, at least on Windows if the VK does not map to a character, it will not even return the VK; the function will return 0.</p> <p>On the other hand, according to Norman on CE it will not even do that. :-(</p> <p>I guess that means if you to get the right character information (on ANY platform), use <a href="http://msdn2.microsoft.com/library/ms646322.aspx">ToUnicodeEx</a>&nbsp;and friends instead. Those mapping functions are a whole lot better at the SC &lt;--&gt; VK type mappings....</p> <p>&nbsp;</p> <p><font color="#ff0080"><em>This post brought to you by</em> Ñ„ <em>(<a href="http://www.fileformat.info/info/unicode/char/0444">U+0444</a>, a.k.a. CYRILLIC SMALL LETTER EF)</em></font></p>
<hr/><p><a id="1951013" href="#1951013">#</a> <strong>Mike Dimmick</strong> on 26 Mar 2007 4:58 AM:</p><div style="margin-left: 1em"><p>I don't know whether Norman's trying to do what I needed to, but here goes: when implementing a DOS(-like) emulator on CE, I needed to know, when a key was pressed, *both* the virtual key code *and* the character produced by that key. WM_KEYDOWN doesn't tell you the character code, and WM_CHAR doesn't tell you the virtual key code (and doesn't even occur if there is no printable character).</p>
<p>So I made a horrible hack: my message pump already calls TranslateMessage (which as we all know queues a WM_CHAR/WM_SYSCHAR message if the current message is WM_KEYDOWN). Therefore, in my WM_KEYDOWN handler I call PeekMessage, filtering for WM_CHAR sent to the same window. If it occurs, I assume that this character corresponds to the virtual key in the WM_KEYDOWN message. This has worked very reliably so far. I can see it will have trouble if another thread posts WM_CHAR messages rather than using SendInput but I've not seen a problem so far, and that includes using the Remote Display Control to remotely operate the device.</p>
</div>
<p><a id="1951034" href="#1951034">#</a> <strong>Michael S. Kaplan</strong> on 26 Mar 2007 5:04 AM:</p><div style="margin-left: 1em"><p>Yikes!</p>
<p>I'd probably prefer using ToUnicodeEx to get the character data out, rather than that TranslateMessage call. A lot less that can possibly go wrong, all things considered -- and a lot easier top fix up the buffer if there are dead keys to worry about....</p>
</div>
<p><a id="1955391" href="#1955391">#</a> <strong>Mike Dimmick</strong> on 26 Mar 2007 5:59 PM:</p><div style="margin-left: 1em"><p>CE does not have ToUnicode[Ex]. Sadly.</p>
<p>The design of Windows CE was originally to drop anything and everything that duplicated some other piece of functionality. In the case of conflicts, normally the simpler thing was dropped. So instead of LineTo and MoveToEx, we only had Polyline (or at least originally - looks like they were added in CE 4.0!) This is my favourite example because the .NET Compact Framework team also dropped duplicated functionality, except that they tended to select only the simplest method, so Graphics.DrawLine *was* present in CF 1.0 but Graphics.DrawLines *wasn't*. That meant that if you actually needed to draw multiple line segments you had to make multiple DrawLine calls, which in turn were calling Polyline, each of which resulted in a cross-process call to GDI, which meant that performance sucked.</p>
<p>[Ahem. Rant over.]</p>
<p>I admit I hadn't considered dead keys, but then we're generally porting software from the pseudo-US-keyboard Symbol Series 3000 to English (US) Windows CE devices so the problem shouldn't arise.</p>
</div>
<p><a id="3034519" href="#3034519">#</a> <strong>Sam</strong> on 1 Jun 2007 10:52 PM:</p><div style="margin-left: 1em"><p>I used ToUnicode in my application, but </p></div>
<hr/><p><em>go to <a id="newer" href="http://archives.miloush.net/michkap/archive/2007/03/25/1949369.html" title="Somebody turned 50 this weekend!">newer</a> or <a id="older" href="http://archives.miloush.net/michkap/archive/2007/03/25/1945659.html" title="Will the real Unicode character message please stand up?">older</a> post, or back to <a href="http://archives.miloush.net/michkap/archive/index.html">index</a> or <a href="http://archives.miloush.net/michkap/archive/index.html#2007-03">month</a> or <a href="http://archives.miloush.net/michkap/archive/index.html#2007-03-25">day</a></em></p></body>
<!-- Mirrored from archives.miloush.net/michkap/archive/2007/03/25/1948887.html by HTTrack Website Copier/3.x [XR&CO'2014], Thu, 25 May 2017 00:42:38 GMT -->
</html>