<html>
<!-- Mirrored from archives.miloush.net/michkap/archive/2007/01/15/1469885.html by HTTrack Website Copier/3.x [XR&CO'2014], Thu, 25 May 2017 00:42:38 GMT -->
<head><meta charset="utf-8" /><meta name="viewport" content="width=device-width" /><title>With SQL Server (and SQL itself) comes the illogic of 'trailing spaces' (and the myth of fixed width)</title></head><body>
<h1>With SQL Server (and SQL itself) comes the illogic of 'trailing spaces' (and the myth of fixed width)</h1>
<p><em>by Michael S. Kaplan, published on 2007/01/15 06:01 -05:00, original URI: http://blogs.msdn.com/b/michkap/archive/2007/01/15/1469885.aspx</em></p>
<hr/> <!-- Archival Source: ProcessPostNew -->
<P>There is a problem with the notion of both trailing spaces and fixed width in SQL Server,&nbsp;when you are using Windows collations.</P>
<P>I bring this up since I have a meeting this week where people will be talking about what are the differences between what Windows provides in comparisons and what SQL Server needs. And it is easiest when one is going into a meeting to discuss to technical issues if one understand the underlying technical information behind&nbsp;people's requirements.... :-)</P>
<P>In theory (if you are a regular reader here) you might even know what the problem is. Because even though I have never talked about it, I have talked about all of the underlying pieces that can lead one to understanding that there is indeed a problem.</P>
<P>Now the theory&nbsp;behind the trailing space behavior is actually based on a wider behavior in the SQL standard that goes beyond Microsoft SQL Server, and it is mainly there to help defined behavior of&nbsp;comparisons between CHAR and VARCHAR (or between NCHAR and NVARCHAR). Since CHAR/NCHAR is presumed to have a fixed length, in theory any comparison between CHAR//NCHAR columns of the same length are supposed to be "easier" due to that fixed length that they share.</P>
<P>But with Windows-based collations, it is the language-independent <STRONG>text elements</STRONG> and the language-dependent <STRONG>sort elements</STRONG> (both discussed previously in posts like <STRONG><A class="" href="http://archives.miloush.net/michkap/archive/2005/07/19/440320.html" mce_href="http://archives.miloush.net/michkap/archive/2005/07/19/440320.html">this one</A></STRONG> and <STRONG><A class="" href="http://archives.miloush.net/michkap/archive/2005/07/20/440842.html" mce_href="http://archives.miloush.net/michkap/archive/2005/07/20/440842.html">this one</A></STRONG>) that help to make up the actual elements that are compared. For our purpose let's assume that sort elements contain the set of all text elements and extend them with language specific behavior....</P>
<P>Thus on all collations <A class="" href="http://www.fileformat.info/info/unicode/char/00e5" mce_href="http://www.fileformat.info/info/unicode/char/00e5">U+00e5</A> (å, LATIN SMALL LETTER A WITH RING ABOVE) is equal to <A class="" href="http://www.fileformat.info/info/unicode/char/0061" mce_href="http://www.fileformat.info/info/unicode/char/0061">U+0061</A> <A class="" href="http://www.fileformat.info/info/unicode/char/030a" mce_href="http://www.fileformat.info/info/unicode/char/030a">U+030a</A> (å, a.k.a. LATIN SMALL LETTER A + COMBINING RING ABOVE), even though they are not same length. This is a Unicode equivalence that is should always be true.</P>
<P>And on some but not all collations <A class="" href="http://www.fileformat.info/info/unicode/char/00c6" mce_href="http://www.fileformat.info/info/unicode/char/00c6">U+00c6</A> (Æ, a.k.a. LATIN CAPITAL LETTER AE) is treated as equal to <A class="" href="http://www.fileformat.info/info/unicode/char/0041" mce_href="http://www.fileformat.info/info/unicode/char/0041">U+0041</A> <A class="" href="http://www.fileformat.info/info/unicode/char/0045" mce_href="http://www.fileformat.info/info/unicode/char/0045">U+0045</A> (AE, a.k.a. LATIN CAPITAL LETTER A + LATIN CAPITAL LETTER E), even though they are not the same length. This is not a Unicode equivalence but one defined in individual collations (in this example most of them).</P>
<P><EM>(for the most part text elements only refer to Unicode columns, but sort elements refer to both Unicode and non-Unicode comparisons....)</EM></P>
<P>And since neither SQL Server nor the SQL Standard defines the notion of either text elements or sort elements, the whole conversation about comparisons between fixed length text columns is meaningless in the context of using&nbsp;Windows collations, which are based on the notion of comparing unique sort elements.</P>
<P>Thus the only thing that the weird and hard to define/explain behavior of trailing spaces and how they affect comparisons in SQL Server provide is a source of confusion and bugs, rather than a defined way for a collation function to perhaps behave.</P>
<P>As weird as the behavior I mentioned <STRONG><A class="" href="http://archives.miloush.net/michkap/archive/2006/11/27/1160195.html" mce_href="http://archives.miloush.net/michkap/archive/2006/11/27/1160195.html">here</A></STRONG>, if not significantly weirder. And probably behind a lot of issues like the one Brian Gonsalves mentioned in <STRONG><A class="" href="http://archives.miloush.net/michkap/archive/2006/10/04/788429.html#1226915" mce_href="http://archives.miloush.net/michkap/archive/2006/10/04/788429.html#1226915">this comment</A></STRONG>.</P>
<P>Does that mean that SQL Server needs a new set of text data types whose maximums involve sort elements? </P>
<P>Such a data type seems to really not be necessary or even useful -- the behavior of VARCHAR and NVARCHAR with the length based on the underlying storage seems more meaningful here, and turning off the whole trailing spaces behavior seems more sensible anyway.</P>
<P>To me at least.</P>
<P>In the end, people&nbsp;are going to have an uphill battle trying to describe the requirements behind anything other than padding strings with spaces themselves prior to calling a function like <A class="" href="http://msdn.microsoft.com/library/en-us/winui/winui/windowsuserinterface/resources/strings/stringreference/stringfunctions/comparestring.asp" mce_href="http://msdn.microsoft.com/library/en-us/winui/winui/windowsuserinterface/resources/strings/stringreference/stringfunctions/comparestring.asp">CompareString</A>. Particularly&nbsp;needing&nbsp;new flags&nbsp;for special/different behavior for "trailing spaces". Since&nbsp;such behavior&nbsp;make no sense whatsoever from a collation perspective anyway.</P>
<P>It should be an interesting conversation, in any case.... :-)</P>
<P mce_keep="true">&nbsp;</P>
<P><FONT color=#ff00ff><EM>This post brought to you by</EM>&nbsp;<FONT size=5>ﬃ</FONT> <EM>(<A class="" href="http://www.fileformat.info/info/unicode/char/fb03" mce_href="http://www.fileformat.info/info/unicode/char/fb03">U+fb03</A>, a.k.a. LATIN SMALL LIGATURE FFI)</EM></FONT></P>
<hr/><p><a id="1471000" href="#1471000">#</a> <strong>Philihp Busby</strong> on 15 Jan 2007 7:21 AM:</p><div style="margin-left: 1em"><p>Although a white-box tester may be able to prove that those flags are necessary, I'd be interested to see if anyone has ever needed them. Seems like a difficult fix for an edge-case bug that &nbsp;practically will never empirically happen.</p></div>
<p><a id="1471013" href="#1471013">#</a> <strong>Dean Harding</strong> on 15 Jan 2007 7:25 AM:</p><div style="margin-left: 1em"><p>To me, CHAR (and to a lesser extent, NCHAR) is really a just hangover from the COBOL days when all strings were fixed length anyway.</p>
<p>In almost all cases, [N]VARCHAR is going to be more efficient than [N]CHAR (except perhaps for strings &lt; 5 characters or so).</p>
<p>And lets not get Norman Diamond started on the fact that CHAR(5) isn't actually storing 5 &quot;characters&quot; at all (whatever definition of &quot;character&quot; you choose to use...) ;-)</p></div>
<p><a id="1471175" href="#1471175">#</a> <strong>Michael S. Kaplan</strong> on 15 Jan 2007 8:11 AM:</p><div style="margin-left: 1em"><P>Well it keeps PSS busy! (e.g. <STRONG><A class="" href="http://support.microsoft.com/kb/154886/EN-US/">here</A></STRONG>, <STRONG><A class="" href="http://support.microsoft.com/kb/231830/EN-US/">here</A></STRONG>, and <STRONG><A class="" href="http://support.microsoft.com/kb/316626">here</A></STRONG>).</P></div>
<p><a id="1478807" href="#1478807">#</a> <strong>ReallyEvilCanine</strong> on 16 Jan 2007 10:42 AM:</p><div style="margin-left: 1em"><p>Where outside of English and French is AE=&#198;?</p>
<p>Dean: Perhaps CHAR should be changed to GLYPH to prevent the confusion. That goes hand-in-hand with Michael's explanation about U+00e5 (&#229;) vs. U+0061 U+030a. The former is two character long, the latter two, but both are one (and the same) GLYPH. </p></div>
<p><a id="1478907" href="#1478907">#</a> <strong>Michael S. Kaplan</strong> on 16 Jan 2007 11:14 AM:</p><div style="margin-left: 1em"><p>Actually everywhere, REC, outside of a few languages (Danish Greeenlandic, Norwegian, and Icelandic).</p>
</div>
<p><a id="1478941" href="#1478941">#</a> <strong>Michael S. Kaplan</strong> on 16 Jan 2007 11:19 AM:</p><div style="margin-left: 1em"><p>As to the idea of adding the GLYPH notion....</p>
<p>Unicode has a term coined by Mark Davis -- &quot;Grapheme Cluster&quot;. But first the question I posed must be answered -- is it useful as a DATATYPE rather than just maybe a T-SQL function or two?</p>
</div>
<p><a id="1479013" href="#1479013">#</a> <strong>kevinowen</strong> on 16 Jan 2007 11:31 AM:</p><div style="margin-left: 1em"><p>Isn't the issue with U+00e5 vs. U+0061 U+030a at least somewhat obviated by normalization? The SQL Standard states that:</p>
<p>&quot;An SQL-implementation may assume that all UCS strings are normalized in Normalization Form C (NFC), as</p>
<p>specified by [Unicode15]. With the exception of &lt;normalize function&gt; and &lt;normalized predicate&gt;, the result</p>
<p>of any operation on an unnormalized UCS string is implementation-defined.&quot; (ISO/IEC 9075-2:2003 &#167;4.2.8)</p>
<p>Is it fair to assume that SQL Server provides support beyond this, such as implicit normalization during collation operations? I'm guessing it probably is, which would explain why that particular case would still be an issue...</p>
</div>
<p><a id="1479040" href="#1479040">#</a> <strong>Michael S. Kaplan</strong> on 16 Jan 2007 11:34 AM:</p><div style="margin-left: 1em"><P>Well, if you normalize then it is, but SQL Server does not do that by default. SQLS for the most part just makes the two strings "the same" for most operations though not so much in T-SQL string handling. Thus the problem persists. :-(</P></div>
<hr/><p><em>referenced by</em></p><div style="margin-left: 1em"><p>2008/10/06 <a href="http://archives.miloush.net/michkap/archive/2008/10/06/8977552.html">UCS-2 to UTF-16, Part 4: Talking about the ask</a></p><p>2008/07/25 <a href="http://archives.miloush.net/michkap/archive/2008/07/25/8771119.html">Let's save some time and call them all IRregular expression engines</a></p><p>2007/12/11 <a href="http://archives.miloush.net/michkap/archive/2007/12/11/6730684.html">In SQL Server, there is the rest of Unicode (aka the SiaO Incompleteness Theorem)</a></p></div><p><em>go to <a id="newer" href="http://archives.miloush.net/michkap/archive/2007/01/16/1475944.html" title="Please excuse the interruption">newer</a> or <a id="older" href="http://archives.miloush.net/michkap/archive/2007/01/15/1466291.html" title="How long can it get?">older</a> post, or back to <a href="http://archives.miloush.net/michkap/archive/index.html">index</a> or <a href="http://archives.miloush.net/michkap/archive/index.html#2007-01">month</a> or <a href="http://archives.miloush.net/michkap/archive/index.html#2007-01-15">day</a></em></p></body>
<!-- Mirrored from archives.miloush.net/michkap/archive/2007/01/15/1469885.html by HTTrack Website Copier/3.x [XR&CO'2014], Thu, 25 May 2017 00:42:38 GMT -->
</html>