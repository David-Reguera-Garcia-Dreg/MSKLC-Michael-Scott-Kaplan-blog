<html>
<!-- Mirrored from archives.miloush.net/michkap/archive/2007/01/06/1421178.html by HTTrack Website Copier/3.x [XR&CO'2014], Thu, 25 May 2017 00:42:38 GMT -->
<head><meta charset="utf-8" /><meta name="viewport" content="width=device-width" /><title>Mixing it up with bidirectional text</title></head><body>
<h1>Mixing it up with bidirectional text</h1>
<p><em>by Michael S. Kaplan, published on 2007/01/06 06:01 -05:00, original URI: http://blogs.msdn.com/b/michkap/archive/2007/01/06/1421178.aspx</em></p>
<hr/> <!-- Archival Source: ProcessPostNew -->
<P>So the question that Ziv asked was:</P>
<BLOCKQUOTE><FONT face="Times New Roman,Times" size=2><I>
<P>Hi,<BR><BR>I’m trying to display both English and Hebrew text in a single WinForms RichTextBox. Basically, the user types a string in one RichTextBox control (in either languages) and I’m appending it to the contents of another RichTextBox control.<BR><BR>The problem is that “ambivalent” characters (such as “!” and “:”), while they get displayed correctly when the user types them in, are not displayed correctly once appended to the other RichTextBox.<BR><BR>For example, if the user types the following two strings:<BR><BR>Hello!<BR>שלום!‏<BR><BR>Appending those strings to the existing RichTextBox yields the following display (if RightToLeft is set to “No”):<BR><BR>Hello!<BR>שלום!<BR><BR>And yields the following display (if RightToLeft is set to “Yes”):<BR><BR>!Hello<BR>שלום!<BR><BR>How can I trick the RichTextBox into behaving correctly?</P>
<P>Thanks, Ziv.</P></I></FONT></BLOCKQUOTE>
<P>This is kind of like a problem I have discussed before in posts like <A class="" href="http://archives.miloush.net/michkap/archive/2006/01/19/514718.html" mce_href="http://archives.miloush.net/michkap/archive/2006/01/19/514718.html"><STRONG>this one</STRONG></A>, with a new twist -- the fact that one does not know what the text might be here -- whether it will be Hebrew or English. If one knows then one can properly use <A class="" href="http://www.fileformat.info/info/unicode/char/200e" mce_href="http://www.fileformat.info/info/unicode/char/200e">U+200e</A> (LEFT-TO-RIGHT MARK) and <A class="" href="http://www.fileformat.info/info/unicode/char/200f" mce_href="http://www.fileformat.info/info/unicode/char/200f">U+200f</A> (RIGHT-TO-LEFT MARK) before these potentially visually&nbsp;leading/trailing characters that have a more neutral directionalty.</P>
<P>If you have no idea whether things are LTR or RTL though, then you don't know what to insert.</P>
<P>Either way, you probably need to get the data out about the various Bidi categories of all of the characters. </P>
<P>To do that in the .NET Framework, you currently have to use reflection to get at an internal method that some others have found spluenking through the IL information of the .NET Framework. At one point there was discussion of making it public but that did not end up happening. Though the method works and&nbsp;enough people have puzzled this one using reflection&nbsp;out that I would just post it now and perhaps keep the next 100 people from having to do it. :-)</P>
<P>Here is a simplified example:</P>
<BLOCKQUOTE><FONT face="Consolas,Lucida Console,Courier New,Courier" size=2><B>
<P>using System;<BR>using System.Reflection;<BR>using System.Globalization;<BR><BR>class CharUnicodeInfoReflection<BR>{<BR>&nbsp;&nbsp;&nbsp; [STAThread]<BR>&nbsp;&nbsp;&nbsp; static void Main() {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; string st = "Hello!\r\nשלום!";<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Type typeCharUnicodeInfo = Type.GetType("System.Globalization.CharUnicodeInfo");<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; BindingFlags bf = BindingFlags.NonPublic | BindingFlags.Static | BindingFlags.Instance | BindingFlags.InvokeMethod;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; MethodInfo getBidiCategory = typeCharUnicodeInfo.GetMethod("GetBidiCategory", bf);<BR><BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for(int ich = 0; ich &lt; st.Length; ich++) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Object [] parameters = new Object[2] {st, ich};<BR><BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Object o = getBidiCategory.Invoke(typeCharUnicodeInfo, bf, null, parameters, CultureInfo.InvariantCulture);<BR><BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Console.WriteLine("U+" + ((ushort)st[ich]).ToString("x4") + "&nbsp;&nbsp;&nbsp; " + o.GetType().ToString() + "&nbsp;&nbsp;&nbsp; " + o.ToString());<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<BR>&nbsp;&nbsp;&nbsp; }<BR>}</P></B></FONT></BLOCKQUOTE>
<P mce_keep="true">This code will return the following when run:</P>
<BLOCKQUOTE><FONT face="Consolas,Lucida Console,Courier New,Courier" size=2><B>
<P mce_keep="true">U+0048&nbsp;&nbsp;&nbsp; System.Globalization.BidiCategory&nbsp;&nbsp;&nbsp; LeftToRight<BR>U+0065&nbsp;&nbsp;&nbsp; System.Globalization.BidiCategory&nbsp;&nbsp;&nbsp; LeftToRight<BR>U+006c&nbsp;&nbsp;&nbsp; System.Globalization.BidiCategory&nbsp;&nbsp;&nbsp; LeftToRight<BR>U+006c&nbsp;&nbsp;&nbsp; System.Globalization.BidiCategory&nbsp;&nbsp;&nbsp; LeftToRight<BR>U+006f&nbsp;&nbsp;&nbsp; System.Globalization.BidiCategory&nbsp;&nbsp;&nbsp; LeftToRight<BR>U+0021&nbsp;&nbsp;&nbsp; System.Globalization.BidiCategory&nbsp;&nbsp;&nbsp; OtherNeutrals<BR>U+000d&nbsp;&nbsp;&nbsp; System.Globalization.BidiCategory&nbsp;&nbsp;&nbsp; ParagraphSeparator<BR>U+000a&nbsp;&nbsp;&nbsp; System.Globalization.BidiCategory&nbsp;&nbsp;&nbsp; ParagraphSeparator<BR>U+05e9&nbsp;&nbsp;&nbsp; System.Globalization.BidiCategory&nbsp;&nbsp;&nbsp; RightToLeft<BR>U+05dc&nbsp;&nbsp;&nbsp; System.Globalization.BidiCategory&nbsp;&nbsp;&nbsp; RightToLeft<BR>U+05d5&nbsp;&nbsp;&nbsp; System.Globalization.BidiCategory&nbsp;&nbsp;&nbsp; RightToLeft<BR>U+05dd&nbsp;&nbsp;&nbsp; System.Globalization.BidiCategory&nbsp;&nbsp;&nbsp; RightToLeft<BR>U+0021&nbsp;&nbsp;&nbsp; System.Globalization.BidiCategory&nbsp;&nbsp;&nbsp; OtherNeutrals</P></B></FONT></BLOCKQUOTE>
<P mce_keep="true">So we've learned that we can get the Unicode bidi class of any Unicode character. In fact, we can probably get the type explicitly and use it more directly than this quick example if we wanted to create a wrapper to make it easier to call while hiding the reflection stuff. anyond want to try and take a stab at that? ;-)</P>
<P mce_keep="true">And now we&nbsp;have the key here to solving Ziv's issue -- any time one finds neutral characters at which ever end of the string is going to be stuck on another string, one has to add&nbsp;either an&nbsp;RLM or an LRM matching the last character with some direction we found, before the append. And for good measure we do it on the other end of the string too, so that a neutral on the other end is not misinterpreted.</P>
<P mce_keep="true">Thus in this case (for example), where the string ends with&nbsp;<STRONG>!</STRONG> (U+0021, a.k.a. EXCLAMATION MARK), we have to walk backwards in the string to the first character that has some direction. We see it is U+05dd and that&nbsp;this character&nbsp;is <STRONG>RightToLeft</STRONG>, so we add a <A class="" href="http://www.fileformat.info/info/unicode/char/200f" mce_href="http://www.fileformat.info/info/unicode/char/200f">U+200f</A>&nbsp;to the end before we append or prepend&nbsp;another string (and we do something similar if the string we are appending/prepending has neutral characters at its ends, too).</P>
<P mce_keep="true">Should this be built in? </P>
<P mce_keep="true">Well, maybe. </P>
<P mce_keep="true">It is hard to imagine the exact semantic of such a method or what we would call it (or even what object would it go on, exactly). </P>
<P mce_keep="true">In this world where the .NET Framework supports neither parsing nor formatting with LRM and RLM like Win32 does, it just seems a little premature to start adding code that will insert these characters so freely. Know what I mean? :-)</P>
<P mce_keep="true">One special note -- the GetBidiCategory method does not seem to have&nbsp;a method that takes a single char (a developer asked me about this a few weeks ago and wondered if he was missing something; he wasn't); it only has one that takes a string and an index (a signature I have discussed <A class="" href="http://archives.miloush.net/michkap/archive/2005/01/28/362305.html" mce_href="http://archives.miloush.net/michkap/archive/2005/01/28/362305.html"><STRONG>previously</STRONG></A>), which means if you pass a supplementary character in UTF-16 as a high surrogate and a low surrogate, you will get the bidi category of the supplementary character. This is what you would want for any code, but note that the code above would have to be modified so that any time one has a high and a low surrogate one knows to not get the bidi category of the low surrogate by itself....</P>
<P mce_keep="true">If someone really wanted to take a stab at the generic function that would do all this, I think it meets the compleity level of a difficult interview question and I'd likely be impressed by code that would do the trick.:-)</P>
<P mce_keep="true">&nbsp;</P>
<P mce_keep="true"><FONT color=#ff00ff><EM>This post brought to you by</EM> <STRONG><FONT size=5>!</FONT></STRONG> <EM>(U+0021, a.k.a. EXCLAMATION MARK)</EM></FONT></P>
<hr/><p><a id="1424993" href="#1424993">#</a> <strong>Erzengel</strong> on 6 Jan 2007 8:25 PM:</p><div style="margin-left: 1em"><p>Isn't this relying on &quot;implementation details&quot;? </p></div>
<p><a id="1425015" href="#1425015">#</a> <strong>Michael S. Kaplan</strong> on 6 Jan 2007 8:31 PM:</p><div style="margin-left: 1em"><p>Since the markers will only ever do to text what you wanted to happen anyway, they will allow you (if you follow this technique) to be independent of implementation-specific details.</p>
<p>If the undocumented piece is what you are referring to, you can find some other source for Bidi info and use it instead if you want. :-)</p>
</div>
<hr/><p><em>referenced by</em></p><div style="margin-left: 1em"><p>2010/07/23 <a href="http://archives.miloush.net/michkap/archive/2010/07/23/10041679.html">It used to be Windows doing it right, and Office following. But now...</a></p><p>2010/04/06 <a href="http://archives.miloush.net/michkap/archive/2010/04/06/9989320.html">Arabic? English? Both? Neither?</a></p><p>2008/08/25 <a href="http://archives.miloush.net/michkap/archive/2008/08/25/8893033.html">The Bidi Algorithm's own SEP Field</a></p><p>2008/04/19 <a href="http://archives.miloush.net/michkap/archive/2008/04/19/8409778.html">Even if the text is right underneath, it may look wrong close up....</a></p><p>2008/04/18 <a href="http://archives.miloush.net/michkap/archive/2008/04/18/8405696.html">The mythical nature of bidirectional support, and where the wheels come off the wagon</a></p><p>2008/04/07 <a href="http://archives.miloush.net/michkap/archive/2008/04/07/8364480.html">Fight the Future? (#8 of ??), aka The Bug(s) Spotted, aka Design flaws are worse than bugs</a></p></div><p><em>go to <a id="newer" href="http://archives.miloush.net/michkap/archive/2007/01/07/1430714.html" title="On trimming the [Unicode] whitespace...">newer</a> or <a id="older" href="http://archives.miloush.net/michkap/archive/2007/01/06/1420754.html" title="Sorting The Old New Thing All Out">older</a> post, or back to <a href="http://archives.miloush.net/michkap/archive/index.html">index</a> or <a href="http://archives.miloush.net/michkap/archive/index.html#2007-01">month</a> or <a href="http://archives.miloush.net/michkap/archive/index.html#2007-01-06">day</a></em></p></body>
<!-- Mirrored from archives.miloush.net/michkap/archive/2007/01/06/1421178.html by HTTrack Website Copier/3.x [XR&CO'2014], Thu, 25 May 2017 00:42:38 GMT -->
</html>