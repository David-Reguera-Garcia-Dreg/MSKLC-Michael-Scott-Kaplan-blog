<html>
<!-- Mirrored from archives.miloush.net/michkap/archive/2007/01/18/1487464.html by HTTrack Website Copier/3.x [XR&CO'2014], Thu, 25 May 2017 00:42:38 GMT -->
<head><meta charset="utf-8" /><meta name="viewport" content="width=device-width" /><title>What the %$#&amp; is up with localized paths in Vista?</title></head><body>
<h1>What the %$#&amp; is up with localized paths in Vista?</h1>
<p><em>by Michael S. Kaplan, published on 2007/01/18 00:01 -08:00, original URI: http://blogs.msdn.com/michkap/archive/2007/01/18/1487464.aspx</em></p>
<hr/> <!-- Archival Source: ProcessPostOld -->
<P>You know, South Park was just on, it was the one where they wind up&nbsp;taking a bus&nbsp;to China for the world dodgeball championship. I was trying to decide whether it was a good thing or not that I recognized&nbsp;野種 on the banner in the back of the gym even though I know very little Chinese, and then I wondered whether KTSW really had cut the scene that had the banners in it or whether I had missed it.</P>
<P>I'm not sure why, but it got me thinking about a question from the Suggestion Box, where&nbsp;ph_arnaud asked:</P>
<BLOCKQUOTE><FONT face="Times New Roman,Times" size=2><I>
<P>Hi,<BR><BR>How are applications running on localized Vista supposed to show filepath names to the user with localized folder names?<BR><BR>For example:<BR><BR>At least in German Vista Ultimate and Home, a dir in command prompt shows:<BR><BR>&nbsp;&nbsp;&nbsp; C:\Program Files<BR>&nbsp;&nbsp;&nbsp; C:\Users<BR>&nbsp;&nbsp;&nbsp; C:\Windows<BR><BR>(not showing hidden or system items).<BR><BR>Windows Explorer shows:<BR><BR>&nbsp;&nbsp;&nbsp; C &gt; Benutzer<BR>&nbsp;&nbsp;&nbsp; C &gt; Programme<BR>&nbsp;&nbsp;&nbsp; C &gt; Windows<BR><BR>If UI shows a confirmation message with a path name say to some user application data file using:<BR><BR>&nbsp;&nbsp;&nbsp; SHGetFolderPath ( CSIDL_MYPICTURES )<BR><BR>this function returns:<BR><BR>&nbsp;&nbsp;&nbsp; C:\Users\admin\Pictures<BR><BR>(I had hoped this would return the localized name, then all legacy code would show localized UI strings on Vista without more effort... and couldn't the hidden 'junctions' folders actually make the path a valid one? &nbsp;well a digression, it doesn't seem to work that way...)<BR><BR>Is this purpose of SHGetLocalizedName(), to convert a path such as returned by SHGetFolderPath to something the user would understand browsing with Windows Explorer?<BR><BR>&nbsp;&nbsp;&nbsp; C:\Betnutzer\admin\Bilder<BR><BR>I've tried using SHGetLocalizedName on the result of SHGetFolderPath but get an error (GetLastError returns 'Invalid window handle')<BR><BR>Is it worth trying to figure this out, because this is the solution to my question, or is another approach (different API function better)?<BR><BR>I would expect this would confuse average users, who don't use the command line, to see English folder names coming from their Vista applications, while Explorer shows localized names for directories.<BR><BR>However I noticed that German WordPad and Paint show the English names of directories in the MRU list in German Vista, which doesn't match my expectation for consistent folder names.<BR><BR>thanks for your insight on this.</P></I></FONT></BLOCKQUOTE>
<P>Well, first let's put together a call to <A class="" href="http://msdn2.microsoft.com/library/ms647786.aspx" mce_href="http://msdn2.microsoft.com/library/ms647786.aspx">SHGetLocalizedName</A> that works, just for grins so we know what it does (and that it can do it!):</P>
<BLOCKQUOTE><FONT face="Consolas,Lucida Console,Courier New,Courier"><B>
<P>using System;<BR>using System.Text;<BR>using System.Globalization;<BR>using System.Runtime.InteropServices;<BR><BR>namespace Testing {<BR>&nbsp;&nbsp;&nbsp; class TestGetLocalizedName {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; [DllImport("shell32.dll", CallingConvention = CallingConvention.Winapi, CharSet = CharSet.Unicode)]<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; internal static extern int SHGetLocalizedName(string pszPath, StringBuilder pszResModule, ref int cch, out int pidsRes);<BR><BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; [DllImport("user32.dll", EntryPoint="LoadStringW", CallingConvention = CallingConvention.Winapi, CharSet = CharSet.Unicode)]<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; internal static extern int LoadString(IntPtr hModule, int resourceID, StringBuilder resourceValue, int len);<BR><BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; [DllImport("kernel32.dll", CharSet = CharSet.Unicode, ExactSpelling = true, EntryPoint = "LoadLibraryExW")]<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; internal static extern IntPtr LoadLibraryEx(string lpFileName, IntPtr hFile, uint dwFlags);<BR><BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; internal const uint DONT_RESOLVE_DLL_REFERENCES = 0x00000001;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; internal const uint LOAD_LIBRARY_AS_DATAFILE = 0x00000002;<BR><BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; [DllImport("kernel32.dll", ExactSpelling = true)]<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; internal static extern int FreeLibrary(IntPtr hModule);<BR><BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; [DllImport("kernel32.dll", EntryPoint="ExpandEnvironmentStringsW", CharSet=CharSet.Unicode, ExactSpelling=true)]<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; internal static extern uint ExpandEnvironmentStrings(string lpSrc, StringBuilder lpDst, int nSize);<BR><BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; [STAThread]<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; static void Main(string[] args) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if(args.Length &gt; 0) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for(int i=0; i &lt; args.Length; i++) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; StringBuilder sb = new StringBuilder(500);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int len, id;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; len = sb.Capacity;<BR><BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if(SHGetLocalizedName(args[i], sb,&nbsp; ref len, out id) == 0) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Console.Write("Resource is in: \"");<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Console.Write(sb.ToString());<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Console.Write("\"; ID to load is: ");<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Console.WriteLine(id);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ExpandEnvironmentStrings(sb.ToString(), sb, sb.Capacity);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; IntPtr hMod = LoadLibraryEx(sb.ToString(), IntPtr.Zero, DONT_RESOLVE_DLL_REFERENCES | LOAD_LIBRARY_AS_DATAFILE);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if(hMod != IntPtr.Zero) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if(LoadString(hMod, id, sb, sb.Capacity) != 0) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Console.Write("which for ");<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Console.Write(CultureInfo.CurrentUICulture.Name);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Console.Write(" is: ");<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Console.WriteLine(sb.ToString());<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; FreeLibrary(hMod);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Console.WriteLine("\r\n");<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; } else {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Console.Write("The path ");<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Console.Write(args[i]);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Console.Write(" is not localized.");<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Console.WriteLine("\r\n");<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<BR>&nbsp;&nbsp;&nbsp; }<BR>}</P></B></FONT></BLOCKQUOTE>
<P mce_keep="true">Ok, just a silly little console app that you can pass a bunch of paths to, and it will return some stuff about them. Like here is what it returned for me when I switched my user interface language to French:</P>
<BLOCKQUOTE><FONT face="Consolas,Lucida Console,Courier New,Courier"><B>
<P mce_keep="true">E:\&gt;GetLocalizedNameTest.EXE "E:\Program Files" "E:\Users"<BR>Resource is in: "%SystemRoot%\system32\shell32.dll"; ID to load is: 21781<BR>which for fr-FR is: Programmes<BR><BR>Resource is in: "%SystemRoot%\system32\shell32.dll"; ID to load is: 21813<BR>which for fr-FR is: Utilisateurs</P></B></FONT></BLOCKQUOTE>
<P mce_keep="true">Now anything that returns failure you can just use the path you had (though I noticed the function&nbsp;fails with paths that have&nbsp;trailing backslashes, <STRONG>which seems like a bug to me</STRONG>, and paths without&nbsp;a&nbsp;localized name, <STRONG>which does not</STRONG>, and mixed paths that have localized and nolocalized elements, <STRONG>which does</STRONG> since the function is documented as requiring full paths).</P>
<P mce_keep="true">Ok, so it works.&nbsp;Kind of (note that the mixed&nbsp;path case is the one that ph_arnaud&nbsp;was running into).</P>
<P mce_keep="true">Though it does leave a person wondering how they are supposed to get the full path name, doesn't it? It must work, since (after all) it works for the Shell.&nbsp;It is just not obvious&nbsp;<STRONG>how</STRONG>.&nbsp;Hmmm....</P>
<P mce_keep="true">Never mind, let's move to the rest of the question, since I think otherwise the superficial functional&nbsp;difficulties here might distract us from the fundamental design problems. :-)</P>
<P mce_keep="true">Once upon a time, when each language SKU had its own set of paths which might well be different from what they might be on an en-US copy, MUI simply left some of these "SKU-specific items" whose underlying resources did not change when the UI language did, people complained (with good reason, in my opinion) that localized systems were not the same as an MUI system set to that user interface language.</P>
<P mce_keep="true">Functions like <A class="" href="http://msdn.microsoft.com/library/en-us/shellcc/platform/shell/reference/functions/shgetfolderpath.asp" mce_href="http://msdn.microsoft.com/library/en-us/shellcc/platform/shell/reference/functions/shgetfolderpath.asp">SHGetFolderPath</A> had the job of giving you a functioning folder you could use in your code (because if you hard coded the folder names they might fail completely!). Their central intent was not so much for nice display (though that worked too) as it was for core functionality of paths resolving at all.</P>
<P mce_keep="true">This is an important point so please read the previous paragraph again.</P>
<P mce_keep="true">But is this always true? Weren't there some&nbsp;folders which did vary with UI language that this function did&nbsp;show those changes&nbsp;for? Perhaps I am misremembering. I don't have an XP MUI machine right in front of ne to test this on. Hmmm....</P>
<P mce_keep="true">Now of course, when every SKU is the same, one has "lost" the "feature" of a command prompt that gave localized names. And one has to decide whether it is most evil to break the ability of <A class="" href="http://msdn.microsoft.com/library/en-us/shellcc/platform/shell/reference/functions/shgetfolderpath.asp" mce_href="http://msdn.microsoft.com/library/en-us/shellcc/platform/shell/reference/functions/shgetfolderpath.asp">SHGetFolderPath</A>&nbsp;to return properly localized paths or whether it is insdtead most evil for it to return paths that will function.</P>
<P mce_keep="true">They decided to go for the functionality, it would seem.</P>
<P mce_keep="true">Though at the same time some functionality has been lost here in each individual SKUs for there to be a better overall architecture.</P>
<P mce_keep="true">For what it is worth, I agree with ph_arnaud that there could have been some better design choices here. And I had trouble getting nested paths that involved both localized and non-localized elements to work properly, which I assume was simply due to the fact that I threw the code together at 11:30pm for a blog post that I was trying to get up around midnight.</P>
<P mce_keep="true"><EM>(Before I forget, I need to remember to send email to the WMI folks to let them know a bunch of their pinvoke declarations are incorrect!)</EM></P>
<P mce_keep="true">I also agree that the inconsistencies are weird, just like they are in <STRONG><A class="" href="http://archives.miloush.net/michkap/archive/2006/12/12/1264508.html" mce_href="http://archives.miloush.net/michkap/archive/2006/12/12/1264508.html">this other post</A></STRONG>.</P>
<P mce_keep="true">I'll be talking more about some of the issues here (both the ones problems that were addressed and the problems that have been introduced) in upcoming posts....</P>
<P mce_keep="true">&nbsp;</P>
<P mce_keep="true"><FONT color=#ff00ff><EM>This post brought to you by</EM>&nbsp;<FONT size=5>፨</FONT> <EM>(<A class="" href="http://www.fileformat.info/info/unicode/char/1368" mce_href="http://www.fileformat.info/info/unicode/char/1368">U+1368</A>, a.k.a. ETHIOPIC PARAGRAPH SEPARATOR)</EM></FONT></P>
<hr/><p><a id="1488254" href="#1488254">#</a> <strong>Björn</strong> on Thursday, January 18, 2007 5:11 AM:</p><div style="margin-left: 1em"><p>So, it might be due to the current state of caffeination of myself, but what is the solution for the mix path case? And is his non-localized element the user name in the path? And if, so, what is the solution to get &quot;Bilder&quot;? Will it be presented in an upcoming post? Will I continue to end sentence in this comment with U+003F a.k.a. QUESTION MARK? No, I guess I will not :)</p>
<p>Sidenote: Wouldn't it be easier and more readable to use C++ (or C++/CLI) for such samples - the interop declarations add a lot of clutter; maybe syntax highlighting could mitigate it...</p></div>
<p><a id="1488625" href="#1488625">#</a> <strong>Michael S. Kaplan</strong> on Thursday, January 18, 2007 7:35 AM:</p><div style="margin-left: 1em"><p>Actually Bj&#246;rn, that is not at all known or obvious, at the moment. :-)</p>
<p>I think it was mainly the fact that I was pretty tight for time that led to the language choice for the sample, &nbsp;though for this case losing the pinvoke declarations actually would have (in my opinion) required me talking more about the functions I was calling that were unfamiliar and their params....</p></div>
<p><a id="1491201" href="#1491201">#</a> <strong>Dean Harding</strong> on Thursday, January 18, 2007 7:53 PM:</p><div style="margin-left: 1em"><p>Hmm, I'm not really sure about this &quot;feature&quot; actually. (That is, having the C:\Users folder untranslated for everybody, and only &quot;displaying&quot; a translated version)</p>
<p>I mean, I understand that for MUI and all that, you've got to have SOME physical folder name which may be different to what the user expects, but couldn't that name have been the localized version of &quot;Users&quot; (or whatever) when the OS was being installed (so if I installed in a French language, I'd get a physical folder name of &quot;C:\Utilisateurs&quot;).</p>
<p>You'd still use SHGetLocalizedName to get the real localized name, but since 99% of people would be USING Vista in the same language that they INSTALLED it, most of the time it'd be exactly the same as the physical name.</p>
<p>As it is now, anywhere I want to display a path, I HAVE to use SHGetLocalizedName (a Vista-only function, of course), otherwise non-English users are going to be rather confused... Isn't it better to be wrong for 1% of users than it is to be wrong for 50% of users (whatever the proportion of non-English-speaking people use Windows)?</p>
<p>&lt;/end-rant&gt; Ah well, I guess the boat as sailed on this one!</p></div>
<p><a id="1491787" href="#1491787">#</a> <strong>Pavanaja U B</strong> on Friday, January 19, 2007 12:39 AM:</p><div style="margin-left: 1em"><p>I have larger issue. Indic does not work on the console :(</p>
<p>-Pavanaja</p></div>
<p><a id="1491967" href="#1491967">#</a> <strong>Michael S. Kaplan</strong> on Friday, January 19, 2007 1:59 AM:</p><div style="margin-left: 1em"><P>You have to try the <STRONG>new</STRONG> console for that!</P></div>
<p><a id="1493343" href="#1493343">#</a> <strong>ph_arnaud</strong> on Friday, January 19, 2007 10:48 AM:</p><div style="margin-left: 1em"><p>Thanks for getting some research and discussion going on this topic.</p>
<p>I also discovered that the function does seem to work for short paths and with trailing backslash.</p>
<p>c:\Program Files\ works. &nbsp;(implemented in a tiny MFC dialog app)</p>
<p>I am still interested to hear the solution for longer paths, as the average case may be to put in a titlebar a full path to a file, or a message box confirming save/delete/etc, with full long path name - with as you mention a mix of folders with no localized name available and a few folders with localized names.</p>
<p>For example:</p>
<p>C:\Users\admin\Pictures\bike.jpg</p>
<p>Just in case I tried to pass in some paths like:</p>
<p>Pictures</p>
<p>%USERPROFILE%\Pictures</p>
<p>with and without a real filename that exists in that directory, didn't get any productive result.</p>
<p>This function SHGetLocalizedName seems like it can't work for a full long path, because it in fact returns a 'path' &nbsp;(dll name, and res id) to find one localized directory name.</p>
<p>I believe pretty much the same issue existed on the multilingual version of Windows XP (enu with language packs), when switched to a language pack, (Explorer would show some folder names localized, vs true English names in the file system). &nbsp;But maybe no one really noticed as the ratio of 'full-localized' XP to enu + language pack XP was vastly skewed to full-localized XP as that was the consumer version available to most end-users.</p>
<p>Looking forward to more info on this topic.</p></div>
<p><a id="1495884" href="#1495884">#</a> <strong>Pavanaja UB</strong> on Friday, January 19, 2007 10:18 PM:</p><div style="margin-left: 1em"><p>&gt; You have to try the new console for that!</p>
<p>Where is that?</p>
<p>Rgds,</p>
<p>Pavanaja</p></div>
<p><a id="1497008" href="#1497008">#</a> <strong>Michael S. Kaplan</strong> on Saturday, January 20, 2007 12:48 AM:</p><div style="margin-left: 1em"><p>It's called PowerShell? You have probably heard tell of it in other blogs; if not a search should be pretty easy....</p>
<p>(let's get this blog and its comment back on topic, kay?)</p></div>
<p><a id="1499716" href="#1499716">#</a> <strong>James S.</strong> on Saturday, January 20, 2007 4:14 PM:</p><div style="margin-left: 1em"><p>The behaviour of the SHGetLocalizedName function seems correct to me (although the documentation for it is rubbish - the third parameter can't seem to decide whether it's in or out and the type is wrong). The string &quot;C:\Users\Bloke&quot; specifies a specific directory; that directory does not have a localised name. On the other hand, &quot;C:\Users&quot; specifies a different directory, which perhaps does.</p>
<p>Isn't the problem here that what we think we want is a function CreateLocalisedPath which maps each path component to its localised value? We could easily write one :)</p>
<p>Really though, the problem is that this functionality creates a one-way mapping from files to filenames, when most software and users expect bidirectional mappings (even if there are many of them). The user won't be able to type &quot;C:\Utilisateurs&quot;, because it doesn't exist. It might even be a different directory! And of course, the vast majority of software won't bother with this particular tax, because the developers won't know about it.</p>
<p>Windows XP had this problem with the start menu. The default folders had desktop.ini files pointing to localised names. This was terribly confusing to anyone who tried to rename the items on the start menu, and doubly so if their user account's start menu folder lacked desktop.ini but the All Users folder did. &quot;Fortunately&quot;, most users never organised their start menu, leading to the new search-based thingy in Vista (which I still consider to be a crime against the organised, but I'm hoping I'll get used to it).</p>
<p>Of course, junctions wouldn't help because there would need to be an infinite number of them :(</p>
<p>The real answer must be to use cryptic names like usr and bin to distract people from the issue :)</p></div>
<p><a id="1506581" href="#1506581">#</a> <strong>Michael S. Kaplan</strong> on Monday, January 22, 2007 2:38 AM:</p><div style="margin-left: 1em"><P>For me the big problem is that this function (while probably useful in the context in which the Shell calls it) is mostly useless for anyone outside of MS (and even for most people within MS). And there is no clear indication of the correct function to be calling here, so there is no hint on where to go from here?</P></div>
<p><a id="1507018" href="#1507018">#</a> <strong>Centaur</strong> on Monday, January 22, 2007 4:23 AM:</p><div style="margin-left: 1em"><p>Why was it decided that names should be localized? Is it based on the assumption that users will not be able to learn a few foreign words? Personally I find this assumption insulting.</p>
<p>The abstraction that this function creates is inherently leaky. Users will not be able to use these localized names in contexts where they expect to be able directory names. They will say, “Why is there a ‘buffalo’ caption on the elephant’s cage? Computers are *so* hard to use”. They will learn not to trust the shell.</p></div>
<p><a id="1507216" href="#1507216">#</a> <strong>Michael S. Kaplan</strong> on Monday, January 22, 2007 5:15 AM:</p><div style="margin-left: 1em"><P>You mean the original decison long before MUI and back when the first localized versions of Windows were being created? When not every user wanted to be required to learn English words, and not everyone at Microsoft wanted to force them to do so?</P>
<P>This was a decision made more than ten versions ago, so it is hard to pin down exactly why, but it's a little late to chuck it all now, IMHO.</P></div>
<p><a id="1507243" href="#1507243">#</a> <strong>c2j2</strong> on Monday, January 22, 2007 5:27 AM:</p><div style="margin-left: 1em"><p>BTW: With the new Vista abbreviated names (c:\Documents == c:\Documents and Settings\[user name]\My Documents), it will be more likely for users to enter the path directly in an edit control (falling on the nose) than to select the path using CommonDialog (using a &quot;browse&quot; button after the edit control).</p>
<p>That entry form (edit control with a &quot;browse button&quot;) is pretty much standard.</p>
<p>Thus for experienced users, they will experience more trouble ;-)</p>
<p>Will there PLEASE be a thorough manual on how to handle these path mappings correctly, in BOTH directions?</p>
<p>Christian</p></div>
<p><a id="1507278" href="#1507278">#</a> <strong>Michael S. Kaplan</strong> on Monday, January 22, 2007 5:41 AM:</p><div style="margin-left: 1em"><P>Hey c2j2, see <STRONG><A class="" href="http://archives.miloush.net/michkap/archive/2006/12/13/1275292.html">this post</A></STRONG> for why the shorter names happened....</P></div>
<p><a id="1507672" href="#1507672">#</a> <strong>c2j2</strong> on Monday, January 22, 2007 7:34 AM:</p><div style="margin-left: 1em"><p>Thanks, MichKa, actually that's where I have seen them first ;-) But my problem is that the paths are so short that some users will enter them in the path edit box faster as selecting them though a commdlg LoadFile().</p>
<p>So what happens if a user enters &quot;c:\dokumente\x.txt&quot; in the edit box to save a file in the &quot;c:\Documents and Settings\[user name]\My Documents&quot; folder, as the knows &quot;c:\dokumente&quot; exists (from explorer)?</p>
<p>&quot;File open error&quot; as the directory does not exist!</p>
<p>a) my program expects this, creates the directory as needed and writes the file - will it ever be found again (for sure not in c:\Documents and Settings\[user name]\My Documents, but also &quot;c:\dokumente&quot; will not be visible in Explorer, will it? Will there be two paths of the same name, one my new directory and the other pointing to the &quot;old&quot;, long-named path?)</p>
<p>b) creating the directory fails -&gt; It will confuse the user as the directory does exist for the user (he can see it in the Explorer)</p>
<p>Anyway, the damage is done, and I fear it will cause some support contacts itself... so for compatibility reasons (or whatever reason is given for the localized paths) a lot of developers actually need to make their applications vista-compatible! Duh!</p>
<p>So all us application developers need to find an easy way for filename conversions, for example SHConvertFSNameToUIName() and SHConvertUINameToFSName()).</p>
<p>Christian</p></div>
<p><a id="1507968" href="#1507968">#</a> <strong>Michael S. Kaplan</strong> on Monday, January 22, 2007 8:07 AM:</p><div style="margin-left: 1em"><p>Hi Christian,</p>
<p>You are actually in your argument using two entirely unrelated issues to try to argue against the problems of the one bring discussed here. We have:</p>
<p>1) The top level, virtual &quot;My Documents&quot; which maps to the longer path -- a feature that has been around since at least Win2000 and has not led to a huge number of people creating phatom new directories. I doubt thast renasming it will change this.</p>
<p>2) The localized path issue beung discussed here.</p>
<p>I would argue that the design of a textbox you type into is a mistake and I ususlly disable the textbox and force them to go through the fileopen dialog. I would recommend that you do the same here, frankly, as this works round 90% of the issues that concern you? :-)</p></div>
<p><a id="1508297" href="#1508297">#</a> <strong>c2j2</strong> on Monday, January 22, 2007 9:13 AM:</p><div style="margin-left: 1em"><p>Hi MichKa,</p>
<p>What you describe (or I assume you describe) is correct, that these folders have been around a long time. I cannot create a &quot;my documents\x.txt&quot; as the folder is so pure virtual, it does not reside in my &quot;c:\&quot; root ;-) Try 'echo Hallo &quot;&gt;my documents\x.txt&quot;'. No user can expect these paths in an edit control that expects a filesystem path. </p>
<p>Once he enters a physical (or seemingly physical) path, that is, a path that he &quot;sees&quot; as a &nbsp;subdirectory on the harddisk, it's different.</p>
<p>I mean the shortcut folders you described in the other post. As they are virtual, localized, but on the harddisk's tree, I would expect consitency. I can create a file &quot;x.txt&quot; in &quot;c:\dokumente&quot; in the Explorer, but I cannot in the command shell ('echo Hallo MichKa &gt;c:\dokumente\x.txt&quot;) and also not in an application that enables fast copy&amp;paste of paths (which is used by prof\b\b\b\busers who shudder at the slowness and awquardness of having to click to open a dialog to enable them to insert a path thay could insert much faster directly).</p>
<p>I don't have a localized Vista here, only an US RC1, so I cannot test what will happen.</p>
<p>Christian</p></div>
<p><a id="1508324" href="#1508324">#</a> <strong>Michael S. Kaplan</strong> on Monday, January 22, 2007 9:18 AM:</p><div style="margin-left: 1em"><P>Again Christian , this is 100% unrelated to the localized dirs issue, happens on English too, and has been around since win2000. Please take it to the <STRONG><A class="" href="http://shellrevealed.com/">shell blog</A></STRONG> as it is their design and has nothing to do with the localized directories.</P></div>
<p><a id="1509861" href="#1509861">#</a> <strong>Installers?</strong> on Monday, January 22, 2007 4:54 PM:</p><div style="margin-left: 1em"><p>Virtually every installer created thus far presents an 'install location' choice to end users, with an edit box and a Browse button. </p>
<p>Am I correct that this can (and will) happen?</p>
<p>1. User on a French machine installing some English shareware</p>
<p>2. Installer prompts for install location</p>
<p>3. It reads: C:\Program Files\Appname</p>
<p>4. User thinks that it's a non-internationalized installer (with accent, exclaming &quot;stupid Americans!&quot;) </p>
<p>5. User changes the path to C:\Programmes\Appname</p>
<p>Now the user has both a C:\Program Files folder and a C:\Programmes folder? Does Vista smart enough to handle this? What happens when they enter C:\Programmes into the address bar? Which folder is loaded? </p></div>
<p><a id="1513397" href="#1513397">#</a> <strong>ph_arnaud</strong> on Tuesday, January 23, 2007 5:42 AM:</p><div style="margin-left: 1em"><p>Hi,</p>
<p>I don't think you need English shareware to see the difference. &nbsp;You could use French or English designed for XP software, or even designed for Vista...</p>
<p>The German Office 2007 installer doesn't show the installation path in the 'default' installation steps - there are no practically no options and the software is just installed.</p>
<p>Only when you choose 'custom', then it does show the English name 'Program Files' as part of path in an edit box (enabled for typing). &nbsp;There is a browse button next to the edit box, which shows a tree structure with localized directory names. &nbsp;Selecting the localized name, then ok, does not change the content of the edit box, which will still contain the English name 'Program Files'. &nbsp;In the Office 2007 installer if you do replace the 'Program Files' with 'Programme' in the install path edit box, it doesn't seem to be an issue, the files are still really installed to Program Files - probably because of the Programme folder junction that exists and redirects? - and of course in Windows Explorer it appears to exist in Programme, whether you put 'Program Files' or 'Programme' in that install edit box)</p>
<p>Beyond installation (which is one time, and perhaps not seen by all users), is run-time usage.</p>
<p>Word 2007 in some cases appears to avoid showing complete paths in UI. &nbsp;For example on the titlebar for the active document, or save confirmation dialogs, it seems to show just the filename - thus avoiding the issue. &nbsp;I don't have any insight if this is to avoid this English/localized foldername issue, or done for other reasons.</p>
<p>German Word 2007 is not completely able to avoid showing full paths. &nbsp;In some cases like hyperlink name and tooltips, the English directory names, when contained in a path, do display.</p></div>
<p><a id="1513458" href="#1513458">#</a> <strong>Michael S. Kaplan</strong> on Tuesday, January 23, 2007 5:52 AM:</p><div style="margin-left: 1em"><P>And everything still works, then. Some confusion? Sure. But that is preferred to some stuff being broken....</P></div>
<p><a id="1668832" href="#1668832">#</a> <strong>Phil Jollans</strong> on Tuesday, February 13, 2007 8:05 AM:</p><div style="margin-left: 1em"><p>Michka, I think localized directory names were a bad idea from the word go. I think that they were introduced in Windows 95, so the design decision was probably about 13 years ago.</p>
<p>You say that it is too late to chuck it now. It seems to me that the basic idea has in fact been chucked. What remains is some cosmetics in the windows explorer.</p>
<p>Localizing the names of directories, which under the surface actually retain their original names, seems so obviously a be bad idea, that the best approach is probably to boycott it. Working with filenames is a basic operation in many applications and the best way to handle it consistently is work with the real filenames.</p>
<p>I cannot imagine the localized aliases being a success and I fully expect Microsoft to abandon them in the following version of Windows.</p>
<p>Phil</p></div>
<p><a id="1669248" href="#1669248">#</a> <strong>Michael S. Kaplan</strong> on Tuesday, February 13, 2007 9:13 AM:</p><div style="margin-left: 1em"><P>The real question is whether more has to be done other than what has already been done -- why not keep the small amount of cosmetic work? :-)</P></div>
<p><a id="1682148" href="#1682148">#</a> <strong>i.g.</strong> on Thursday, February 15, 2007 4:01 AM:</p><div style="margin-left: 1em"><p>So, how can we convert</p>
<p>C:\Users\admin\Pictures</p>
<p>into</p>
<p>C:\Betnutzer\admin\Bilder</p>
<p>?</p>
<p>The SHGetLocalizedName() function works only for the first part (i.e. converting C:\Users into C:\Benutzer is easy, just like shown in the example code)... but how can we get the rest?</p></div>
<p><a id="1683262" href="#1683262">#</a> <strong>Michael S. Kaplan</strong> on Thursday, February 15, 2007 8:36 AM:</p><div style="margin-left: 1em"><p>If I knew, I'd have posted it -- but thus far no one seems to know the answer....</p></div>
<p><a id="1736328" href="#1736328">#</a> <strong>Ming Zhu</strong> on Wednesday, February 21, 2007 1:00 PM:</p><div style="margin-left: 1em"><P>I am from the Windows Shell team. I have recently come across a customer question with the link to this blog. I can see many confusion here and I feel that I can share the discussion here.</P>
<P>Actually, SHGetLocalizedName API is NOT designed to work with folders. The MSDN document already mentioned that it is used to retrieve localized names for files. Use it on folders has in-consistent result - for some folders it will work but for some it does not. </P>
<P>The official way to get a localized name for a folder is through the IShellItem::GetDisplayName or IShellFolder::GetDisplayNameOf method, it works on both pre-Vista and Vista systems. And, it works for all shell folders as well, include those non-file-sytem folders such as "Control Panel". </P>
<P>Here's some code example:</P>
<BLOCKQUOTE><FONT face="Consolas,Lucida Console,Courier New,Courier">
<P>//<BR>// &nbsp;Get the display name of a folder in the shell namespace according to the pidl<BR>//<BR>HRESULT GetDisplayNameFromPidl(LPCITEMIDLIST pidl, __out_ecount(cchName) LPWSTR pszName, UINT cchName) {<BR>&nbsp;&nbsp;&nbsp;IShellFolder *psf = NULL;<BR>&nbsp;&nbsp;&nbsp;LPCITEMIDLIST pidlRelative = NULL;<BR>&nbsp;&nbsp;&nbsp;HRESULT hr = SHBindToParent(pidl, IID_PPV_ARGS(&amp;psf), &amp;pidlRelative);<BR><BR>&nbsp;&nbsp;&nbsp;if (SUCCEEDED(hr))&nbsp;{<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;STRRET sr;<BR><BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;hr = psf-&gt;GetDisplayNameOf(pidlRelative, SHGDN_NORMAL, &amp;sr);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (SUCCEEDED(hr))&nbsp;{<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;hr = StrRetToBuf(&amp;sr, pidl, pszName, cchName);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (FAILED(hr))&nbsp;{<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Trace(Warning, "StrRetToBuf failed, hr = %08X", hr);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;else {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Trace(Warning, "GetDisplayNameOf failed, hr = %08X", hr);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<BR><BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;psf-&gt;Release();<BR>&nbsp;&nbsp;&nbsp;}&nbsp;else&nbsp;{<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Trace(Warning, "SHBindToParent failed, hr = %08X", hr);<BR>&nbsp;&nbsp;&nbsp;}<BR><BR>&nbsp;&nbsp;&nbsp;return hr;<BR>}<BR><BR>//<BR>// &nbsp;Get the a string form of the PIDL by concatenate the display names of the folders in the PIDL<BR>//<BR>HRESULT GetPidlStringFromPidl(LPCITEMIDLIST pidl, __out_ecount(cchPidlString) LPWSTR pszPidlString, size_t cchPidlString) {<BR>&nbsp;&nbsp;&nbsp;HRESULT &nbsp; &nbsp; &nbsp; &nbsp; hr = S_OK;<BR><BR>&nbsp;&nbsp;&nbsp;// First, get the display name of each level of the pidl, and combine them together.<BR>&nbsp;&nbsp;&nbsp;// Since we used ILRemoveLastID() recursively, the order is actually bottom to top.&nbsp;<BR>&nbsp;&nbsp;&nbsp;WCHAR &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; szReversedString[MAX_PATH] = L"";<BR>&nbsp;&nbsp;&nbsp;LPITEMIDLIST &nbsp; &nbsp;pidlClone = ILClone(pidl);<BR>&nbsp;&nbsp;&nbsp;if (pidlClone)&nbsp;{<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;while (SUCCEEDED(hr))&nbsp;{<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;WCHAR &nbsp; szOneLevel[MAX_PATH];<BR><BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;hr = GetDisplayNameFromPidl(pidlClone, szOneLevel, ARRAYSIZE(szOneLevel));<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (SUCCEEDED(hr))&nbsp;{<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;StringCchCat(szReversedString, ARRAYSIZE(szReversedString), L"\\");<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;StringCchCat(szReversedString, ARRAYSIZE(szReversedString), szOneLevel);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (!ILRemoveLastID(pidlClone))&nbsp;{<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;break;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<BR><BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ILFree(pidlClone);<BR>&nbsp;&nbsp;&nbsp;}&nbsp;else&nbsp;{<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;hr = E_OUTOFMEMORY;<BR>&nbsp;&nbsp;&nbsp;}<BR><BR>&nbsp;&nbsp;&nbsp;// Now, we are gonna reverse the path in szReverseName, to get a regular top to bottom path<BR>&nbsp;&nbsp;&nbsp;*pszPidlString = 0;<BR>&nbsp;&nbsp;&nbsp;PWSTR &nbsp;pszLast = szReversedString;<BR>&nbsp;&nbsp;&nbsp;while (pszLast)&nbsp;{<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;pszLast = StrRChr(szReversedString, NULL, L'\\');<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (pszLast) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*pszLast = 0;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;pszLast++;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (pszLast)&nbsp;{<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;StringCchCat(pszPidlString, cchPidlString, L"\\");<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;StringCchCat(pszPidlString, cchPidlString, pszLast);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<BR>&nbsp;&nbsp;&nbsp;}<BR><BR>&nbsp;&nbsp;&nbsp;return hr;<BR>}</P></FONT></BLOCKQUOTE>
<P>You can see the above code works with PIDLs - the shell equivelant of paths. You can get the PIDL from many APIs such as SHGetFolderLocation, ILCreateFromPath etc. </P>
<P>Hope this helps.</P></div>
<p><a id="1737658" href="#1737658">#</a> <strong>ph_arnaud</strong> on Wednesday, February 21, 2007 5:40 PM:</p><div style="margin-left: 1em"><p>Thanks for the precise example!</p>
<p>Now let's see if we can get some recommendations from the Vista User Experience Guidelines team.</p>
<p>This is worth a topic in there. &nbsp;Do we do this mapping only in 'shell explorer' types of interfaces, or should any path shown in a Windows application (list of paths in compression tools, paths in confirmation dialogs, installation paths, etc.) be mapped to a localized folder paths.</p>
<p>I think they've got a link on their page for feedback...</p>
<p>mailto:winui@microsoft.com?subject=Windows Vista User Experience Guidelines feedback</p></div>
<hr/><p><em>referenced by</em></p><div style="margin-left: 1em"><p>2007/09/21 <a href="http://archives.miloush.net/michkap/archive/2007/09/21/5025885.html">If you had gotten there first, you might have staked your claim too!</a></p><p>2007/02/21 <a href="http://archives.miloush.net/michkap/archive/2007/02/21/1736611.html">Here is what's up with localized paths in Vista (and in Windows!)</a></p></div><p><em>go to <a id="newer" href="http://archives.miloush.net/michkap/archive/2007/01/18/1488052.html" title="Even if it makes no sense it has to go somewhere">newer</a> or <a id="older" href="http://archives.miloush.net/michkap/archive/2007/01/17/1481756.html" title="Ungarbling the comments">older</a> post, or back to <a href="http://archives.miloush.net/michkap/archive/index.html">index</a> or <a href="http://archives.miloush.net/michkap/archive/index.html#2007-01">month</a> or <a href="http://archives.miloush.net/michkap/archive/index.html#2007-01-18">day</a></em></p></body>
<!-- Mirrored from archives.miloush.net/michkap/archive/2007/01/18/1487464.html by HTTrack Website Copier/3.x [XR&CO'2014], Thu, 25 May 2017 00:42:38 GMT -->
</html>