<html>
<!-- Mirrored from archives.miloush.net/michkap/archive/2007/07/07/3746794.html by HTTrack Website Copier/3.x [XR&CO'2014], Thu, 25 May 2017 00:42:38 GMT -->
<head><meta charset="utf-8" /><meta name="viewport" content="width=device-width" /><title>TTC indexes, the easy way...</title></head><body>
<h1>TTC indexes, the easy way...</h1>
<p><em>by Michael S. Kaplan, published on 2007/07/07 10:01 -04:00, original URI: http://blogs.msdn.com/b/michkap/archive/2007/07/07/3746794.aspx</em></p>
<hr/> <!-- Archival Source: ProcessPostNew -->
<P>Obviously a follow-on to <STRONG><A class="" href="http://archives.miloush.net/michkap/archive/2007/06/22/3452969.html" mce_href="http://archives.miloush.net/michkap/archive/2007/06/22/3452969.html">TTC indexes, the hard way...</A></STRONG>, this post provides the code that Sergey Malkin put together to work with .TTC files, and more importantly with the individual fonts thereof. </P>
<P>And I think I'll save some of his helpful functions byte swapping, too -- for future forays in this area like that thing I did <A class="" href="http://archives.miloush.net/michkap/archive/2006/02/13/530814.html" mce_href="http://archives.miloush.net/michkap/archive/2006/02/13/530814.html">with the names</A>.... :-)</P>
<P>Here is the code:</P>
<BLOCKQUOTE><FONT face="Consolas,Lucida Console,Courier New,Courier"><B>
<P>#include &lt;stdio.h&gt;<BR>#include &lt;windows.h&gt;<BR><BR>USHORT ReadUshort(BYTE* p) {<BR>&nbsp;&nbsp;&nbsp; return ((USHORT)p[0] &lt;&lt;&nbsp; 8)+ <BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ((USHORT)p[1]&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; );<BR>}<BR><BR>DWORD ReadDword(BYTE* p) {<BR>&nbsp;&nbsp;&nbsp; return ((LONG)p[0] &lt;&lt; 24&nbsp; )+ <BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ((LONG)p[1] &lt;&lt; 16&nbsp; )+<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ((LONG)p[2] &lt;&lt;&nbsp; 8&nbsp; )+<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ((LONG)p[3]&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; );<BR>}|<BR><BR>DWORD ReadTag(BYTE* p) {<BR>&nbsp;&nbsp;&nbsp; return ((LONG)p[3] &lt;&lt; 24&nbsp; )+ <BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ((LONG)p[2] &lt;&lt; 16&nbsp; )+<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ((LONG)p[1] &lt;&lt;&nbsp; 8&nbsp; )+<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ((LONG)p[0]&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; );<BR>}<BR><BR>void WriteDword(BYTE* p, DWORD dw) {<BR>&nbsp;&nbsp;&nbsp; p[0] = (BYTE)((dw &gt;&gt; 24 ) &amp; 0xFF);<BR>&nbsp;&nbsp;&nbsp; p[1] = (BYTE)((dw &gt;&gt; 16 ) &amp; 0xFF);<BR>&nbsp;&nbsp;&nbsp; p[2] = (BYTE)((dw &gt;&gt;&nbsp; 8 ) &amp; 0xFF);<BR>&nbsp;&nbsp;&nbsp; p[3] = (BYTE)((dw&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ) &amp; 0xFF);<BR>}<BR><BR>DWORD RoundUpToDword(DWORD val) {<BR>&nbsp;&nbsp;&nbsp; return (val + 3) &amp; ~3;<BR>}<BR><BR>#define TTC_FILE 0x66637474<BR><BR>const DWORD SizeOfFixedHeader&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; = 12;<BR>const DWORD OffsetOfTableCount&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; = 4;<BR><BR>const DWORD SizeOfTableEntry&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; = 16;<BR>const DWORD OffsetOfTableTag&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; = 0;<BR>const DWORD OffsetOfTableChecksum&nbsp;&nbsp; = 4;<BR>const DWORD OffsetOfTableOffset&nbsp;&nbsp;&nbsp;&nbsp; = 8;<BR>const DWORD OffsetOfTableLength&nbsp;&nbsp;&nbsp;&nbsp; = 12;<BR><BR>HRESULT ExtractFontDataFromTTC(<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; HDC&nbsp;&nbsp;&nbsp;&nbsp; hdc, <BR>&nbsp;&nbsp;&nbsp; __out&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DWORD*&nbsp; pcbFontDataSize,<BR>&nbsp;&nbsp;&nbsp; __deref_out_bcount(*pcbFontDataLength)&nbsp; void**&nbsp; ppvFontData<BR>) {<BR>&nbsp;&nbsp;&nbsp; *ppvFontData = NULL;<BR>&nbsp;&nbsp;&nbsp; *pcbFontDataSize = 0;<BR><BR>&nbsp;&nbsp;&nbsp; // Check if font is really in ttc<BR>&nbsp;&nbsp;&nbsp; if (GetFontData(hdc, TTC_FILE, 0, NULL, 0) == GDI_ERROR)&nbsp;{<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return GetLastError();<BR>&nbsp;&nbsp;&nbsp; }<BR>&nbsp;&nbsp;&nbsp; <BR>&nbsp;&nbsp;&nbsp; // 1. Read number of tables in the font (ushort value at offset 2)<BR><BR>&nbsp;&nbsp;&nbsp; USHORT nTables;<BR>&nbsp;&nbsp;&nbsp; BYTE UshortBuf[2];<BR>&nbsp;&nbsp;&nbsp; if (GetFontData(hdc, 0, 4, UshortBuf, 2) == GDI_ERROR)&nbsp;{<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return GetLastError();<BR>&nbsp;&nbsp;&nbsp; }<BR>&nbsp;&nbsp;&nbsp; nTables = ReadUshort(UshortBuf);<BR>&nbsp;&nbsp;&nbsp; <BR>&nbsp;&nbsp;&nbsp; // 2. Calculate memory needed for the whole font header and read it into buffer<BR>&nbsp;&nbsp;&nbsp; <BR>&nbsp;&nbsp;&nbsp; DWORD cbHeaderSize = SizeOfFixedHeader + nTables * SizeOfTableEntry;<BR>&nbsp;&nbsp;&nbsp; BYTE* pbFontHeader = (BYTE*)malloc(cbHeaderSize);<BR>&nbsp;&nbsp;&nbsp; if (!pbFontHeader)&nbsp;{<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return E_OUTOFMEMORY;<BR>&nbsp;&nbsp;&nbsp; }<BR>&nbsp;&nbsp;&nbsp; if (GetFontData(hdc, 0, 0, pbFontHeader, cbHeaderSize) == GDI_ERROR)&nbsp;{<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; free(pbFontHeader);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return GetLastError();<BR>&nbsp;&nbsp;&nbsp; }<BR>&nbsp;&nbsp;&nbsp; <BR>&nbsp;&nbsp;&nbsp; // 3. Go through tables and calculate total font size. <BR>&nbsp;&nbsp;&nbsp; //&nbsp;&nbsp;&nbsp; Don't forget that tables should be padded to 4-byte <BR>&nbsp;&nbsp;&nbsp; //&nbsp;&nbsp;&nbsp; boundaries, so length should be rounded up to dword.<BR>&nbsp;&nbsp;&nbsp; <BR>&nbsp;&nbsp;&nbsp; DWORD cbFontSize = cbHeaderSize;<BR>&nbsp;&nbsp;&nbsp; <BR>&nbsp;&nbsp;&nbsp; for(int i = 0; i &lt; nTables; i++)&nbsp;{<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DWORD cbTableLength = ReadDword(pbFontHeader + <BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; SizeOfFixedHeader + <BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; i * SizeOfTableEntry + <BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; OffsetOfTableLength<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; );<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (i &lt; nTables - 1)&nbsp;{<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cbFontSize += RoundUpToDword(cbTableLength);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }&nbsp;else {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cbFontSize += cbTableLength;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<BR>&nbsp;&nbsp;&nbsp; }<BR>&nbsp;&nbsp;&nbsp; <BR>&nbsp;&nbsp;&nbsp; // 4. Copying header into target buffer. Offsets are incorrect, <BR>&nbsp;&nbsp;&nbsp; //&nbsp;&nbsp;&nbsp; we will patch them with correct values while copying data.<BR>&nbsp;&nbsp;&nbsp; <BR>&nbsp;&nbsp;&nbsp; BYTE* pbFontData = (BYTE*)malloc(cbFontSize);<BR>&nbsp;&nbsp;&nbsp; if (!pbFontData) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; free(pbFontHeader);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return E_OUTOFMEMORY;<BR>&nbsp;&nbsp;&nbsp; }<BR>&nbsp;&nbsp;&nbsp; memcpy(pbFontData, pbFontHeader, cbHeaderSize);<BR>&nbsp;&nbsp;&nbsp; <BR>&nbsp;&nbsp;&nbsp; // 5. Get table data from GDI, write it into known place <BR>&nbsp;&nbsp;&nbsp; //&nbsp;&nbsp;&nbsp; inside target buffer and fix offset value.<BR>&nbsp;&nbsp;&nbsp; <BR>&nbsp;&nbsp;&nbsp; DWORD dwRunningOffset = cbHeaderSize;<BR>&nbsp;&nbsp;&nbsp; <BR>&nbsp;&nbsp;&nbsp; for(int i = 0; i &lt; nTables; i++) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; BYTE* pEntryData = pbFontHeader + <BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; SizeOfFixedHeader + <BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; i * SizeOfTableEntry; <BR>&nbsp;&nbsp;&nbsp; <BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DWORD dwTableTag&nbsp;&nbsp;&nbsp; = ReadTag(pEntryData + OffsetOfTableTag);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DWORD cbTableLength = ReadDword(pEntryData + OffsetOfTableLength);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Write new offset for this table.<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; WriteDword(pbFontData+<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; SizeOfFixedHeader + <BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; i * SizeOfTableEntry + <BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; OffsetOfTableOffset,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; dwRunningOffset<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; );<BR><BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //Get font data from GDI and place it into target buffer<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (GetFontData(hdc, dwTableTag, 0, pbFontData + dwRunningOffset, cbTableLength) == GDI_ERROR)&nbsp;{<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; free(pbFontHeader);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return GetLastError();<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; dwRunningOffset += cbTableLength;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Pad tables (except last) with zero's<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (i &lt; nTables - 1)&nbsp;{<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; while (dwRunningOffset&nbsp; % 4 != 0)&nbsp;{<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pbFontData[dwRunningOffset] = 0;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ++dwRunningOffset;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; } <BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<BR>&nbsp;&nbsp;&nbsp; }<BR>&nbsp;&nbsp;&nbsp; <BR>&nbsp;&nbsp;&nbsp; free(pbFontHeader);<BR>&nbsp;&nbsp;&nbsp; <BR>&nbsp;&nbsp;&nbsp; *ppvFontData&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; = pbFontData;<BR>&nbsp;&nbsp;&nbsp; *pcbFontDataSize&nbsp;&nbsp;&nbsp;&nbsp; = cbFontSize;<BR><BR>&nbsp;&nbsp;&nbsp; return S_OK;<BR>}<BR><BR>int main(int argc, WCHAR* argv[]) {<BR>&nbsp;&nbsp;&nbsp; HDC hdc = CreateCompatibleDC(0);<BR>&nbsp;&nbsp;&nbsp; <BR>&nbsp;&nbsp;&nbsp; LOGFONT lf = {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 12,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0, <BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0, <BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0, <BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; FW_NORMAL, <BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; false, <BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; false, <BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; false, <BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ANSI_CHARSET,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; OUT_DEFAULT_PRECIS, <BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; CLIP_DEFAULT_PRECIS, <BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DEFAULT_QUALITY, <BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DEFAULT_PITCH | FF_DONTCARE};<BR>&nbsp;&nbsp;&nbsp; wcscpy_s(lf.lfFaceName, sizeof(lf.lfFaceName)/sizeof(WCHAR), L"MS Gothic");<BR>&nbsp;&nbsp;&nbsp; HFONT oldfont = (HFONT)SelectObject(hdc, CreateFontIndirect(&amp;lf));<BR>&nbsp;&nbsp;&nbsp; <BR>&nbsp;&nbsp;&nbsp; void* pvFontData;<BR>&nbsp;&nbsp;&nbsp; DWORD dwFontDataSize;<BR>&nbsp;&nbsp;&nbsp; <BR>&nbsp;&nbsp;&nbsp; if (FAILED(ExtractFontDataFromTTC(hdc, &amp;dwFontDataSize, &amp;pvFontData)))&nbsp;{<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return -1;<BR>&nbsp;&nbsp;&nbsp; }<BR>&nbsp;&nbsp;&nbsp; <BR>&nbsp;&nbsp;&nbsp; printf("Font extracted: %i bytes in size", dwFontDataSize);<BR>&nbsp;&nbsp;&nbsp; <BR>&nbsp;&nbsp;&nbsp; FILE* file = fopen("font.ttf","wb");<BR>&nbsp;&nbsp;&nbsp; fwrite(pvFontData, sizeof(BYTE), dwFontDataSize, file);<BR>&nbsp;&nbsp;&nbsp; fclose(file);<BR>&nbsp;&nbsp;&nbsp; <BR>&nbsp;&nbsp;&nbsp; free(pvFontData);<BR>&nbsp;&nbsp;&nbsp; <BR>&nbsp;return 0;<BR>}</P></B></FONT></BLOCKQUOTE>
<P mce_keep="true">Very cool!</P>
<P mce_keep="true">&nbsp;</P>
<P mce_keep="true"><FONT color=#ff00ff><EM>This post brought to you by</EM> ख़ <EM>(<A class="" href="http://www.fileformat.info/info/unicode/char/0959" mce_href="http://www.fileformat.info/info/unicode/char/0959">U+0959</A>, a.k.a. DEVANAGARI LETTER KHHA)</EM></FONT></P>
<hr/><p><a id="3756181" href="#3756181">#</a> <strong>Igor</strong> on 7 Jul 2007 11:04 PM:</p><div style="margin-left: 1em"><P>Well Michael, how about using some assembler instead of all that casting, shifting and masking?</P>
<P>__declspec(naked) DWORD ReadDWord(LPBYTE p)<BR>{<BR>&nbsp;&nbsp;&nbsp; __asm {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mov edx, dword ptr [esp + 4]<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mov eax, dword ptr [edx]<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; bswap eax<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ret<BR>&nbsp;&nbsp;&nbsp; }<BR>}</P>
<P>__declspec(naked) void WriteDWord(LPBYTE p, DWORD dw)<BR>{<BR>&nbsp;&nbsp;&nbsp; __asm {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mov edx, dword ptr [esp + 4]<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mov eax, dword ptr [esp + 8]<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; bswap eax<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mov dword ptr [edx], eax<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ret<BR>&nbsp;&nbsp;&nbsp; }<BR>}</P>
<P>It is limited to 32-bit x86 (486 and up) but it is a lot cleaner and easier to read.</P></div>
<p><a id="3757025" href="#3757025">#</a> <strong>Michael S. Kaplan</strong> on 8 Jul 2007 1:23 AM:</p><div style="margin-left: 1em"><p>I don't know that it is more readable specifically, and if it won't run on x64 then over half of my Windows machines won't like it much. :-)</p>
</div>
<p><a id="3757029" href="#3757029">#</a> <strong>Michael S. Kaplan</strong> on 8 Jul 2007 1:25 AM:</p><div style="margin-left: 1em"><P>Also, I explained <STRONG><A class="" href="http://archives.miloush.net/michkap/archive/2005/05/11/416624.html">here</A></STRONG> where I gave up on inline assembler in most cases. :-)</P></div>
<hr/><p><em>go to <a id="newer" href="http://archives.miloush.net/michkap/archive/2007/07/08/3747992.html" title="UnLCMapString or LCUnMapString?">newer</a> or <a id="older" href="http://archives.miloush.net/michkap/archive/2007/07/07/3738133.html" title="We&#39;ve got a style of glyphs, yes we do; we&#39;ve got a style of glyphs, how &#39;bout you?">older</a> post, or back to <a href="http://archives.miloush.net/michkap/archive/index.html">index</a> or <a href="http://archives.miloush.net/michkap/archive/index.html#2007-07">month</a> or <a href="http://archives.miloush.net/michkap/archive/index.html#2007-07-07">day</a></em></p></body>
<!-- Mirrored from archives.miloush.net/michkap/archive/2007/07/07/3746794.html by HTTrack Website Copier/3.x [XR&CO'2014], Thu, 25 May 2017 00:42:38 GMT -->
</html>