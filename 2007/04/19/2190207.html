<html>
<!-- Mirrored from archives.miloush.net/michkap/archive/2007/04/19/2190207.html by HTTrack Website Copier/3.x [XR&CO'2014], Thu, 25 May 2017 00:42:38 GMT -->
<head><meta charset="utf-8" /><meta name="viewport" content="width=device-width" /><title>Is CharNextExA broken?</title></head><body>
<h1>Is CharNextExA broken?</h1>
<p><em>by Michael S. Kaplan, published on 2007/04/19 07:01 -04:00, original URI: http://blogs.msdn.com/b/michkap/archive/2007/04/19/2190207.aspx</em></p>
<hr/> <!-- Archival Source: ProcessPostNew -->
<P>Jochen Kalmbach asks over in the Suggestion Box:</P>
<BLOCKQUOTE>
<P><FONT face="times new roman,times"><EM>Hi Michael!</EM></FONT></P>
<P><FONT face="times new roman,times"><EM>Short question: Is "CharNextExA" broken in XP (or generally borken)?</EM></FONT></P>
<P><FONT face="times new roman,times"><EM>It does not recognize UTF8...<BR><BR>Here is a small example:</EM></FONT></P>
<P><FONT face="times new roman,times"><EM>#include &lt;windows.h&gt;<BR>#include &lt;tchar.h&gt;<BR>#include &lt;stdio.h&gt;<BR>#include &lt;string.h&gt;<BR><BR>#pragma comment(lib, "User32.lib")<BR><BR>size_t StrLenCP(WORD codepage, LPCSTR szString) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;if (szString == NULL) return 0;<BR><BR>&nbsp;&nbsp;&nbsp;&nbsp;size_t res = 0;<BR>&nbsp;&nbsp; &nbsp;LPCSTR p = szString;<BR>&nbsp;&nbsp;&nbsp;&nbsp;LPCSTR plast;<BR><BR>&nbsp;&nbsp;&nbsp;&nbsp;do&nbsp;{<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;plast = p;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;p = CharNextExA(codepage, p, 0);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;res++;<BR>&nbsp;&nbsp;&nbsp; } while(p != plast);<BR><BR>&nbsp;&nbsp;&nbsp;&nbsp;return res;<BR>}<BR><BR>int _tmain() {<BR>&nbsp;&nbsp;&nbsp;&nbsp;// "I{heart}NY"<BR>&nbsp;&nbsp;&nbsp; char str[] = {0x49, 0xE2, 0x99, 0xA5, 0x4E, 0x59, 0x00};<BR>&nbsp;&nbsp;&nbsp;&nbsp;wchar_t *szUnicode = new wchar_t[20];<BR><BR>&nbsp;&nbsp;&nbsp;&nbsp;MultiByteToWideChar(CP_UTF8, 0, str, -1, szUnicode, 20);<BR>&nbsp;&nbsp;&nbsp;&nbsp;printf("Characters (UTF16): %d\n", wcslen(szUnicode));<BR>&nbsp;&nbsp;&nbsp; printf("Characters (UTF8) : %d\n", StrLenCP(CP_UTF8, str));<BR>}<BR><BR>Greetings<BR>Jochen</EM></FONT></P></BLOCKQUOTE>
<P>I could have answered this one without the code sample. :-)</P>
<P>Neither <A class="" href="http://msdn2.microsoft.com/library/ms647470.aspx" mce_href="http://msdn2.microsoft.com/library/ms647470.aspx">CharNextExA</A> nor <A class="" href="http://msdn2.microsoft.com/library/ms647472.aspx" mce_href="http://msdn2.microsoft.com/library/ms647472.aspx">CharPrevExA</A> are broken in any version of Windows, but neither one was designed with UTF-8 in mind.</P>
<P>Remember how I talked about the way that even though NLS did not own some of these USER functions, that we pretty much "owned" them since we control their behavior, in <STRONG><A class="" href="http://archives.miloush.net/michkap/archive/2005/06/22/431394.html" mce_href="http://archives.miloush.net/michkap/archive/2005/06/22/431394.html">this post</A></STRONG>?</P>
<P>Well, this is one of those functions.</P>
<P>It is completely dependent on the behavior of <A class="" href="http://msdn2.microsoft.com/library/ms776460.aspx" mce_href="http://msdn2.microsoft.com/library/ms776460.aspx">IsDBCSLeadByteEx</A>, which is an NLS function that is (for obvious reasons) only dealing with East Asian, DBCS code pages.</P>
<P>There is code in <A class="" href="http://msdn2.microsoft.com/library/ms776460.aspx" mce_href="http://msdn2.microsoft.com/library/ms776460.aspx">IsDBCSLeadByteEx</A>&nbsp;related to UTF-8 -- but that bit of code simply returns FALSE, always.</P>
<P>So the function is behaving as it was designed back when it was ported from Windows 95, and it was only ever&nbsp;designed to handle a specific set of code pages that pre-date support of&nbsp;UTF-8 in Windows.</P>
<P>Now the big question -- would it make sense to add this support? Just like we added C3_HIGHSURROGATE and C3_LOWSURROGATE to the Vista <A class="" href="http://msdn2.microsoft.com/library/ms647481.aspx" mce_href="http://msdn2.microsoft.com/library/ms647481.aspx">GetStringTypeW</A> function?</P>
<P>And the answer is simple --&nbsp;the NLS API&nbsp;could. Though the meaning of this function when a character can contain up to four bytes is unclear -- it almost begs for a new function to be added in order to properly support the notion of these four byte characters....</P>
<P>Kind of a "lunch interview" question -- what would be required of NLS to extend support of <A class="" href="http://msdn2.microsoft.com/library/ms647470.aspx" mce_href="http://msdn2.microsoft.com/library/ms647470.aspx">CharNextExA</A>/<A class="" href="http://msdn2.microsoft.com/library/ms647472.aspx" mce_href="http://msdn2.microsoft.com/library/ms647472.aspx">CharPrevExA</A>&nbsp;in the next version of Windows?</P>
<P mce_keep="true">&nbsp;</P>
<P><FONT color=#ff00ff><EM>This post brought to you by</EM> <FONT size=6>ê†·</FONT> <EM>(<A class="" href="http://www.fileformat.info/info/unicode/char/a1b7" mce_href="http://www.fileformat.info/info/unicode/char/a1b7">U+a1b7</A>, a.k.a. YI SYLLABLE LIT)</EM></FONT></P>
<hr/><p><a id="2205939" href="#2205939">#</a> <strong>Michiel</strong> on 20 Apr 2007 7:13 AM:</p><div style="margin-left: 1em"><p>First rough solution:</p>
<p>1. IsDBCSLeadByteEx is documented as returning non-zero if it's a lead byte. Make it return the number of characters following for a lead byte. (By definition 1 for DBCS)</p>
<p>2. Update its documentation to say &quot;A lead byte is the first byte of a character sequence in a double-byte character set (DBCS) or multibyte character set (MBCS) for the code page.&quot;</p>
<p>3. CharNextExA uses the returned number of characters from IsDBCSLeadByteEx.</p>
<p>This approach takes advantage of the fact that UTF-8 was designed explicitly to determine the number of bytes in a character sequence from its lead byte.</p>
<p>CharPrevExA is harder, as IsDBCSLeadByteEx has to return 0 for both single-byte characters and the non-lead-bytes. And you can't decrement twice without risking to underrun a buffer (the caller must obviously make sure there is one preceding character, but not two). Hence, only one byte is available. If that's a single-byte character, we're done, else we search back until we find the first lead byte. The remaining problem here is determining single-byte characters.</p></div>
<hr/><p><em>referenced by</em></p><div style="margin-left: 1em"><p>2010/11/24 <a href="http://archives.miloush.net/michkap/archive/2010/11/24/10095816.html">UTF-8 on a platform whose support is overwhelmingly, almost oppressively, UTF-16</a></p><p>2007/04/29 <a href="http://archives.miloush.net/michkap/archive/2007/04/29/2322357.html">What type to use for code page values</a></p></div><p><em>go to <a id="newer" href="http://archives.miloush.net/michkap/archive/2007/04/19/2194275.html" title="Search and ye shall find, SIAO style!">newer</a> or <a id="older" href="http://archives.miloush.net/michkap/archive/2007/04/19/2185812.html" title="A picture that can&#39;t be easily described with words">older</a> post, or back to <a href="http://archives.miloush.net/michkap/archive/index.html">index</a> or <a href="http://archives.miloush.net/michkap/archive/index.html#2007-04">month</a> or <a href="http://archives.miloush.net/michkap/archive/index.html#2007-04-19">day</a></em></p></body>
<!-- Mirrored from archives.miloush.net/michkap/archive/2007/04/19/2190207.html by HTTrack Website Copier/3.x [XR&CO'2014], Thu, 25 May 2017 00:42:38 GMT -->
</html>