<html>
<!-- Mirrored from archives.miloush.net/michkap/archive/2011/07/18/10187271.html by HTTrack Website Copier/3.x [XR&CO'2014], Thu, 25 May 2017 00:42:34 GMT -->
<head><meta charset="utf-8" /><meta name="viewport" content="width=device-width" /><title>Pedantic nitpickery, turned up to 11</title></head><body>
<h1>Pedantic nitpickery, turned up to 11</h1>
<p><em>by Michael S. Kaplan, published on 2011/07/18 07:01 -04:00, original URI: http://blogs.msdn.com/b/michkap/archive/2011/07/18/10187271.aspx</em></p>
<hr/> <!-- Archival Source: ProcessPostNew -->
<p>I am an expert on some things.</p>
<p>Not all things mind you; just some things.</p>
<p>Further, I am expert on the way most things interact with the things I am expert on.</p>
<p>Not an expert on most of those things; just on the way they interact with the thing I am an expert on.</p>
<p>Up until just recently, I had been able to pretty much steer clear of a particular breed of reader -- <strong>the nitpicker</strong>.</p>
<p>This fairly insane need to make a point, even at the expense of missing the point.</p>
<p>Then on Wednesday, that all changed.</p>
<p>In <strong><a title="It's ultimately your call, but your PowerShell cmdlets really don't need to SUCK this much" href="http://archives.miloush.net/michkap/archive/2011/07/13/10185915.html">It's ultimately your call, but your PowerShell cmdlets really don't need to SUCK this much</a></strong>, I decried a terrible situation in PowerShell cmdlets.</p>
<p>A situation where, to quote myself from another, tangentially related email thread about a similar bug affecting the ISE itself:</p>
<p style="padding-left: 30px;"><em>&ldquo;The promise of the Graphical PowerShell is moving beyond the CMD boundaries, and bugs like this betray that promise&rdquo;</em></p>
<p>But, as circumstances unfolded, my contrasting of the "ISE-based PowerShell" versus the "CMD-based PowerShell" became what virtually every comment was about.</p>
<p>The fact that many people have the same (apparently incorrect) assumption about the legacy PowerShell&nbsp;being CMD-based&nbsp;is irrelevant.</p>
<p>The fact that the property sheets for the two of them look amazingly similar while the ISE's looks more like a regular app shortcut does not:</p>
<p><img src="http://msdnshared.blob.core.windows.net/media/MSDNBlogsFS/prod.evol.blogs.msdn.com/CommunityServer.Blogs.Components.WeblogFiles/00/00/00/33/81/2425.cmd01.jpg" />&nbsp;&nbsp; <img src="http://msdnshared.blob.core.windows.net/media/MSDNBlogsFS/prod.evol.blogs.msdn.com/CommunityServer.Blogs.Components.WeblogFiles/00/00/00/33/81/3443.cmd08.jpg" />&nbsp;&nbsp; <img src="http://msdnshared.blob.core.windows.net/media/MSDNBlogsFS/prod.evol.blogs.msdn.com/CommunityServer.Blogs.Components.WeblogFiles/00/00/00/33/81/5353.cmd09.jpg" /></p>
<p>And the fact that the&nbsp;main app propsheet&nbsp;for the first two (right down to the "Defaults" and "Properties" entries) also look the same while the third did not have either option or look in any way similar did not:</p>
<p><img src="http://msdnshared.blob.core.windows.net/media/MSDNBlogsFS/prod.evol.blogs.msdn.com/CommunityServer.Blogs.Components.WeblogFiles/00/00/00/33/81/4431.cmd04.jpg" />&nbsp;&nbsp; <img src="http://msdnshared.blob.core.windows.net/media/MSDNBlogsFS/prod.evol.blogs.msdn.com/CommunityServer.Blogs.Components.WeblogFiles/00/00/00/33/81/6136.cmd05.jpg" />&nbsp;&nbsp; <img src="http://msdnshared.blob.core.windows.net/media/MSDNBlogsFS/prod.evol.blogs.msdn.com/CommunityServer.Blogs.Components.WeblogFiles/00/00/00/33/81/0020.cmd10.jpg" /></p>
<p>The fact that the "Properties" and "Defaults" options for the first two that did not exist on the third at all was also not relevant:</p>
<p><img src="http://msdnshared.blob.core.windows.net/media/MSDNBlogsFS/prod.evol.blogs.msdn.com/CommunityServer.Blogs.Components.WeblogFiles/00/00/00/33/81/7065.cmd03.jpg" />&nbsp;&nbsp;&nbsp; <img src="http://msdnshared.blob.core.windows.net/media/MSDNBlogsFS/prod.evol.blogs.msdn.com/CommunityServer.Blogs.Components.WeblogFiles/00/00/00/33/81/2063.cmd02.jpg" /></p>
<p>And finally, and most relevant to the point of Unicode and complex script support, the fact that the first two behaved identically limitedly useful while the third did not was also, once again, irrelevant.</p>
<p>The only thing that was important was that I was saying that these two different things that acted just like each other, had property sheets that were the same, had right click menus that were the same and shortcuts used in consoles, or anything else, had nothing to do with CMD.EXE but instead was a CSRSS.exe/conhost.exe thing.</p>
<p>Um, okay.</p>
<p>As rjcox pointed out:</p>
<p style="padding-left: 60px;"><em>Of course a s/cmd.exe/Win32 console subsystem/ would still make sense and be more, pedantically, accurate.</em></p>
<p>In other words, there was a single mistake here to do with labeling that would make the entire post accurate. A single pedantic misapprehension on my part that has nothing important to do with the point in question.</p>
<p>Now clearly if I were billing myself as an expert on the console subsystem this would have been bad.</p>
<p>But I'm not, I'm just someone who points out bugs to experts in it to do with Unicode (ref: <strong><a title="Ā was unexpected at this time" href="http://archives.miloush.net/michkap/archive/2006/01/30/519760.html">Ā was unexpected at this time</a></strong>).</p>
<p>The same way I'm not an expert in conhost.exe but have helped fix problems and bugs in its TSF input component (contsf) compiled right into it.</p>
<p>The same way I'm not an expert in security but know more about the localizability of account names than some experts in that.</p>
<p>Or that I'm not an expert in a number of things, though in explaining how they work with Unicode or with internationalization or localizability or keyboards or whatever, I am.</p>
<p>Funny how until I got to the PowerShell experts (who were sick of dealing this CMD.EXE mistake long before they got to me) did I become such a target for pedantic nitpickery!</p>
<p>And not from team members for PowerShell, either. Or any of the other&nbsp;internal folks I've been dealing with. Perhaps since when I am talking to them I am usually helping them with an actual bug, they see no purpose or reason in correcting me on my terminology....</p>
<p>Now it would be my hope that most people will suss all of this out correctly, and recognize that not only my lack of expertise on the legacy console subsystem's pieces&nbsp;but my lack of desire to obtain expertise on the legacy console subsystem will simply keep me from finding it important to make such fine distinctions of things that behave identically and neither of which should be used when one can help it.</p>
<p><strong>All</strong> console work should happen in the PowerShell ISE, not just the cmdlet work -- since everything behaves better there.</p>
<p>A Unicode console app behaves <strong>perfectly</strong> in the ISE.</p>
<p>This fact is true whether you are hosted by CSRSS, conhost.exe, CMD.EXE, or <strong>Console Fred</strong>, or anything else. This whole collection of components that I called "CMD.EXE based" is bad whether or not what I called it was the exact right name.</p>
<p>So, will I update the blog at some point? Maybe. Given that the software behind the Blog can send trackbacks every time, I'm not especially eager to. The comment spooge is there, it just doesn't seem that important....</p>
<p>If anyone has trouble with this still, then they, like commenter Blake, should likely be excited about one less Blog in their RSS reader. This Blog is clearly unsuitable.</p>
<p>You probably shouldn't be here -- like Blake....</p>
<hr/><p><strong>Klimax</strong> on 18 Jul 2011 2:43 PM:</p><div style="margin-left: 1em"><p>I think that reason why all that happened was that your post seemed to be unfair and wrong attack on Powershell and team responsible.</p>
<p>(On second reading it seems attack is on cmdlets, whose authors may or may not be on Powershell team)</p>
<p>In the end it looks like misunderstanding escalating quickly.</p></div>
<p><strong>Michael S. Kaplan</strong> on 18 Jul 2011 3:18 PM:</p><div style="margin-left: 1em"><p>You&#39;re probably right. One could I suppose attack the PowerShell team a little -- they do have a bug here, and they have been putting out some less than great &quot;best practices&quot;. But they are fixing the bug and they are working on communicating the practices. So generally speaking I don&#39;t think they are the guilty parties here. Or if they are the restitution is well under way.</p>
<p>I was told offline that the misunderstanding (assumption that legacy PowerShell is in CMD.EXE) is pretty common, at least in part for the reasons I mention in this blog here, in part because both legacy PowerShell and CMD do have the same underlying host doing lots of the work here. And that people are pretty sensitive about trying to correct this mistake when they can (my previous PS team interactions missed this fun because no one acts that way when they&#39;re getting assistance, and previous cmdlet authors often assumed I was right anyway -- it isn&#39;t an unreasonable assumption, it just isn&#39;t true).</p>
<p>Not that it matters too much. As I said to someone earlier today: &quot;since my whole point was “don’t use it”, it’s a bit like complaining that I called something horseshit when it was really from cows. Either way I don’t want to touch it, and the article was about not touching it....&quot;</p>
<p>:-)</p>
</div>
<p><strong>Random832</strong> on 20 Jul 2011 9:07 AM:</p><div style="margin-left: 1em"><p>the blog keeps eating my comments... (I can tell when it happens, i don&#39;t get that nice green banner on the page after going to it, but by then i&#39;ve lost the text)</p>
<p>&quot;since everything behaves better there. -- A Unicode console app behaves perfectly in the ISE.&quot; Even ignoring the problem of _interactive_ console apps, it&#39;s not clear how a console application is supposed to use unicode in the ISE. Standard output is a pipe; data written to it is interpreted as OEMCP, and WriteConsole does nothing. I only tried this with a native console application - is the situation better with .NET?</p></div>
<p><strong>Michael S. Kaplan</strong> on 20 Jul 2011 9:31 AM:</p><div style="margin-left: 1em"><p>ReadConsoleW and WriteConsoleW work rather handily, and if you stick to win32 rather than the CRT, you avoid the OEMCP quite nicely!</p>
<p>They also do well with interactive apps.</p></div>
<p><strong>Simon Buchan</strong> on 20 Jul 2011 4:40 PM:</p><div style="margin-left: 1em"><p>Of course, having read the earlier post now, they were far too strong. While calling the console &quot;cmd.exe&quot; *is* wrong, it was pretty clear who you were referring to (though you *might* get the wrong team on the first call), and you semi-correctly place blame for invalid output at the cmdlet writers. Semi-correctly, because I&#39;m not actually sure that outputting in a fallback langauge is worse than outputting intellegible ? streams or simply denying output - but obviously that would depend on the purpose of the cmdlet.</p>
</div>
<p><strong>Random832</strong> on 20 Jul 2011 10:54 PM:</p><div style="margin-left: 1em"><p>Yes, they do, on both counts. In a normal console window.</p>
<p>Not so much in the ISE, though, which was kind of what I was trying to say.</p>
</div>
<p><strong>Michael S. Kaplan</strong> on 21 Jul 2011 12:51 AM:</p><div style="margin-left: 1em"><p>I have been able to get them both to work in the ISE without problems - they work just fine.</p>
</div>
<p><strong>Michael S. Kaplan</strong> on 21 Jul 2011 10:53 AM:</p><div style="margin-left: 1em"><p>Simon -- the right option is to detect what you can do correctly for the user and then do that. Always! :-)</p>
</div>
<p><strong>Random832</strong> on 23 Jul 2011 1:20 PM:</p><div style="margin-left: 1em"><p>I don&#39;t know how much more simply I can put it, other than...</p>
<p>DWORD n; WCHAR wc; HANDLE hCI, hCO; BOOL r;</p>
<p>hCO = CreateFileW(L&quot;CONOUT$&quot;, GENERIC_WRITE,FILE_SHARE_WRITE,0,OPEN_EXISTING,0,0); /* succeeds */</p>
<p>hCI = CreateFileW(L&quot;CONIN$&quot;, GENERIC_READ,FILE_SHARE_READ,0,OPEN_EXISTING,0,0); /* succeeds */</p>
<p>r = WriteConsoleW(hCO,L&quot;Hello, World!\n&quot;,14,&amp;n,0); /* No visible output, TRUE, 14. */</p>
<p>r = ReadConsoleW(hCI,&amp;wc,1,&amp;n,0); /* Does not return. */</p>
<p>Works great on the console, not so much in ISE.</p>
<p>Attempting to type in the ISE command line simply complains that there is already a command running. There are no other obvious candidates for where one would type to provide input to an interactive console program. (or where one would look for the output that is not showing up in the ISE output window).</p>
<p>Is there something I&#39;m doing that I shouldn&#39;t be doing, or something I&#39;m not doing that I should be doing?</p></div>
<p><strong>Michael S. Kaplan</strong> on 23 Jul 2011 9:45 PM:</p><div style="margin-left: 1em"><p>The trick is to use the code I have used before here that uses GetStdHandle -- it works well. Those old hacks, not so much.</p>
</div>
<p><strong>Random832</strong> on 25 Jul 2011 7:01 AM:</p><div style="margin-left: 1em"><p>The blog ate my comment again... but it was basically a repetition of what I already said: &quot;Standard output is a pipe; data written to it is interpreted as OEMCP, and WriteConsole does nothing.&quot; Did you just not believe me? Or is it that since I said WriteConsole (I had UNICODE defined, in fact) you assumed that I meant WriteConsoleA, ignoring the fact that _not displaying anything_ is just as strange behavior even for that?</p>
<p>And anyway I don&#39;t understand how other than those &quot;old hacks&quot; you&#39;re supposed to get a handle to console output when standard output **is redirected**! (and it definitely is redirected in the ISE). GetStdHandle returns redirected handle (a pipe, which the ISE reads from and displays as OEMCP), not the console.</p>
</div>
<p><strong>Random832</strong> on 25 Jul 2011 7:32 AM:</p><div style="margin-left: 1em"><p>I was finally able to get it working. WriteConsole[W] does *not* produce any output in the ISE under any circumstance. The only way that worked was to use WriteFile [with the data in UTF-8, UTF-16, or UTF-32] _and_ to explicitly write a BOM [so it doesn&#39;t get interpreted as OEMCP] before writing anything else. Using the CRT [e.g. _setmode(_O_U8TEXT)], at least in VS2010, also solves the issue on a real console and redirected files.</p>
<p>Is it possible that whatever code you got working before was taking a code path meant for redirected files when invoked from the ISE?</p>
<p>There doesn&#39;t seem to be any hope of interactive input working, whether through ReadConsole[W] or ReadFile (ReadFile works fine in a pipeline, for whatever that&#39;s worth)</p>
</div>
<p><strong>Michael S. Kaplan</strong> on 25 Jul 2011 8:04 AM:</p><div style="margin-left: 1em"><p>As I pointed out in those other posts previously, there is no single way that always works -- you need a combination of the different techniques, and then it works. Since I have posted code that *does* work -- even in the ISE -- it is now your responsibility to explain what fails for you when you run that code....</p>
</div>
<hr/><p><em>go to <a id="newer" href="http://archives.miloush.net/michkap/archive/2011/07/19/10187740.html" title="Creating things that aren&#39;t real">newer</a> or <a id="older" href="http://archives.miloush.net/michkap/archive/2011/07/16/10187196.html" title="Tweels (n) - The squeals tween tweeps make when they tweet">older</a> post, or back to <a href="http://archives.miloush.net/michkap/archive/index.html">index</a> or <a href="http://archives.miloush.net/michkap/archive/index.html#2011-07">month</a> or <a href="http://archives.miloush.net/michkap/archive/index.html#2011-07-18">day</a></em></p></body>
<!-- Mirrored from archives.miloush.net/michkap/archive/2011/07/18/10187271.html by HTTrack Website Copier/3.x [XR&CO'2014], Thu, 25 May 2017 00:42:34 GMT -->
</html>