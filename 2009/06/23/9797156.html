<html>
<!-- Mirrored from archives.miloush.net/michkap/archive/2009/06/23/9797156.html by HTTrack Website Copier/3.x [XR&CO'2014], Thu, 25 May 2017 00:42:35 GMT -->
<head><meta charset="utf-8" /><meta name="viewport" content="width=device-width" /><title>EZ fwide[R]? It ain't all that. Roll it up and smoke it, you won't get very high....</title></head><body>
<h1>EZ fwide[R]? It ain't all that. Roll it up and smoke it, you won't get very high....</h1>
<p><em>by Michael S. Kaplan, published on 2009/06/23 10:01 -04:00, original URI: http://blogs.msdn.com/b/michkap/archive/2009/06/23/9797156.aspx</em></p>
<hr/> <!-- Archival Source: ProcessPostNew -->
<p>Conformance to standards seems to be a pretty big deal these days in many different parts of Microsoft.</p>
<p>Not all, mind you -- that is something I know about through both law of averages (there are a lot of groups at Microsoft!) and also some specific knowledge (I've chatted with a few of them now and again).<br></p>
<p>But by and large if there is a standard related to the work people are doing at the company, then there is some degree of effort to conform. A statistically significaant trend, you might say.<br></p>
<p>I was thinking about this other day when people were having kind of a conversation about the C runtime <b><a href="http://msdn.microsoft.com/library/aa985619.aspx" mce_href="http://msdn.microsoft.com/library/aa985619.aspx">fwide</a></b> function.</p>
<p>The documentation is something like this:</p>
<blockquote>
<p><b>Run-Time Library Reference</b><br></p>
<blockquote><b>fwide</b></blockquote><blockquote><blockquote>Unimplemented. </blockquote></blockquote><blockquote><b><font face="consolas,courier new,courier">int fwide(<br>&nbsp;&nbsp; FILE *stream,<br>&nbsp;&nbsp; int mode;<br>); </font></b><br></blockquote>
<blockquote><b>Parameters</b></blockquote><blockquote><blockquote><i>stream</i><br>Pointer to FILE structure (ignored). <br><br><i>mode</i><br>The new width of the stream: positive for wide character, negative for byte, zero to leave unchanged. (This value is ignored.) <br><br></blockquote></blockquote><blockquote><b>Return Value</b></blockquote><blockquote><blockquote>This function currently just returns mode. <br></blockquote><b>Remarks</b> <br><blockquote>The current version of this function does not comply with the Standard.&nbsp; <br></blockquote></blockquote>
</blockquote>
<p>Okay, it is being kind of upfront here on the whole conformance issue.<br></p><p>The documentation hints that this function basically returns whatever it is passed in the <i>mode</i> parameter, so I'll be clear and say that is exactly what it is doing.</p><p><i>Of course this makes the claim that the <b>mode</b> parameter is ignored kind of inaccurate -- it lives and dies by that parameter, but we'll let that slide.</i></p><p>Let's look at the standard itself to see what conformance would mean, what it would look like. It is over in C99, a standard that Microsoft has taken around the dancefloor but not yet gotten fully busy with just yet:<br></p><blockquote><p><b>7.24.3.5 The fwide function</b><br><br>int fwide(FILE *stream, int mode);<br><br>The fwide function determines the orientation of the stream pointed to by <i>stream</i>. If mode is greater than zero, the function first attempts to make the stream wide oriented. If mode is less than zero, the function first attempts to make the stream byte oriented.Otherwise, mode is zero and the function does not alter the orientation of the stream.<br><br><b>Returns</b><br>The fwide function returns a value greater than zero if, after the call, the stream has wide orientation, a value less than zero if the stream has byte orientation, or zero if the stream has no orientation. <br></p></blockquote><p>This is rather vague -- either Microsoft's implementation is mostly right <b>or</b> the standard is saying this:</p><ul><li>If mode &gt; 0, try to make it wide (return 0 on failure);<br></li><li>If mode &lt; 0, try to make it narrow (return 0 on failure)</li><li>If mode is 0, try to detect whether it is a wide stream or not and return the results  (return 0 on failure).</li></ul><p>I could spend a little bit of time discussing how fundamentally useless this function would be even if this is the meaning and it were fully conformant; this seems like an important point. But we'll leave it alone for a moment and get back to this point in a bit.</p><p>Now the fundamental issue here is that Microsoft's implementation of the file stream does not store any kind of attribute on it indicating its wideness or lack thereof. This is important as it means all the information about trying to change this attribute on a stream is not going to happen. In the words of Yoda: </p><blockquote><p>"There is do, and not do; there is no Try."</p></blockquote><p>In this case, Microsoft improves on Yoda a bit -- there is no "not do" either. :-)</p><p>Now if you passed &lt;0 or &gt;0 then you wanted the function to try to do something, and it is returning that it succeeded. This does meet the letter of the law in regards to conformance but obviously violates the spirit since if you call the function once you might reasonably expect the call to impact what will happen later. And it won't.</p><p>And if you passed 0, then you didn't want the function to change anything, you were just asking a question. The Microsoft explanation just answers the question with the same value that means "who knows?".</p><p>It is probably just as well that the docs claim the function is unimplemented since by any sort of reasonable man standard it is probably not implemented.</p><p>Would it be nice if you could write to/read from the stream using whatever functions you wanted (wide or narrow) and have it automatically do conversions to follow the behavior of <b>fwide</b>? Maybe. I tend to hate behavior that will silently but happily do a ton of conversion work that may not be required. But I can't claim that there aren't people who would find it useful.</p><p>Irregardless, at this time it is not out there, so the results shouldn't be expected to conform.</p><p>Now clearly conformance is, on the whole, a good thing. But one would be hard put to claim with authority that the lack of rush to support the standard for this one case would be likely to hurt anyone.</p><p>Does anyone disagree?</p><p>I mean, based on practical reasons, not lofty "it's the standard" type reasons, of course....<br></p>
<hr/><p><strong>John Cowan</strong> on 23 Jun 2009 5:51 PM:</p><div style="margin-left: 1em"><p>I don't think your equation of 0 with failure is correct. &nbsp;In particular, suppose a model where (a) streams are either narrow or wide, (b) a narrow stream can be widened only if nothing has been read from/written to it, and (c) a wide stream can't be narrowed at all (because of buffering issues, say). &nbsp;In that case, fwide(wideStream, -1) should return 1, not 0, and fwide(narrowStream, 1) might return either 1 or -1, but in no case 0.</p>
<p>The Microsoft model seems to be one in which streams never have any orientation. &nbsp;Therefore, an attempt to widen does nothing and returns 0 (not oriented); an attempt to narrow does nothing and returns 0 (not oriented), and a query returns 0 (not oriented). &nbsp;In short, the correct implementation is "int fwide(FILE *stream, int mode) { return 0; }". &nbsp;Go forth and fix it.</p></div>
<p><strong>Mihai</strong> on 23 Jun 2009 6:37 PM:</p><div style="margin-left: 1em"><p>This looks like a work-around for something that I have seen the Linux world (UNIX? POSIX?): once you write something stream-oriented to a file, it gets set to that and does not accept output any other way.</p>
<p>This is kind of disconcerting when you see it first:</p>
<p> &nbsp; &nbsp;wprintf( L"Hello wide world" );</p>
<p> &nbsp; &nbsp;printf( "Hello narrow world" );</p>
<p>You will only see the first message (and all the other messages that use "wide APIs"), while the narrow ones get discarded.</p>
<p>As a solution, adding another a "wideness status" to a stream looks very clunky to me. A bit of a repeat of the text/binary file distinction in the MS-DOS/Windows world which makes all the POSIX world yell "bloody murder" :-)</p></div>
<p><strong>Michael S. Kaplan</strong> on 23 Jun 2009 7:43 PM:</p><div style="margin-left: 1em"><p>John, not sure I understand what you are saying here. Since it never technically does in fact fail, changing to what you are asking for would break callers for no reason!</p>
</div>
<p><strong>Mike Dimmick</strong> on 24 Jun 2009 6:11 AM:</p><div style="margin-left: 1em"><p>DevDiv's position on C99 is that C is completely superseded by C++, and that the target is C++0x conformance (hey, they'll get to full C++98 eventually). C99 falls under the heading of 'too late'.</p>
<p>I think, though, that it must have been in an earlier version of the C standard as it's been in the MS runtime at least as far back as VS 6.0! Possibly Amendment 1 of ISO 9899:1990, since I think this is where wide character APIs were first standardised.</p>
<p>If John's point is correct about the wide vs byte-oriented APIs working or not on other systems, then arguably fwide's behaviour is correct: both sets of APIs work on any stream, and it may well be better to say 'yes that set of APIs will now work' than to say 'I couldn't do that'.</p>
<p>Unfortunately it looks like 9899:1990 is no longer available from the ANSI standards store, only the 1999 version.</p></div>
<p><strong>Pinky</strong> on 24 Jun 2009 7:16 AM:</p><div style="margin-left: 1em"><p>&quot;Conformance to standards seems to be a pretty big deal these days in many different parts of Microsoft.&quot;</p>
<p>I wish I'd known this was going to be a comedy post; I've just spat coffee all over my monitor.</p></div>
<p><strong>John Cowan</strong> on 25 Jun 2009 3:57 PM:</p><div style="margin-left: 1em"><p>Okay, less compactly:</p>
<p>Returning 0 from fwide() does not mean failure.</p>
<p>I repeat, returning 0 from fwide() does not mean failure.</p>
<p>It means that the stream has no orientation.</p>
<p>Microsoft streams have no orientation, no matter what orientation you try to set.</p>
<p>Therefore, fwide() should return 0.</p>
<p>The current implementation of fwide() is grossly inconsistent. &nbsp;For example, if you call fwide(s, 1) to set a stream to wide-oriented, it returns 1 to indicate that the stream is now wide-oriented. &nbsp;But if you ask for its orientation with fwide(s, 0), it returns 0, which means the stream has no orientation! &nbsp;(Same story for -1, of course.)</p>
<p>There are no wide-oriented streams.</p>
<p>There are no byte-oriented streams.</p>
<p>There are only streams with no orientation.</p>
<p>fwide() should always return 0.</p></div>
<p><strong>Michael S. Kaplan</strong> on 25 Jun 2009 10:14 PM:</p><div style="margin-left: 1em"><p>I prefer the "weak-minded function, susceptible to the Jedi Mind Trick" explanation:</p>
<ul><li>Function is told the stream is wide, it agrees and says it's wide.</li><li>Function is told the stream is narrow, it agrees and says it's narrow.</li><li>Function is told the stream width is unknown, it agrees and says it's unknown.</li></ul>


<p>The fwideEx function will also take you to Jabba now....</p></div>
<hr/><p><em>go to <a id="newer" href="http://archives.miloush.net/michkap/archive/2009/06/25/9803395.html" title="Where do you want to go today^H^H^Hmorrow with MUI?">newer</a> or <a id="older" href="http://archives.miloush.net/michkap/archive/2009/06/18/9773077.html" title="Those keys aren&#39;t going to be extended; they&#39;re dead!">older</a> post, or back to <a href="http://archives.miloush.net/michkap/archive/index.html">index</a> or <a href="http://archives.miloush.net/michkap/archive/index.html#2009-06">month</a> or <a href="http://archives.miloush.net/michkap/archive/index.html#2009-06-23">day</a></em></p></body>
<!-- Mirrored from archives.miloush.net/michkap/archive/2009/06/23/9797156.html by HTTrack Website Copier/3.x [XR&CO'2014], Thu, 25 May 2017 00:42:35 GMT -->
</html>