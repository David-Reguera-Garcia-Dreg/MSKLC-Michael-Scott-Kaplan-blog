<html>
<!-- Mirrored from archives.miloush.net/michkap/archive/2009/07/20/9840848.html by HTTrack Website Copier/3.x [XR&CO'2014], Thu, 25 May 2017 00:42:35 GMT -->
<head><meta charset="utf-8" /><meta name="viewport" content="width=device-width" /><title>Garbage in, garbage out -- and this means Ü!</title></head><body>
<h1>Garbage in, garbage out -- and this means Ü!</h1>
<p><em>by Michael S. Kaplan, published on 2009/07/20 10:01 -04:00, original URI: http://blogs.msdn.com/b/michkap/archive/2009/07/20/9840848.aspx</em></p>
<hr/> <!-- Archival Source: ProcessPostNew -->
<p>So the other day a colleague over in C++-ville forwarded a bug report he was looking at, one he wanted my thoughts about.</p>
<p>It went something like this:</p>
<blockquote>
<p><font face="times new roman,times">Repro Steps:<br>+ Change language in Control Panel under "Regional an Language Options" tab "Advanced" to Japanese<br>+ Make new c++ console project with MFC support<br>+ Change Character set to Multi-Byte (_MBCS)<br>+ Compile folowing Code (0xFC =&gt; "ü"):</font><br><b><font face="consolas,lucida console,courier new,courier"><br>&nbsp;&nbsp;&nbsp; char* test= "\xfc";<br>&nbsp;&nbsp;&nbsp; CString tt;<br>&nbsp;&nbsp;&nbsp; tt = test;<br>&nbsp;&nbsp;&nbsp; tt.MakeUpper();</font></b><br><br><font face="times new roman,times">+ Run or Debug the program =&gt; Crashes when MakeUpper() is called. </font><br></p>
</blockquote>
<p>The result of running this code, as the last step mentions, is a crash in the "Microsoft Visual C++ Debug Library".</p><p>Obviously, the question was whether this was a bug....</p><p>Now one of the cool things about the CRT, MFC, and ATL from the developer's point of view is that you don't have to take my word for it, you can look at the source if you don't believe me! </p><p>In this case, CStringA's <b>MakeUpper</b> function calls an internal function <b>StringUppercase</b> that calls (when non-Unicode data is passed) <a href="http://msdn.microsoft.com/library/ms647474.aspx" mce_href="http://msdn.microsoft.com/library/ms647474.aspx">CharUpperA</a> or <a href="http://msdn.microsoft.com/library/ms647475.aspx" mce_href="http://msdn.microsoft.com/library/ms647475.aspx">CharUpperBuffA</a> -- in this case I think <a href="http://msdn.microsoft.com/library/ms647474.aspx" mce_href="http://msdn.microsoft.com/library/ms647474.aspx">CharUpperA</a>. These functions both call <a href="http://msdn.microsoft.com/library/dd318700.aspx" mce_href="http://msdn.microsoft.com/library/dd318700.aspx">LCMapString</a> eventually, after some convolutions of their own....<br></p><p>But the important point is the</p><blockquote><p><font size="5"><b>0xFC =&gt; "ü"</b></font> <br></p></blockquote><p>claim in the repro steps.</p><p>This is very true in <a href="http://msdn.microsoft.com/goglobal/cc305145.aspx" mce_href="http://msdn.microsoft.com/goglobal/cc305145.aspx">Windows code page 1252</a>, but since the steps require changing the default system locale to be Japanese, the code is running with <a href="http://msdn.microsoft.com/goglobal/cc305152.aspx" mce_href="http://msdn.microsoft.com/goglobal/cc305152.aspx">Windows code page 932</a>.</p><p>And on that code page, 0xFC is not LATIN SMALL LETTER U WITH DIAERESIS; it is a valid lead byte that is used for <a href="http://www.microsoft.com/globaldev/reference/dbcs/932/932_FC.mspx" mce_href="http://www.microsoft.com/globaldev/reference/dbcs/932/932_FC.mspx">the following potential trail bytes</a>.</p><p>So now we see what is happening.</p><p>Since a legal lead byte was found, the assumption is that a legal trail byte will follow. And when that attempt to access the non-existent trail byte happens, a crash occurs.</p><p>So whose bug would it be?</p><ul><li>In the Japanese Microsoft subsidiary, there is a definite preference for meaningful data, and a serious paucity of people doing non-Unicode data on any code page other than 932. So for them this a "garbage in, garbage out" bug and by design;</li><li>At the NLS level, the thoughts are similar, though there are nuances (skip two bullet points to see what I mean);<br></li><li>At the "USER" level, there is not much serious thought, mainly because even though NLS doesn't "own" those functions, they do own the functionality, <b><a href="http://archives.miloush.net/michkap/archive/2005/06/22/431394.html" mce_href="http://archives.miloush.net/michkap/archive/2005/06/22/431394.html">something I talked about rears ago</a></b>, and though there is some code here its bugs are almost invariably caused by either what they call or what calls them;<br></li><li>At the "ATLMFC" level, the StringUpperCase overload that calls <a href="http://msdn.microsoft.com/library/ms647474.aspx" mce_href="http://msdn.microsoft.com/library/ms647474.aspx">CharUpperA</a> has a deprecation assert on it since no buffer size is being passed and there is a good faith basis for functions below it to assume one more byte needs to be read under the circumstances, and the <a href="http://msdn.microsoft.com/library/ms647475.aspx" mce_href="http://msdn.microsoft.com/library/ms647475.aspx">CharUpperBuffA</a>-calling overload would be getting a buffer size that is either incorrect or that is being ignored by the NLS function. So either this is an ATLMFC bug for setting up a one byte buffer overrun or an NLS bug for doing a one byte buffer overrun (I suspect the former, fwiw, and not a "bug" but kind of the very reason the function is deprecated!);</li><li>At the customer level, it is a true "garbage in, garbage out" bug based on an incorrect assumption about code pages and definite proof of one of the many benefits of using Unicode!</li></ul>Sorting out what should be changed/fixed or if anything should be is something I'll leave to the owners to track down.... :-)<br>
<hr/><p><strong>John Cowan</strong> on 20 Jul 2009 8:36 PM:</p><div style="margin-left: 1em"><p>If a system function causes a user program to crash when the user passes in bad data, the answer is: It's Microsoft's fault.</p></div>
<p><strong>Michael S. Kaplan</strong> on 21 Jul 2009 2:54 AM:</p><div style="margin-left: 1em"><p>Um, okay.</p>
<p>But as I went to some length to explain, there are a lot of potential places to look here -- notice that even if you are right, there are three groups across two divisions involved.</p>
<p>Sure I can blame Google if there is a bug in a Google product. But I doubt that the investigative process within Google wouldn't be a bit more granular in its determination of where the bug might lie, or that a blog post (were someone to be as forthcoming about it as I have been) would not do the same....</p>
</div>
<p><strong>Tim Greenwood</strong> on 22 Jul 2009 11:33 AM:</p><div style="margin-left: 1em"><p>If we were discussing an end user application that crashed when given bad data then John would be correct. The author of the application would be at fault. But this is incorrect data being passed to a low level programming function. Complaining about a crash here is analogous to complaining about a segmentation error if I wrote</p>
<p>int *pa=0;</p>
<p>(*pa)++;</p></div>
<p><strong>Random832</strong> on 9 Aug 2009 11:56 PM:</p><div style="margin-left: 1em"><p>Of course, the opposite assumption to the NLS one (that a lead byte is always followed by a trail byte) is a somewhat widespread C/C++ assumption - i.e. a zero byte (or a zero WCHAR) ends a string, full stop.</p>
<p>Which is probably where the ATLMFC people are coming from.</p>
<p>An you did mix up one thing - reading the byte after \xfc (i.e. the non-existent trail byte) is fine - that's what it's there for, it's the string terminator. It's reading (and/or writing) the byte after that, and so on until encountering another zero that _isn't_ preceded by a lead byte, because it missed the real null terminator because it skipped over it thinking it was a trail byte, that is the problem.</p>
<p>Ultimately it depends on whether a buffer containing { 0xFC, 0x00 } is a valid &quot;null-terminated string&quot;. If it is, then the bug is in CharUpperA (and would be in any length-determining function that would not always return 1 on this buffer)</p></div>
<p><strong>Michael S. Kaplan</strong> on 11 Aug 2009 12:40 PM:</p><div style="margin-left: 1em"><p>Some follow-up thoughts and the actual cause <b><a href="http://archives.miloush.net/michkap/archive/2009/08/11/9864576.html">here</a></b>...</p></div>
<hr/><p><em>referenced by</em></p><div style="margin-left: 1em"><p>2009/08/11 <a href="http://archives.miloush.net/michkap/archive/2009/08/11/9864576.html">On the nonubiquitousness of Ü</a></p></div><p><em>go to <a id="newer" href="http://archives.miloush.net/michkap/archive/2009/07/21/9843391.html" title="No disassemble #5! Redux">newer</a> or <a id="older" href="http://archives.miloush.net/michkap/archive/2009/07/13/9831700.html" title="Anything still wrong is probably wrong for good....">older</a> post, or back to <a href="http://archives.miloush.net/michkap/archive/index.html">index</a> or <a href="http://archives.miloush.net/michkap/archive/index.html#2009-07">month</a> or <a href="http://archives.miloush.net/michkap/archive/index.html#2009-07-20">day</a></em></p></body>
<!-- Mirrored from archives.miloush.net/michkap/archive/2009/07/20/9840848.html by HTTrack Website Copier/3.x [XR&CO'2014], Thu, 25 May 2017 00:42:35 GMT -->
</html>