<html>
<!-- Mirrored from archives.miloush.net/michkap/archive/2009/01/07/9287052.html by HTTrack Website Copier/3.x [XR&CO'2014], Thu, 25 May 2017 00:42:35 GMT -->
<head><meta charset="utf-8" /><meta name="viewport" content="width=device-width" /><title>Someone please detect if there's a BOM before the plane takes off!</title></head><body>
<h1>Someone please detect if there's a BOM before the plane takes off!</h1>
<p><em>by Michael S. Kaplan, published on 2009/01/07 10:01 -05:00, original URI: http://blogs.msdn.com/b/michkap/archive/2009/01/07/9287052.aspx</em></p>
<hr/> <!-- Archival Source: ProcessPostNew -->
<p>One can really never get enough of puns about the BOM (Byte Order Mark) and TSA.</p><p>And when I say one, I mean I. :-)</p><p>Just think back to blogs like <b><a href="http://archives.miloush.net/michkap/archive/2008/07/26/8776572.html" mce_href="http://archives.miloush.net/michkap/archive/2008/07/26/8776572.html">Don't sneak a BOM in on someone who promises to ignore free space</a></b> or <b><a href="http://archives.miloush.net/michkap/archive/2008/05/19/8518545.html" mce_href="http://archives.miloush.net/michkap/archive/2008/05/19/8518545.html">Everyone seems averse to the BOM these days; Should we blame TSA? :-)</a></b> or <b><a href="http://archives.miloush.net/michkap/archive/2007/12/11/6726647.html" mce_href="http://archives.miloush.net/michkap/archive/2007/12/11/6726647.html">How to get yourself imprisoned [by/for talking about Unicode]</a></b>.</p><p>See what I mean?</p><p>I was reminded of this when Pritam asked:</p><blockquote><p><font face="times new roman,times">Is there any tool or code available to verify Byte Order Mark signature in XML files?</font></p></blockquote><p>Of course sniffing out a few bytes is easy enough. Abhinaba provided the full chart of valid BOM values:</p><table class="MsoNormalTable" border="1" cellpadding="0" cellspacing="0">
<tbody>
<tr>
<td style="padding: 1.5pt; width: 50%;" width="50%">
<p class="MsoNormal" style="text-align: center;" align="center"><b><span style="font-size: 12pt; color: black; font-family: 'Arial','sans-serif';">Bytes<o:p></o:p></span></b></p></td>
<td style="padding: 1.5pt; width: 50%;" width="50%">
<p class="MsoNormal" style="text-align: center;" align="center"><b><span style="font-size: 12pt; color: black; font-family: 'Arial','sans-serif';">Encoding 
Form<o:p></o:p></span></b></p></td></tr>
<tr>
<td style="padding: 1.5pt; background: rgb(255, 255, 254) none repeat scroll 0% 0%; -moz-background-clip: -moz-initial; -moz-background-origin: -moz-initial; -moz-background-inline-policy: -moz-initial; width: 50%;" width="50%">
<p class="MsoNormal"><span style="font-size: 12pt; color: black; font-family: 'Arial','sans-serif';">00 00 
FE FF<o:p></o:p></span></p></td>
<td style="padding: 1.5pt; background: rgb(255, 255, 254) none repeat scroll 0% 0%; -moz-background-clip: -moz-initial; -moz-background-origin: -moz-initial; -moz-background-inline-policy: -moz-initial; width: 50%;" width="50%">
<p class="MsoNormal"><span style="font-size: 12pt; color: black; font-family: 'Arial','sans-serif';">UTF-32, 
big-endian<o:p></o:p></span></p></td></tr>
<tr>
<td style="padding: 1.5pt; background: rgb(255, 255, 254) none repeat scroll 0% 0%; -moz-background-clip: -moz-initial; -moz-background-origin: -moz-initial; -moz-background-inline-policy: -moz-initial; width: 50%;" width="50%">
<p class="MsoNormal"><span style="font-size: 12pt; color: black; font-family: 'Arial','sans-serif';">FF FE 
00 00<o:p></o:p></span></p></td>
<td style="padding: 1.5pt; background: rgb(255, 255, 254) none repeat scroll 0% 0%; -moz-background-clip: -moz-initial; -moz-background-origin: -moz-initial; -moz-background-inline-policy: -moz-initial; width: 50%;" width="50%">
<p class="MsoNormal"><span style="font-size: 12pt; color: black; font-family: 'Arial','sans-serif';">UTF-32, 
little-endian<o:p></o:p></span></p></td></tr>
<tr>
<td style="padding: 1.5pt; background: rgb(255, 255, 254) none repeat scroll 0% 0%; -moz-background-clip: -moz-initial; -moz-background-origin: -moz-initial; -moz-background-inline-policy: -moz-initial; width: 50%;" width="50%">
<p class="MsoNormal"><span style="font-size: 12pt; color: black; font-family: 'Arial','sans-serif';">FE 
FF<o:p></o:p></span></p></td>
<td style="padding: 1.5pt; background: rgb(255, 255, 254) none repeat scroll 0% 0%; -moz-background-clip: -moz-initial; -moz-background-origin: -moz-initial; -moz-background-inline-policy: -moz-initial; width: 50%;" width="50%">
<p class="MsoNormal"><span style="font-size: 12pt; color: black; font-family: 'Arial','sans-serif';">UTF-16, 
big-endian<o:p></o:p></span></p></td></tr>
<tr>
<td style="padding: 1.5pt; background: rgb(255, 255, 254) none repeat scroll 0% 0%; -moz-background-clip: -moz-initial; -moz-background-origin: -moz-initial; -moz-background-inline-policy: -moz-initial; width: 50%;" width="50%">
<p class="MsoNormal"><span style="font-size: 12pt; color: black; font-family: 'Arial','sans-serif';">FF 
FE<o:p></o:p></span></p></td>
<td style="padding: 1.5pt; background: rgb(255, 255, 254) none repeat scroll 0% 0%; -moz-background-clip: -moz-initial; -moz-background-origin: -moz-initial; -moz-background-inline-policy: -moz-initial; width: 50%;" width="50%">
<p class="MsoNormal"><span style="font-size: 12pt; color: black; font-family: 'Arial','sans-serif';">UTF-16, 
little-endian<o:p></o:p></span></p></td></tr>
<tr>
<td style="padding: 1.5pt; background: rgb(255, 255, 254) none repeat scroll 0% 0%; -moz-background-clip: -moz-initial; -moz-background-origin: -moz-initial; -moz-background-inline-policy: -moz-initial; width: 50%;" width="50%">
<p class="MsoNormal"><span style="font-size: 12pt; color: black; font-family: 'Arial','sans-serif';">EF BB 
BF<o:p></o:p></span></p></td>
<td style="padding: 1.5pt; background: rgb(255, 255, 254) none repeat scroll 0% 0%; -moz-background-clip: -moz-initial; -moz-background-origin: -moz-initial; -moz-background-inline-policy: -moz-initial; width: 50%;" width="50%">
<p class="MsoNormal"><span style="font-size: 12pt; color: black; font-family: 'Arial','sans-serif';">UTF-8<o:p></o:p></span></p></td></tr></tbody></table><p>Easy, right?</p><p>Okay, anyone want to make a try at writing the minimal code BOM detector?</p><p>Think of it as a way to play your part in airport security!</p><p>Points awarded for clearest, or for most concise, or for briefest, or for most clever, or for the sake of maintainability, most smart.</p><p>If you can write something able to handle other, non-standard byte orderings of data, then you probably went to Cal Tech! :-)<br></p><p><br></p><p><i><font color="#ff00ff">This post brought to you by <a href="http://www.fileformat.info/info/unicode/char/feff" class="" mce_href="http://www.fileformat.info/info/unicode/char/feff">U+feff</a>, aka 
ZERO WIDTH NO-BREAK SPACE)</font></i> <br></p>
<hr/><p><a id="9288800" href="#9288800">#</a> <strong>Josh</strong> on 7 Jan 2009 1:00 PM:</p><div style="margin-left: 1em"><p>wait...which plane? BMP? SMP? SIP? TIP? SSP?</p>
<p>Sorry, I have nothing else useful to contribute here, though I'm a little surprised this problem isn't solved already...?!?</p></div>
<p><a id="9290335" href="#9290335">#</a> <strong>John Cowan</strong> on 7 Jan 2009 4:17 PM:</p><div style="margin-left: 1em"><p>See <a rel="nofollow" target="_new" href="http://recycledknowledge.blogspot.com/2005/07/hello-i-am-xml-encoding-sniffer.html">http://recycledknowledge.blogspot.com/2005/07/hello-i-am-xml-encoding-sniffer.html</a> for a formal English description of what you have to do to play in the Appendix F leagues.</p></div>
<p><a id="9293799" href="#9293799">#</a> <strong>ReallyEvilCanine</strong> on 8 Jan 2009 12:00 AM:</p><div style="margin-left: 1em"><p>Mike, you're the only person I know of who pronounces &quot;bee-oh-em&quot; as a word. Cakemakers and codebreakers have every right to say &quot;bomb/bombe&quot; but not we I18Ners.</p></div>
<p><a id="9294265" href="#9294265">#</a> <strong>Michael S. Kaplan</strong> on 8 Jan 2009 12:58 AM:</p><div style="margin-left: 1em"><p>Dude, you lead a sheltered life. In Unicode and related standards circles, in i18n conversations with developers at Adobe, Apple, IBM, Google, and Microsoft -- it is pronounced as a single word all the time....</p>
</div>
<p><a id="9301145" href="#9301145">#</a> <strong>Maurits [MSFT]</strong> on 8 Jan 2009 8:58 PM:</p><div style="margin-left: 1em"><p>Here's my approach:</p>
<p>enum BOM {</p>
<p>	BOM_NONE,</p>
<p>	BOM_UTF8,</p>
<p>	BOM_UTF16LE,</p>
<p>	BOM_UTF16BE,</p>
<p>	BOM_UTF32BE,</p>
<p>	BOM_UTF32LE,</p>
<p>};</p>
<p>HRESULT BOMFromStream(Byte pbBytes[], UINT cbLength, BOM *pBOM) {</p>
<p>	if (NULL == pbBytes || NULL == pBOM) {</p>
<p>		return E_POINTER;</p>
<p>	}</p>
<p>	// need at least two bytes for UTF16 BOMs</p>
<p>	if (cbLength &gt;= 2) {</p>
<p>		if (0xFE == pbBytes[0] &amp;&amp; 0xFF == pbBytes[1]) {</p>
<p>			*pBOM = BOM_UTF16BE;</p>
<p>			return S_OK;</p>
<p>		}</p>
<p>		if (0xFF == pbBytes[0] &amp;&amp; 0xFE == pbBytes[1]) {</p>
<p>			*pBOM = BOM_UTF16LE;</p>
<p>			return S_OK;</p>
<p>		}</p>
<p>	}</p>
<p>	// need at least three bytes for UTF8 BOM</p>
<p>	if (</p>
<p>		cbLength &gt;= 3 &amp;&amp;</p>
<p>		0xEF == pbBytes[0] &amp;&amp;</p>
<p>		0xBB == pbBytes[1] &amp;&amp;</p>
<p>		0xBF == pbBytes[2]</p>
<p>	) {</p>
<p>		*pBOM = BOM_UTF8;</p>
<p>		return S_OK;</p>
<p>	}</p>
<p>	// need at least four bytes for UTF32 BOMs</p>
<p>	if (cbLength &gt;= 4) {</p>
<p>		if (</p>
<p>			0 == pbBytes[0] &amp;&amp;</p>
<p>			0 == pbBytes[1] &amp;&amp;</p>
<p>			0xFE == pbBytes[2] &amp;&amp;</p>
<p>			0xFF == pbBytes[3]</p>
<p>		) {</p>
<p>			*pBOM = BOM_UTF32BE;</p>
<p>			return S_OK;</p>
<p>		}</p>
<p>		if (</p>
<p>			0xFF == pbBytes[0] &amp;&amp;</p>
<p>			0xFE == pbBytes[1] &amp;&amp;</p>
<p>			0 == pbBytes[2] &amp;&amp;</p>
<p>			0 == pbBytes[3]</p>
<p>		) {</p>
<p>			*pBOM = BOM_UTF32LE;</p>
<p>			return S_OK;</p>
<p>		}		</p>
<p>	}</p>
<p>	// if we made it this far there's no recognizable BOM</p>
<p>	*pBOM = BOM_NONE;</p>
<p>	return S_OK;</p>
<p>}</p>
<p>Possible future additional features: sanity check UTF16 byte stream length is even, UTF32 is divisible by 4; advance byte stream by length of BOM.</p></div>
<p><a id="9302298" href="#9302298">#</a> <strong>Peter Ibbotson</strong> on 9 Jan 2009 12:56 PM:</p><div style="margin-left: 1em"><p>I've had a quick stab in C# I've put a longer version that does appendix F (also a port to C for byte counting purposes) on my blog here:</p>
<p><a rel="nofollow" target="_new" href="http://www.ibbotson.co.uk/peteri/index.php?/archives/120-Finding-the-BOM.html">http://www.ibbotson.co.uk/peteri/index.php?/archives/120-Finding-the-BOM.html</a></p>
<p>public enum Encoding</p>
<p>{</p>
<p> &nbsp; &nbsp;Unknown = 0, BomBigEndianUcs4, BomUcs4, BomUtf8,</p>
<p> &nbsp; &nbsp;BomUtf16, BomBigEndianUtf16</p>
<p>}</p>
<p>// We use Bit 3 as a end of data marker, true means end</p>
<p>// bit 5 happens to be same value as bit 3</p>
<p>private static byte[] matchData =</p>
<p> &nbsp; &nbsp;{</p>
<p> &nbsp; &nbsp; &nbsp; &nbsp;0x00,0x00,0xF6,0xFF, &nbsp; &nbsp;// &nbsp;0- 00 00 FE FF Bom UCS4 Big endian</p>
<p> &nbsp; &nbsp; &nbsp; &nbsp;0xF7,0xF6,0x00,0x08, &nbsp; &nbsp;// &nbsp;4- FF FE 00 00 Bom UCS4 Little endian</p>
<p> &nbsp; &nbsp; &nbsp; &nbsp;0xE7,0xB3,0xBF, &nbsp; &nbsp; &nbsp; &nbsp; // &nbsp;8- EF BB BF &nbsp; &nbsp;Bom UTF8 </p>
<p> &nbsp; &nbsp; &nbsp; &nbsp;0xF7,0xFE, &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;// 12 - FF FE &nbsp; &nbsp; &nbsp;Bom UTF16 Little endian</p>
<p> &nbsp; &nbsp; &nbsp; &nbsp;0xF6,0xFF &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; // 14 - FE FF &nbsp; &nbsp; &nbsp;Bom UTF16 Big endian</p>
<p> &nbsp; &nbsp;};</p>
<p>public static Encoding DetectType(byte[] data)</p>
<p>{</p>
<p> &nbsp; &nbsp;int i = 0;</p>
<p> &nbsp; &nbsp;int offset = 0;</p>
<p> &nbsp; &nbsp;Encoding currentEncoding = Encoding.BomBigEndianUcs4;</p>
<p> &nbsp; &nbsp;while (i &lt; matchData.Length)</p>
<p> &nbsp; &nbsp;{</p>
<p> &nbsp; &nbsp; &nbsp; &nbsp;byte compare = (byte)((matchData[i] &amp; 0xf7) | ((matchData[i] &amp; 0x20) &gt;&gt; 2));</p>
<p> &nbsp; &nbsp; &nbsp; &nbsp;if ((offset &gt;= data.Length) || (data[offset] != compare))</p>
<p> &nbsp; &nbsp; &nbsp; &nbsp;{</p>
<p> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;offset = 0;</p>
<p> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;while ((matchData[i] &amp; 0x08) == 0) i++;</p>
<p> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;currentEncoding++;</p>
<p> &nbsp; &nbsp; &nbsp; &nbsp;}</p>
<p> &nbsp; &nbsp; &nbsp; &nbsp;else</p>
<p> &nbsp; &nbsp; &nbsp; &nbsp;{</p>
<p> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;if ((matchData[i] &amp; 0x08) == 0x08) return currentEncoding;</p>
<p> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;offset++;</p>
<p> &nbsp; &nbsp; &nbsp; &nbsp;}</p>
<p> &nbsp; &nbsp; &nbsp; &nbsp;i++;</p>
<p> &nbsp; &nbsp;}</p></div>
<p><a id="9322369" href="#9322369">#</a> <strong>Khedron</strong> on 15 Jan 2009 7:23 PM:</p><div style="margin-left: 1em"><p>Ok, everyone seems to be just testing for the bytes in order. I realise that I'm posting late, so may have to give up the points race, but here's my version. Auto-calculates the BOM based on endianness and wchar size and compares the char* against that. Except for UTF-8. I gave up on that (its midnight here &amp; I'm going to bed now).</p>

<p>#include &lt;string&gt;<br>#include &lt;cstring&gt;</p>





<p>// Same-endian: feff<br>// Different-endian: fffe<br>enum endianness {<br>&nbsp; be = -1,<br>&nbsp; le = 1<br>};</p>





<p>bool compare_bom_string(int sizeof_wchar, endianness end, const char* data)<br>{<br>&nbsp; std::string bom(sizeof_wchar, 0);<br>&nbsp; int pos = (end==be?3:0);<br><br>&nbsp; bom[pos] = '\xFF';<br>&nbsp; bom[pos+end] = '\xFE';</p>

<p> &nbsp; return !memcmp((void*)data, (void*)bom.c_str(), sizeof_wchar);<br>}</p>




<p>struct bom {<br>&nbsp; bom(int i, endianness e) : sizeof_wchar(i), end(e) { }<br>&nbsp; int sizeof_wchar;<br>&nbsp; endianness end;<br>};</p>

<p>int wchar_sizes[] = { 4, 2 };<br>endianness ends[] = { be, le };</p>


<p>struct ex {<br>&nbsp; ex(const char*m) : msg(m) { }<br>&nbsp; const char * what() { return msg; }</p>
<p> &nbsp; const char *msg;</p>
<p>};</p>




<p>bom sniff(const char* data)<br>{<br>&nbsp; for (int i = 0; i &lt; sizeof wchar_sizes; ++i)<br>&nbsp; &nbsp;&nbsp; for (int j = 0; j &lt; sizeof ends; ++j)<br>&nbsp; &nbsp; &nbsp; &nbsp; if (compare_bom_string(wchar_sizes[i], ends[j], data)) return bom(wchar_sizes[i], ends[j]);</p>

<p> &nbsp; // Just got lazy<br>&nbsp; const char* utf_8 = "\xEF\xBB\xBF";</p>
<p> &nbsp; if (!memcmp((void*)data, (void*)utf_8, 3)) return bom(1,le);</p>


<p> &nbsp; // Just got lazier<br>&nbsp; throw ex("Whoops");;<br>}</p></div>
<p><a id="9425693" href="#9425693">#</a> <strong>Anonymous</strong> on 16 Feb 2009 5:36 AM:</p><div style="margin-left: 1em">
<p>import Maybe<br>import List</p>















<p>detectBOM s = snd . fromJust $ find ((flip isPrefixOf) s . fst) byteOrderMarks<br>&nbsp;&nbsp; where byteOrderMarks = [("\xef\xbb\xbf","UTF-8"),<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; ("\x00\x00\xfe\xff","UTF-32BE"),<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; ("\xff\xfe\x00\x00","UTF-32LE"),<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; ("\xfe\xff","UTF-16BE"),<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; ("\xff\xfe","UTF-16LE"),<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; ("\x2b\x2f\x76\x38","UTF-7"),<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; ("\x2b\x2f\x76\x39","UTF-7"),<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; ("\x2b\x2f\x76\x2b","UTF-7"),<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; ("\x2b\x2f\x76\x2f","UTF-7"),<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; ("\xf7\x64\x4c","UTF-1"),<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; ("\xdd\x73\x66\x73","UTF-EBCDIC"),<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; ("\x0e\xfe\xff","SCSU"),<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; ("\xfb\xee\x28","BOCU-1"),<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; ("\x84\x31\x95\x33","GB18030"),<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; ("","NO BOM")]</p></div>
<hr/><p><em>go to <a id="newer" href="http://archives.miloush.net/michkap/archive/2009/01/08/9293101.html" title="After calling the airline, iBOT a ticket to Vegas!">newer</a> or <a id="older" href="http://archives.miloush.net/michkap/archive/2009/01/07/9286918.html" title="Counting to four with the Holy Hand Grenade of Typography">older</a> post, or back to <a href="http://archives.miloush.net/michkap/archive/index.html">index</a> or <a href="http://archives.miloush.net/michkap/archive/index.html#2009-01">month</a> or <a href="http://archives.miloush.net/michkap/archive/index.html#2009-01-07">day</a></em></p></body>
<!-- Mirrored from archives.miloush.net/michkap/archive/2009/01/07/9287052.html by HTTrack Website Copier/3.x [XR&CO'2014], Thu, 25 May 2017 00:42:35 GMT -->
</html>