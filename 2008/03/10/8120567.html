<html>
<!-- Mirrored from archives.miloush.net/michkap/archive/2008/03/10/8120567.html by HTTrack Website Copier/3.x [XR&CO'2014], Thu, 25 May 2017 00:42:36 GMT -->
<head><meta charset="utf-8" /><meta name="viewport" content="width=device-width" /><title>What's wrong with one of GetNumberFormat's callers? And what's wrong with GetNumberFormat?</title></head><body>
<h1>What's wrong with one of GetNumberFormat's callers? And what's wrong with GetNumberFormat?</h1>
<p><em>by Michael S. Kaplan, published on 2008/03/10 09:16 -04:00, original URI: http://blogs.msdn.com/b/michkap/archive/2008/03/10/8120567.aspx</em></p>
<hr/> <!-- Archival Source: ProcessPostNew -->
<P><FONT color=#ff0000 size=1><EM>Please read the </EM></FONT><A class="" href="http://archives.miloush.net/michkap/archive/2008/02/28/7934999.html" mce_href="http://archives.miloush.net/michkap/archive/2008/02/28/7934999.html"><EM><FONT size=1>disclaimer</FONT></EM></A><EM><FONT color=#ff0000 size=1>; content of <A class="" href="http://blogs.msdn.com/michkap" mce_href="http://blogs.msdn.com/michkap">Michael Kaplan's blog</A> not approved by Microsoft!</FONT></EM></P>
<P>Some of you may recall Igor Levicki, the guy who had 64-bit keyboards working before MSKLC 1.4 was released who I mentioned in <A class="" href="http://archives.miloush.net/michkap/archive/2006/09/28/774957.html" mce_href="http://archives.miloush.net/michkap/archive/2006/09/28/774957.html"><STRONG>If you just don't think you can hold it (64-bit style!)</STRONG></A>.</P>
<P>The other day he sent me mail about a bug (actually a small bundle of bugs, but the bug he found was a crash bug) in a third party application (name withheld to protect the guilty, and&nbsp;also the embarrassed!).</P>
<P>Igor&nbsp;looked at crash via the disassembly, which I'll put here just for the sake of completeness. If you are the same kind of person you can work along here and try to find the problems within the disassembly:</P>
<BLOCKQUOTE>
<P><FONT face="Consolas,Lucida Console,Courier New,Courier,fixed" size=1>; Exported entry 592. <A href="mailto:?GetDoubleFormat@CAppUtils@@SAPB_WNH@Z">?GetDoubleFormat@CAppUtils@@SAPB_WNH@Z</A><BR><BR></FONT><FONT face="Consolas,Lucida Console,Courier New,Courier,fixed" size=1>; wchar_t* __cdecl CAppUtils__GetDoubleFormat(double, int)<BR><BR></FONT><FONT face="Consolas,Lucida Console,Courier New,Courier,fixed" size=1>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; public <A href="mailto:?GetDoubleFormat@CAppUtils@@SAPB_WNH@Z">?GetDoubleFormat@CAppUtils@@SAPB_WNH@Z</A>&nbsp;<BR><BR></FONT><FONT face="Consolas,Lucida Console,Courier New,Courier,fixed" size=1><A href="mailto:?GetDoubleFormat@CAppUtils@@SAPB_WNH@Z">?GetDoubleFormat@CAppUtils@@SAPB_WNH@Z</A> proc near<BR><BR></FONT><FONT face="Consolas,Lucida Console,Courier New,Courier,fixed" size=1>var_108&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; = qword&nbsp;&nbsp;&nbsp; ptr -108h<BR>LCData&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; = word ptr -0D4h<BR>Value&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; = word ptr -0D0h<BR>var_4&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; = dword&nbsp;&nbsp;&nbsp; ptr -4<BR>arg_0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; = qword&nbsp;&nbsp;&nbsp; ptr&nbsp; 8<BR>arg_8&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; = dword&nbsp;&nbsp;&nbsp; ptr&nbsp; 10h<BR><BR></FONT><FONT face="Consolas,Lucida Console,Courier New,Courier,fixed" size=1>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; push&nbsp;&nbsp;&nbsp; ebp<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mov&nbsp;&nbsp;&nbsp; ebp, esp<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; and&nbsp;&nbsp;&nbsp; esp, 0FFFFFFC0h<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; sub&nbsp;&nbsp;&nbsp; esp, 0FCh<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mov&nbsp;&nbsp;&nbsp; eax, dword_1007E01C<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; xor&nbsp;&nbsp;&nbsp; eax, esp<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mov&nbsp;&nbsp;&nbsp; [esp+0FCh+var_4], eax<BR><BR></FONT><FONT face="Consolas,Lucida Console,Courier New,Courier,fixed" size=1>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; fld&nbsp;&nbsp;&nbsp; [ebp+arg_0]<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; push&nbsp;&nbsp;&nbsp; esi<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; sub&nbsp;&nbsp;&nbsp; esp, 8<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; fstp&nbsp;&nbsp;&nbsp; [esp+108h+var_108]<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; lea&nbsp;&nbsp;&nbsp; eax, [esp+108h+Value]<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; push&nbsp;&nbsp;&nbsp; offset aF&nbsp;&nbsp;&nbsp; ; "%f"<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; push&nbsp;&nbsp;&nbsp; eax&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ; String<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call&nbsp;&nbsp;&nbsp; ds:_swprintf<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; add&nbsp;&nbsp;&nbsp; esp, 10h<BR><BR></FONT><FONT face="Consolas,Lucida Console,Courier New,Courier,fixed" size=1>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; push&nbsp;&nbsp;&nbsp; 0FFh&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ; cchNumber<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; push&nbsp;&nbsp;&nbsp; offset word_100873B0 ; lpNumberStr<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; push&nbsp;&nbsp;&nbsp; 0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ; lpFormat<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; lea&nbsp;&nbsp;&nbsp; ecx, [esp+10Ch+Value]<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; push&nbsp;&nbsp;&nbsp; ecx&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ; lpValue<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; push&nbsp;&nbsp;&nbsp; 0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ; dwFlags<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; push&nbsp;&nbsp;&nbsp; 400h&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ; Locale<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call&nbsp;&nbsp;&nbsp; ds:GetNumberFormatW<BR><BR></FONT><FONT face="Consolas,Lucida Console,Courier New,Courier,fixed" size=1>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; push&nbsp;&nbsp;&nbsp; 2&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ; cchData<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; lea&nbsp;&nbsp;&nbsp; edx, [esp+104h+LCData]<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; push&nbsp;&nbsp;&nbsp; edx&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ; lpLCData<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; push&nbsp;&nbsp;&nbsp; 0Eh&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ; LCType<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; push&nbsp;&nbsp;&nbsp; 400h&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ; Locale<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call&nbsp;&nbsp;&nbsp; ds:GetLocaleInfoW<BR><BR></FONT><FONT face="Consolas,Lucida Console,Courier New,Courier,fixed" size=1>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mov&nbsp;&nbsp;&nbsp; esi, [ebp+arg_8]<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cmp&nbsp;&nbsp;&nbsp; esi, 0FFFFFFFFh<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; jz&nbsp;&nbsp;&nbsp; short loc_10008344<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mov&nbsp;&nbsp;&nbsp; eax, dword ptr [esp+100h+LCData]<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; push&nbsp;&nbsp;&nbsp; eax&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ; Ch<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; push&nbsp;&nbsp;&nbsp; offset word_100873B0 ; Str<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call&nbsp;&nbsp;&nbsp; ds:wcsrchr<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; add&nbsp;&nbsp;&nbsp; esp, 8<BR><BR></FONT><FONT face="Consolas,Lucida Console,Courier New,Courier,fixed" size=1>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; test&nbsp;&nbsp;&nbsp; eax, eax<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; jz&nbsp;&nbsp;&nbsp; short loc_1000833F<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; lea&nbsp;&nbsp;&nbsp; eax, [eax+esi*2+2]<BR><BR></FONT><FONT face="Consolas,Lucida Console,Courier New,Courier,fixed" size=1>loc_1000833F:<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mov&nbsp;&nbsp;&nbsp; word ptr [eax],&nbsp;&nbsp;&nbsp; 0<BR><BR></FONT><FONT face="Consolas,Lucida Console,Courier New,Courier,fixed" size=1>loc_10008344:<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mov&nbsp;&nbsp;&nbsp; ecx, [esp+100h+var_4]<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pop&nbsp;&nbsp;&nbsp; esi<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; xor&nbsp;&nbsp;&nbsp; ecx, esp<BR><BR></FONT><FONT face="Consolas,Lucida Console,Courier New,Courier,fixed" size=1>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mov&nbsp;&nbsp;&nbsp; eax, offset word_100873B0<BR><BR></FONT><FONT face="Consolas,Lucida Console,Courier New,Courier,fixed" size=1>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call&nbsp;&nbsp;&nbsp; sub_10059B35<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mov&nbsp;&nbsp;&nbsp; esp, ebp<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pop&nbsp;&nbsp;&nbsp; ebp<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; retn<BR><BR></FONT><FONT face="Consolas,Lucida Console,Courier New,Courier,fixed" size=1><A href="mailto:?GetDoubleFormat@CAppUtils@@SAPB_WNH@Z">?GetDoubleFormat@CAppUtils@@SAPB_WNH@Z</A> endp</FONT></P></BLOCKQUOTE>
<P mce_keep="true">From assembly it is pretty hard to know whose application it is, but what is happening in this one function is not too hard to figure out.</P>
<P mce_keep="true">Now for those who really aren't as comfortable working&nbsp;this way where you have watch&nbsp;parameters get placed on the stack an such&nbsp;(though it should be fairly straightforward to work with&nbsp;in this case&nbsp;for those so inclined!), here is some essentially equivalent&nbsp;C code:</P>
<BLOCKQUOTE>
<BLOCKQUOTE><FONT face="Consolas,Lucida Console,Courier New,Courier,fixed">
<P mce_keep="true"><STRONG>wchar_t Formatted[256];<BR><BR>wchar_t *GetDoubleFormat(double Value, int DecimalPlaces) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; wchar_t Buffer[MAX_PATH];<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int&nbsp;&nbsp;&nbsp;&nbsp; DecimalChar;<BR><BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; _swprintf(Buffer, "%f", Value);<BR><BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; GetNumberFormatW(LOCALE_USER_DEFAULT, LOCALE_NOUSEROVERRIDE, Buffer, NULL, Formatted, 255);<BR><BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; GetLocaleInfoW(LOCALE_USER_DEFAULT, LOCALE_SDECIMAL, &amp;DecimalChar, 2);<BR><BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (DecimalPlaces != -1) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; wchar_t *Point = wcsrchr(Formatted, DecimalChar);<BR><BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (Point != NULL) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Point = Point + DecimalPlaces + 1;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<BR><BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; *Point = 0x0000;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<BR><BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return Formatted;<BR>}</STRONG></P></FONT></BLOCKQUOTE></BLOCKQUOTE>
<P mce_keep="true">Now this bit of code is as veritable bug farm of how to misuse the NLS API.</P>
<P mce_keep="true">What it is trying to do, with many of the bugs embedded in the descriptive language for easy retrieval:</P>
<OL>
<LI>
<DIV mce_keep="true">Format a passed in double with the current user default locale and allowing no user overrides.</DIV></LI>
<LI>
<DIV mce_keep="true">Retrieve the numeric decimal separator,&nbsp;allowing user overrides.</DIV></LI>
<LI>
<DIV mce_keep="true">Search backward through the formatted string looking for that decimal separator.</DIV></LI>
<LI>
<DIV mce_keep="true">Increment the pointer to be the passed in number of places after the decimal separator plus one.</DIV></LI>
<LI>
<DIV mce_keep="true">Stick a NULL there, effectively truncated the formatted string there.</DIV></LI></OL>
<P mce_keep="true">Originally Igor was thinking this might have even made a great entry for <A class="" href="http://thedailywtf.com/" mce_href="http://thedailywtf.com/">The Daily WTF</A>, and I'm not gonna disagree with him on that.</P>
<P mce_keep="true"><EM>The crash bug&nbsp;Igor had run into initially was based on the fact that he had Serbian locale settings with a customized decimal separator -- thus the user override mismatch in #1 and #2 above quickly led to a problem searching for a "." in a string such as "44,90" -- then after properly detecting that wcsrchr returning NULL for failure, a somewhat catastrophic situation arises when it tries to dereference that NULL in order to assign to it.</EM></P>
<P mce_keep="true">Basically what they (apparently) wanted to do was format a number with the user's preferences but overriding the user's choice of the number of decimal places. The resulting string is&nbsp;put in their user interface, returning the result to the user in a property sheet.</P>
<P mce_keep="true"><FONT color=#009933 size=4>Worse&nbsp;ways of&nbsp;achieving that goal&nbsp;have been&nbsp;reported in code reviews, but not by reliable witnesses.</FONT></P>
<P mce_keep="true">(There are other silly/problematic issues here, such as:</P>
<UL>
<LI>
<DIV mce_keep="true">LOCALE_SDECIMAL can be up to two characters; this code assumes it is always one (note that this is a problem most code&nbsp;tends to&nbsp;have)</DIV></LI>
<LI>
<DIV mce_keep="true">The retrieved LOCALE_SDECIMAL value is stored in an &amp;int, presumably to facilitate the later wcsrchr call, but which is less than ideal always (and in the case of #1 will guarantee incorrect detection behavior);</DIV></LI>
<LI>
<DIV mce_keep="true">GetNumberFormatW assumes that space for the NULL is included in the buffer -- why allocate a wchar_t array of 256 if you are only going to pass 255 for the length? If the function cannot fit the NULL it will fail;</DIV></LI>
<LI>
<DIV mce_keep="true">No return value checking for _swprintf, GetNumberFormatW or GetLocaleInfoW -- despite the fact that they can all return errors and some of the errors would have negative side effects on the intended operation of&nbsp;their GetDoubleFormat function.</DIV></LI></UL>
<P mce_keep="true">Now in fairness to the people who wrote this code (whoever they are and whenever they wrote it), <A class="" href="http://msdn2.microsoft.com/library/ms776317.aspx" mce_href="http://msdn2.microsoft.com/library/ms776317.aspx">GetNumberFormat</A> has some specific limitations that make it less useful and that make it more difficult to&nbsp;write the idealized version of this function.</P>
<P mce_keep="true">I am going to enumerate the&nbsp;three big problems&nbsp;here as I see them, and Igor might have some additional thoughts on this matter either for comments here or on <A class="" href="http://www.levicki.net/" mce_href="http://www.levicki.net/">his own site</A>. :-)</P>
<P mce_keep="true"><FONT color=#ff0000><STRONG>But the NLS team could think of this next bit as feedback to them</STRONG></FONT> on ways to make functions like <A class="" href="http://msdn2.microsoft.com/library/ms776317.aspx" mce_href="http://msdn2.microsoft.com/library/ms776317.aspx">GetNumberFormat</A> better, faster, easier to use, and more generally useful.</P>
<P mce_keep="true">First of all,&nbsp;since <A class="" href="http://msdn2.microsoft.com/library/ms776317.aspx" mce_href="http://msdn2.microsoft.com/library/ms776317.aspx">GetNumberFormat</A> can only take a string rather than a number due to the lack of a LOCALE_SPECIFY_NUMBER flag (as I mentioned in <A class="" href="http://archives.miloush.net/michkap/archive/2005/05/29/422980.html" mce_href="http://archives.miloush.net/michkap/archive/2005/05/29/422980.html"><STRONG>Pass the string please</STRONG></A>, three years ago), the caller must format their number as a string via a function like _swprintf so that it can then format the number within the string as yet another a string -- and perhaps this is proof that I have changed my mind a bit since tha tblog; the NLS code really ought to help out more with the more common obvious cases when it can, such as this one.</P>
<P mce_keep="true">Second of all (and perhaps most importantly), the longstanding behavior of <A class="" href="http://msdn2.microsoft.com/library/ms776317.aspx" mce_href="http://msdn2.microsoft.com/library/ms776317.aspx">GetNumberFormat</A>&nbsp;that requires either a fully filled in NUMBERFMT in lpFormat or a NULL lpFormat means that the only way to specify an lpFormat-&gt;NumDigits value is to also fill in the lpFormat-&gt;LeadingZero, lpFormat-&gt;Grouping, lpFormat-&gt;lpDecimalSep, lpFormat-&gt;ThousandSep, and lpFormat-&gt;NegativeOrder values as well -- thus requiring up to five calls to GetLocaleInfo for information entirely derivable from the passed-in locale (assuming one value being overridden).</P>
<P mce_keep="true">There are any number of alternate possible ways it could have been done -- like establish the NULL case for the struct as being the default which means "take the locale's data", or specify values that mean the same thing, or even define flags to specify which values to pay attention to in the structure (there is room in the dwFlags for this both this function and GetCurrencyFormat!).</P>
<P mce_keep="true">Third of all,&nbsp;where&nbsp;<A class="" href="http://msdn2.microsoft.com/library/ms776317.aspx" mce_href="http://msdn2.microsoft.com/library/ms776317.aspx">GetNumberFormat</A> always requires either a fully filled in NUMBERFMT in lpFormat or a NULL lpFormat, if you don't pass in that filled-in NUMBERFMT then the code behind the function always grabs all of the information even if it does not need it -- meaning for example that it will grab the user overridable lpFormat-&gt;ThousandSep even if the number is not big enough to need it according to the number itself. The upshot of this is that the performance of the function is much better if you pass in the lpFormat yourself if you have the data handy -- because the function is not smart about how it does its work.</P>
<P mce_keep="true">Now one may argue against that type of optimization due to potential thread safety issues&nbsp;caused by <A class="" href="http://msdn2.microsoft.com/library/ms776312.aspx" mce_href="http://msdn2.microsoft.com/library/ms776312.aspx">SetLocaleInfo</A> calls happening while number formatting is happening, but given that this is already&nbsp;really a bit&nbsp;of a problem in the code terms of consistent number formatting in such situations&nbsp;(and also how uncommon <A class="" href="http://msdn2.microsoft.com/library/ms776312.aspx" mce_href="http://msdn2.microsoft.com/library/ms776312.aspx">SetLocaleInfo</A> calls or user-specific Regional Options changes that amount to <A class="" href="http://msdn2.microsoft.com/library/ms776312.aspx" mce_href="http://msdn2.microsoft.com/library/ms776312.aspx">SetLocaleInfo</A> calls actually are), there are much better solutions for this problem that are possible. Much moreso&nbsp;than the current solution (trying to front-load all of the data loading calls to minimize the number of possible <A class="" href="http://msdn2.microsoft.com/library/ms776312.aspx" mce_href="http://msdn2.microsoft.com/library/ms776312.aspx">SetLocaleInfo</A> calls that could happen). And many of those better solutions would be more performant, too!</P>
<P mce_keep="true">On top of all that, this front-loading in the case of the NULL lpFormat happens when LOCAL:E_NOUSEROVERRIDE is specified, too -- meaning there is no thread safety issue all but the code is happy to fill a structure with six separate data items&nbsp;without ever&nbsp;returning the data it loaded to the caller (in case they were going to call the function repeatedly). If one has to pay the price, one would like a bit more for one's money, in my opinion....</P>
<P mce_keep="true">If those issues did not exist, then all of the work done by the third party GetDoubleFormat&nbsp;could happen in a single very fast function call, rather than a whole bunch of code, such as the buggy code Igor pointed out in the version&nbsp;of the third party application&nbsp;he was looking at.</P>
<P mce_keep="true">Now none of this excuses the bugs in&nbsp;the third party&nbsp;application&nbsp;-- that code screws up the usage of NLS functions with multiple&nbsp;bugs including some that crash? They have no good reason to have those.</P>
<P mce_keep="true">But if the NLS function did a bit more of the work here, perhaps the kind of developers who were going to make those mistakes when left to their own devices would have one less opportunity to do so?</P>
<P mce_keep="true"><STRONG><FONT color=#ff0000>Now for the interactive bit of&nbsp;this blog (and incidentally of this Blog):</FONT></STRONG></P>
<P mce_keep="true">Any developers want to take a stab at implementing the </P>
<BLOCKQUOTE>
<P mce_keep="true"><STRONG>wchar_t *GetDoubleFormat(double Value, int DecimalPlaces)</STRONG></P></BLOCKQUOTE>
<P mce_keep="true">function without any of the numerous aforementioned&nbsp;bugs? :-)</P>
<P mce_keep="true">&nbsp;</P>
<P mce_keep="true"><FONT color=#ff00ff><EM>This blog brought to you by</EM><FONT size=5> . </FONT><EM>(<A class="" href="http://www.fileformat.info/info/unicode/char/002e" mce_href="http://www.fileformat.info/info/unicode/char/002e">U+002e</A>, aka FULL STOP)</EM></FONT></P>
<hr/><p><a id="8135036" href="#8135036">#</a> <strong>Pseudo</strong> on 10 Mar 2008 1:16 PM:</p><div style="margin-left: 1em"><p>The simplest way would seem to be:</p>
<p>set f = 10^DecimalPlaces</p>
<p>multiply Value by f</p>
<p>round or truncate to an integer</p>
<p>divide by f</p>
<p>wsprintf to get the string</p></div>
<p><a id="8144496" href="#8144496">#</a> <strong>Michael S. Kaplan</strong> on 11 Mar 2008 12:37 AM:</p><div style="margin-left: 1em"><p>Not sure how this gets all the user 's preferences?</p>
</div>
<p><a id="8146839" href="#8146839">#</a> <strong>Leo Davidson</strong> on 11 Mar 2008 3:58 AM:</p><div style="margin-left: 1em"><p>&quot;GetNumberFormatW assumes that space for the NULL is included in the buffer -- why allocate a wchar_t array of 256 if you are only going to pass 255 for the length?&quot;</p>
<p>Because MSDN is almost always vague about what the length arguments mean. MSDN typically talks about the length of the string, but doesn't say if it means the length as in what strlen (etc.) would return, or if it means the number of characters in the string including the null.</p>
<p>I expect most APIs do include the null in their lengths but it only takes one bad API call to cause a crash or corrupt memory when the string happens to be the same length as the buffer and the null either doesn't get written or gets written off the end of the buffer...</p>
<p>So I almost always, unless the MSDN documentation is very explicit, allocate that one extra character. It's just two bytes of memory, so why not? Not everyone has the advantage of being able to look in the API source when the documentation falls short and it's quicker to waste 2 bytes (for the millisecond that stack frame is in scope) than to run tests on every API to see how it behaves when the result fills the buffer exactly.</p></div>
<p><a id="8152009" href="#8152009">#</a> <strong>Michael S. Kaplan</strong> on 11 Mar 2008 9:06 AM:</p><div style="margin-left: 1em"><p>I guess the lack of clarity on that point could be considered a fourth problem to fix? :-)</p>
</div>
<p><a id="8159199" href="#8159199">#</a> <strong>Igor Levicki</strong> on 11 Mar 2008 4:22 PM:</p><div style="margin-left: 1em"><P>This is how I would write GetDoubleFormat():</P><FONT face="Consolas,Lucida Console,Courier New,Courier" size=1>
<P>#ifndef _WIN32_WINNT<BR>#define _WIN32_WINNT 0x0501<BR>#endif<BR><BR>#include &lt;tchar.h&gt;<BR>#include &lt;stdio.h&gt;<BR>#include &lt;stdlib.h&gt;<BR>#include &lt;math.h&gt;<BR>#include &lt;float.h&gt;<BR>#include &lt;windows.h&gt;<BR><BR>#define MSEP_MAX 5&nbsp;&nbsp;&nbsp; // 4 characters + NULL, actual Windows XP limit<BR>#define TSEP_MAX 4&nbsp;&nbsp;&nbsp; // 3 characters + NULL, actual Windows XP limit<BR>#define DSEP_MAX 4&nbsp;&nbsp;&nbsp; // 3 characters + NULL, actual Windows XP limit<BR>#define NDEC_MAX 9&nbsp;&nbsp;&nbsp; // 9 decimal places, actual Windows XP limit<BR>#define PDBL_MAX&nbsp;320&nbsp; // 1.7976931348623158e+308<BR>#define PDBL_MAX2&nbsp;640<BR>// Copyright (c) 2008 by Igor Levicki. All Bugs Reserved. :-)<BR><BR>LPCTSTR GetDoubleFormat(const double Value, const UINT DecimalPlaces) {<BR>&nbsp;&nbsp;&nbsp; static TCHAR Formatted[MAX_PATH];<BR>&nbsp;&nbsp;&nbsp; TCHAR StrValue[MAX_PATH];<BR>&nbsp;&nbsp;&nbsp; TCHAR StrFraction[MAX_PATH];<BR>&nbsp;&nbsp;&nbsp; TCHAR MSep[MSEP_MAX] = _T("-");<BR>&nbsp;&nbsp;&nbsp; TCHAR TSep[TSEP_MAX] = _T(",");<BR>&nbsp;&nbsp;&nbsp; TCHAR DSep[DSEP_MAX] = _T(".");<BR><BR>&nbsp;&nbsp;&nbsp; const TCHAR Dot = _T('.');<BR>&nbsp;&nbsp;&nbsp; const TCHAR Zero = _T('0');<BR><BR>&nbsp;&nbsp;&nbsp; LPTSTR FracPtr;<BR>&nbsp;&nbsp;&nbsp; size_t Cch, Mod, Idx;<BR><BR>&nbsp;&nbsp;&nbsp; if (DecimalPlaces &gt; NDEC_MAX) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; SetLastError(ERROR_INVALID_PARAMETER);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return NULL;<BR>&nbsp;&nbsp;&nbsp; }<BR><BR>&nbsp;&nbsp;&nbsp; if (Value &gt; DBL_MAX) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; SetLastError(ERROR_INVALID_PARAMETER);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return NULL;<BR>&nbsp;&nbsp;&nbsp; }<BR><BR>&nbsp;&nbsp;&nbsp; GetLocaleInfo(LOCALE_USER_DEFAULT, LOCALE_SNEGATIVESIGN, MSep, MSEP_MAX);<BR>&nbsp;&nbsp;&nbsp; GetLocaleInfo(LOCALE_USER_DEFAULT, LOCALE_STHOUSAND, TSep, TSEP_MAX);<BR>&nbsp;&nbsp;&nbsp; GetLocaleInfo(LOCALE_USER_DEFAULT, LOCALE_SDECIMAL, DSep, DSEP_MAX);<BR><BR>&nbsp;&nbsp;&nbsp; Formatted[0] = 0;<BR><BR>&nbsp;&nbsp;&nbsp; switch (_fpclass(Value)) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; case _FPCLASS_SNAN:<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; case _FPCLASS_QNAN:<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; case _FPCLASS_NINF:<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; case _FPCLASS_ND;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; case _FPCLASS_PD:<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; case _FPCLASS_PINF:<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; SetLastError(ERROR_INVALID_PARAMETER); // or ERROR_INVALID_DATA<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return NULL; // or ERROR_NOT_SUPPORTED<BR><BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; case _FPCLASS_NZ:<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; _tcscat_s(Formatted, MAX_PATH, MSep);<BR><BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; case _FPCLASS_PZ:<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; _tcsncat_s(Formatted, MAX_PATH, &amp;Zero, 1);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (DecimalPlaces &gt; 0) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; _tcscat_s(Formatted, MAX_PATH, DSep);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; size_t Len = _tcslen(Formatted);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for (UINT i = 0; i &lt; DecimalPlaces; i++) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Formatted[Len + i] = Zero;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Formatted[Len + DecimalPlaces] = 0;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return Formatted;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<BR><BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; _stprintf_s(StrValue, PDBL_MAX, _T("%0.*f"), DecimalPlaces, abs(Value));&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; FracPtr = _tcsrchr(StrValue, Dot);<BR><BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (FracPtr != NULL) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; *FracPtr++ = 0;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;_tcscpy_s(StrFraction, PDBL_MAX, FracPtr);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; } else {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; StrFraction[0] = 0;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<BR><BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Cch = _tcslen(StrValue);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Mod = (Cch % 3);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Idx = (Mod == 0) ? 3 : Mod;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Formatted[0] = 0;<BR><BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (Value &lt; 0.0) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; _tcscat_s(Formatted, PDBL_MAX2, MSep);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<BR><BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for (size_t i = 0; i &lt; Cch; i++) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (i == Idx) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; _tcscat_s(Formatted, PDBL_MAX2, TSep);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Idx += 3;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<BR><BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; _tcsncat_s(Formatted, MAX_PATH, &amp;StrValue[i], 1);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<BR><BR>&nbsp;&nbsp;&nbsp; if (DecimalPlaces &gt; 0) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; _tcscat_s(Formatted, PDBL_MAX2, DSep);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; _tcscat_s(Formatted, PDBL_MAX2, StrFraction);<BR>&nbsp;&nbsp;&nbsp; }<BR><BR>&nbsp;&nbsp;&nbsp; return Formatted;<BR>}<BR><BR>int _tmain(int argc, _TCHAR* argv[]) {<BR>&nbsp;&nbsp;&nbsp; if (--argc != 2) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf("Usage : %s &lt;decimal_number&gt; &lt;places&gt;\n", argv[0]);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return 1;<BR>&nbsp;&nbsp;&nbsp; }<BR><BR>&nbsp;&nbsp;&nbsp;&nbsp;double Value = _tstof(argv[1]);<BR>&nbsp;&nbsp;&nbsp;&nbsp;int DecimalPlaces = _tstoi(argv[2]);<BR><BR>&nbsp;&nbsp;&nbsp;&nbsp;_tprintf(_T("DecimalPlaces = %ld, Formatted : %s"), DecimalPlaces, GetDoubleFormat(Value, DecimalPlaces));<BR><BR>&nbsp;&nbsp;&nbsp; return 0;<BR>}</P></FONT>
<P>It properly handles user overrides for minus sign (up to 4 characters), thousand separator and decimal separator (up to 3 characters each), and it allows showing more decimal places than the original which could only chop the fractional part, not extend it.</P>
<P>Function could be easily expanded to handle +/- Infinity (and use locale supplied strings for that), to handle denormals and to display SNaN and QNaN text if needed. A bit more challenging task would be to handle digit replacement correctly and to use digit grouping other than 3.</P></div>
<hr/><p><em>go to <a id="newer" href="http://archives.miloush.net/michkap/archive/2008/03/10/8125510.html" title="When Ping was first described (back in 1933)">newer</a> or <a id="older" href="http://archives.miloush.net/michkap/archive/2008/03/09/8116053.html" title="When in doubt, blame it on the @#%&amp;*! SMILERS">older</a> post, or back to <a href="http://archives.miloush.net/michkap/archive/index.html">index</a> or <a href="http://archives.miloush.net/michkap/archive/index.html#2008-03">month</a> or <a href="http://archives.miloush.net/michkap/archive/index.html#2008-03-10">day</a></em></p></body>
<!-- Mirrored from archives.miloush.net/michkap/archive/2008/03/10/8120567.html by HTTrack Website Copier/3.x [XR&CO'2014], Thu, 25 May 2017 00:42:36 GMT -->
</html>