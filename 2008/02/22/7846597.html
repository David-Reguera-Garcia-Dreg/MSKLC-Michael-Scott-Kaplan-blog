<html>
<!-- Mirrored from archives.miloush.net/michkap/archive/2008/02/22/7846597.html by HTTrack Website Copier/3.x [XR&CO'2014], Thu, 25 May 2017 00:42:36 GMT -->
<head><meta charset="utf-8" /><meta name="viewport" content="width=device-width" /><title>Optimized for English (oh, and also Invariant, and NOTHING ELSE) Redux</title></head><body>
<h1>Optimized for English (oh, and also Invariant, and NOTHING ELSE) Redux</h1>
<p><em>by Michael S. Kaplan, published on 2008/02/22 09:46 -05:00, original URI: http://blogs.msdn.com/b/michkap/archive/2008/02/22/7846597.aspx</em></p>
<hr/> <!-- Archival Source: ProcessPostNew -->
<P><FONT color=#ff0000><EM>This post may not be of interest to all readers since it not only covers technical topics (which can easily turn off half my readers!) </EM><EM>but does so in a slightly more sociological kind of way (which can easily turn off the other half!). Feel free to skip, as appropriate.</EM></FONT></P>
<P>Although this post shares a conceptual framework with <A class="" href="http://archives.miloush.net/michkap/archive/2006/08/14/698304.html" mce_href="http://archives.miloush.net/michkap/archive/2006/08/14/698304.html"><STRONG>Optimized for English (oh, and also Japanese, and maybe a few others)</STRONG></A>, that post was really about ClearType and the group that was at the time referred to most often as the Advanced Reading Technologies team, while this one is about string comparisons in the .Net Framework. </P>
<P>So we are thinking about two entirely different groups of people sitting in two entirely different [sets of ]buildings in two entirely different divisions of Microsoft, and there is no relevant organizational or architectural connection between them....</P>
<P>My hints about this topic have been sprinkled throughout he blog but one of the more obvious ones can be found in a side paragraph in <A class="" href="http://archives.miloush.net/michkap/archive/2007/10/09/5375754.html" mce_href="http://archives.miloush.net/michkap/archive/2007/10/09/5375754.html"><STRONG>A&amp;P of Sort Keys, part 13 (About the function that is too lazy to get it right every time)</STRONG></A>:</P>
<BLOCKQUOTE>
<P>In another astounding burst of irony, there is an even quicker version of the string comparison function found in the .NET Framework which, due to a bug that I only accidentally found in the beginning of the Whidbey (2.0) product cycle, was never even called in versions 1.0 or 1.1. Subsequent to the decision to fix the bug by enabling the superfast function<FONT size=1><SUP>1</SUP></FONT>, no fewer than five bugs were found by testers in the logic of this attempt to capture optimizable calls to <A class="" href="http://msdn2.microsoft.com/library/ms647476.aspx" mce_href="http://msdn2.microsoft.com/library/ms647476.aspx">CompareString</A>-like code, due not only to the problem above but an unrelated obsession with&nbsp;making English faster even if it makes the more complicated languages a bit slower<SUP><FONT size=1>2</FONT></SUP>....</P></BLOCKQUOTE>
<P>Now some may think I was being a bit harsh, but the optimization is for string comparisons done on Unicode strings when the characters are all in the ASCII ( &lt;= U+007f)&nbsp;range. Basically when the string is created (and remember that in .NET strings are immutable so creation time work is pretty much the only time that the contents can really change!), it walks the string and determines whether it is one of these simple ASCII-content strings.</P>
<P>Now obviously that is not all that needs to happen, since word type sorting (as compared to string sorts, discussed earlier in <A class="" href="http://archives.miloush.net/michkap/archive/2005/05/05/414845.html" mce_href="http://archives.miloush.net/michkap/archive/2005/05/05/414845.html"><STRONG>A few of the gotchas of CompareString</STRONG></A>) affects the way the hyphen (U+002d)&nbsp;and the apostrophe (U+0027) sort, and they are down in that range. And there were other exceptions, too. So a big map of the "fast" characters had to be put together for this "default" case. </P>
<P>If you are a developer I'd like you to take a moment and think carefully about the consequences of building such a map and using it in the pre-processing. Incredible effort is being gone to here to look for the most optimizable case, given the very real belief that this will happen often enough that the case is truly worth optimizing.</P>
<P>Of course many locales have exceptions for how the letters in this range sort -- and so these other locales have to be excluded too. The decision for how to decide what locales to use is a rather simple macro in a C++ header file (you can actually find it yourself in the <STRONG>Rotor</STRONG> source if you have spent time in there, it is fairly hard to miss):</P>
<BLOCKQUOTE>
<P><FONT face="courier new,courier"><STRONG>//This is the list of locales which we currently understand are fast.<BR>//We should only do fast comparisons in one of these locales.<BR>#define IS_FAST_COMPARE_LOCALE(loc) \<BR>&nbsp;&nbsp;&nbsp; (((loc)==LOCALE_INVARIANT) || (PRIMARYLANGID(loc)==LANG_ENGLISH))</STRONG></FONT></P></BLOCKQUOTE>
<P>Ah, so we are restricting ourselves to invariant and English (all of the English locales that are there) -- nothing else is "fast" here?</P>
<P>But of all of the&nbsp;cultures that the .NET Framework supports, about half of them don't use the default sorting table (i.e. they&nbsp;have exceptions or compressions or reverse diacritics or whatever) -- say about 70 of them, and a little over half of those remaining (say 40 of them) have exceptions/compressions that impact this default table<SUP><FONT size=1>3</FONT></SUP>. Thus of all of the&nbsp;cultures in the .NET Framework,&nbsp;just under&nbsp;3/4 of them could use this optimization. </P>
<P>Yet it is essentially restricted to English and Invariant (which is basically English).</P>
<P>So you notice the team bends over backwards and is even willing to slow down string creation<SUP><FONT size=1>4</FONT></SUP>&nbsp;in order to find this optimized case -- but only for English (no one&nbsp;chose to build up a "fast locale map" for the&nbsp;almost 3/4 of cultures that could benefit from the same optimization). Do we need further proof that the framework comes from a US-based company? :-)</P>
<P>When you consider the fact that there was a 1.0/1.1 bug that kept the optimization from ever being used (once it was turned on rather than being yanked out, they found several bugs in sorting results and each time I suggested the code be removed but was overruled -- it was a lot of fun being right but not so much fun not being heeded!).</P>
<P>In my mind, the proof that the code was never used and thus probably had bugs was sufficient for me -- the old code was good enough, and they could even try to remove some of the string initialization performance hit if they wanted to make all operations faster rather than enabling an unproven optimization in string comparison. It did seem like there was an almost religious battle about the heresy of removing an optimized (but dead) code path merely because it was dead....</P>
<P>Now I have alway looked at .NET as a full-size Skunk Works-type project from the very beginning and right on through Silverlight, with small teams of people working to get good proof of concept work and then after driving the concept bulking it up and then shipping it. The team is obviously huge and there is a lot of process there (so my Skunk Works notion is not a fully accurate picture of how things actually work in practice) but I mean in terms of mindset and focus. </P>
<P>I mostly mean it as a compliment from an engineering standpoint, with the exception of international support issues, which often fall off in proof of concept and don't always get fully added back later.</P>
<P>So what does this team have in common with the ClearType team? Well, clearly there is a particular scenario-based focus on a subset of the customer population in both cases; the .NET case is perhaps slightly worse since I think we wrote a lot of the code here and own most of the code now (even the parts we didn't write). Though on the other hand much of the overall ownership of ClearType started from a small group that splintered from the core typography team which obviously was required to have a wider focus that included other languages, so perhaps both teams are guilty of this scenario narrowing effect?</P>
<P>Now I don't want to make <STRONG>too much</STRONG> of this, since in the end even the original code (which never used the optimization)&nbsp;was fast enough to work. But I do want to point out how the intent shapes the implementation in ways both subtle and not so subtle....</P>
<P mce_keep="true">&nbsp;</P>
<P><FONT size=1>1 - My recommendation to yank it out since it we never called anyway was denied;&nbsp;I was overruled given the universal reluctance to remove an intentional optimization from the code, even one that was never used.<BR>2 - An occupational hazard of a US-based software company. :-(<BR>3 - As an example of one that would not be included, consider Farsi/Persian, which has exceptions but obviously none in the ASCII range.<BR>4 - Anyone who does not think that walking the string is not a performance issue does not understand the lesson taught by <A class="" href="http://archives.miloush.net/michkap/archive/2007/10/12/5396685.html" mce_href="http://archives.miloush.net/michkap/archive/2007/10/12/5396685.html"><STRONG>That function is always faster! (well, except for that one case when it can actually be slower...)</STRONG></A>!</FONT></P>
<P mce_keep="true">&nbsp;</P>
<P mce_keep="true"><FONT color=#ff00ff><EM>This blog brought to you by</EM><FONT size=5> B </FONT><EM>(<A class="" href="http://www.fileformat.info/info/unicode/char/0042" mce_href="http://www.fileformat.info/info/unicode/char/0042">U+0042</A>, LATIN CAPITAL LETTER B)</EM></FONT></P>
<hr/><div style="margin-left: 1em"><em>no comments</em></div><hr/><p><em>go to <a id="newer" href="http://archives.miloush.net/michkap/archive/2008/02/22/7847522.html" title="What&#39;s missing from the model">newer</a> or <a id="older" href="http://archives.miloush.net/michkap/archive/2008/02/21/7837478.html" title="We&#39;re back and we&#39;re embarrassing ourselves? (aka Making your localizer&#39;s life easier, Part 2)">older</a> post, or back to <a href="http://archives.miloush.net/michkap/archive/index.html">index</a> or <a href="http://archives.miloush.net/michkap/archive/index.html#2008-02">month</a> or <a href="http://archives.miloush.net/michkap/archive/index.html#2008-02-22">day</a></em></p></body>
<!-- Mirrored from archives.miloush.net/michkap/archive/2008/02/22/7846597.html by HTTrack Website Copier/3.x [XR&CO'2014], Thu, 25 May 2017 00:42:36 GMT -->
</html>