<html>
<!-- Mirrored from archives.miloush.net/michkap/archive/2008/08/26/8890822.html by HTTrack Website Copier/3.x [XR&CO'2014], Thu, 25 May 2017 00:42:36 GMT -->
<head><meta charset="utf-8" /><meta name="viewport" content="width=device-width" /><title>Making SQL Server operations slower (without explicitly trying)</title></head><body>
<h1>Making SQL Server operations slower (without explicitly trying)</h1>
<p><em>by Michael S. Kaplan, published on 2008/08/26 10:01 -04:00, original URI: http://blogs.msdn.com/b/michkap/archive/2008/08/26/8890822.aspx</em></p>
<hr/> <!-- Archival Source: ProcessPostNew -->
<p>So I was chatting with <a href="http://www.sqlskills.com/blogs/kimberly/" mce_href="http://www.sqlskills.com/blogs/kimberly/">Kim</a> and <a href="http://www.sqlskills.com/blogs/paul/" mce_href="http://www.sqlskills.com/blogs/paul/">Paul</a> after that .NET DA meeting I <b><a href="http://archives.miloush.net/michkap/archive/2008/08/19/8877510.html" mce_href="http://archives.miloush.net/michkap/archive/2008/08/19/8877510.html">mentioned</a></b> the other day. The one where Kim kind of laid out the way that SQL Server did its searches, whether unindexed, indexed via a clustered key, and indexed without one.</p><p><i>Probably the best description of it I have ever heard, by the way. Kim really is a SQL goddess!</i></p><p>After her talk about the internals followed by Paul's talk about index fragmentation, they had me thinking about an additional piece of information that might be of interest.<br></p><p>I mentioned it in terms of how it can be a problem that can come up when you add multiple language-based indexes. Like you get when you use that technique I mentioned in <b><a href="http://archives.miloush.net/michkap/archive/2005/05/06/415199.html" mce_href="http://archives.miloush.net/michkap/archive/2005/05/06/415199.html">Making SQL Server index usage a bit more deterministic</a></b>.</p><p>Basically you have the interesting case where some collations are basically identical.</p><p>Like if you are dealing with Unicode columns and you use two collations that are only different due to the fact that they support different code pages. Like <b>Latin1_General_CS_AS</b> vs. <b>Arabic_CS_AS</b> vs. <b>Greek_CS_AS</b> vs. <b>Hebrew_CS_AS</b> vs. <b>Russian_CS_AS</b>, for example.</p><p>Or one like <b>Bosnian_Cyrillic_100_CI_AS</b> vs. <b>Bosnian_Latin_100_CI_AS</b> vs. <b>Croatian_100_CI_AS</b> vs. <b>Serbian_Cyrillic_100_CI_AS</b> vs. <b>Serbian_Latin_100_CI_AS</b> (some of these are identical but split out for political reasons proving that in SQL Server 2008 the have learned the lession I mentioned <b><a href="http://archives.miloush.net/michkap/archive/2006/04/25/583307.html" mce_href="http://archives.miloush.net/michkap/archive/2006/04/25/583307.html">previously</a></b> and others are the same because there was no good reason not to include the identical data in two different sorts where the users would reasonably expect the data to sort for them properly in either script, another lesson that they have "learned" well by picking up the new data).</p><p>The list goes on.</p><p>If you create multiple indexes on a column in order to assure better international user support, this is a good thing.</p><p>But if you go too far and create indexes that literally duplicate the same information as previously created indexes then all you are doing is taking up space (the size of the extra index) and hurting performance (the cost of index maintenance is 100% parasitic if the extra index is extraneous).</p><p>I asked someone on the SQL Server development team about this and he confirmed what I noticed through experimentation. Though he was unclear on how common the scenario was (he technically has a point since the technique is really only well documented here at <b><a href="http://blogs.msdn.com/michkap" mce_href="http://blogs.msdn.com/michkap">SiaO</a></b>, though I am philosophically opposed to <i>ever</i> relying on poor documentation as a justification for a bug!).<br></p><p>Now in regard to size luckily indexes are not huge since SQL Server does not use NLS-type sort keys for their indexes -- they use B-trees created via CompareString-type results.</p><p>But the size hit is greater than zero and if one has a mulei-million row table keeping two B-trees around that return the same results is hardly in anyone's best interests.</p><p>Plus the hit of adding entries when one has filled the level they are at in the B-tree and have to split the entry, but having to do so twice? A person is taking one of the really bad sides of index fragmentation and doubling it ir worse, for no reason!</p><p>Note that there is no warning for when this happens -- the new index is cheerfully created (to the extent that SQL Server is cheerful about such things!).</p><p>And although one could through research work to find out which collations give identical results for Unicode columns, it is not easy to find, and the information is really not exposed in any way to query it (other than asking me or something!).</p><p>The problem is worse for Exchange and the Jet Blue engine (which may beg the question of why I slant this blog so much toward SQL Server, but I think that these kinds of scenarios are much worse conceptually in SQL Server given how huge the optimization information is there both inside and outside of Microsoft -- people just seem to care a lot about database optimization in SQL Server).</p><p>But getting back to ESENT for a moment, the fact is that an e.g. <a href="http://msdn.microsoft.com/library/ms683117.aspx" mce_href="http://msdn.microsoft.com/library/ms683117.aspx">JetCreateIndex2</a> call will cheerfully succeed for English, German, and Dutch, no matter how long each one takes -- and it will actually also take the huge space hit, far beyond the hit SQL Server does. Since it has no optimization to partially combine identical sorts -- and those three truly are identical, as I mentioned <b><a href="http://archives.miloush.net/michkap/archive/2005/11/30/498183.html" mce_href="http://archives.miloush.net/michkap/archive/2005/11/30/498183.html">before</a></b>).<br></p><p>I suppose in the ideal world both database engines would have -- either through SQL DDL or function call -- two things:</p><ol><li>a way to determine if two indexes would be expected to return identical results, and<br></li><li>a way to "modify" an index that would either be a) a drop and recreate or b) a change of the existing index metadata, depending on which was required.</li></ol><p>Since </p><ul><li>none of these products do this work and <br></li><li>neither Windows nor .NET provide that kind of information</li></ul><p>there really is no good way for a developer to take advantage of this potentially huge size/performance optimization. </p><p>Well, there is the whole "just ask Michael Kaplan" thing but that hardly scales. :-)</p><p>So, is this important?</p><p>Well, that kind of depends. <br></p><p>If one is taking the time to be interested in index architecture and index fragmentation in general, and one cares bout multilingual applications, then I'd argue that yes, it can be quite important.</p><p>Though I admit that <b>YMMV</b> (your mileage may vary).</p><p>In the long run, adding the feature to query about or possibly even detect such cases is probably the best strategy for the various technologies and products. This would translate to features in NLS for the sake of clients like ESENT, and features in SQL Server.<br></p><p><br></p><p><font color="#ff00ff"><i>This blog brought to you by</i><font size="6"> á¹ƒ </font><i>(<a href="http://www.fileformat.info/info/unicode/char/1e43" mce_href="http://www.fileformat.info/info/unicode/char/1e43">U+1e43</a>, aka LATIN SMALL LETTER M WITH DOT BELOW)</i></font><br></p>
<hr/><div style="margin-left: 1em"><em>no comments</em></div><hr/><p><em>go to <a id="newer" href="http://archives.miloush.net/michkap/archive/2008/08/26/8895190.html" title="The sheer Shear of it all">newer</a> or <a id="older" href="http://archives.miloush.net/michkap/archive/2008/08/25/8893208.html" title="In the name of God, St Michael, and St. George, I dub thee the SUBOptimus keyboard">older</a> post, or back to <a href="http://archives.miloush.net/michkap/archive/index.html">index</a> or <a href="http://archives.miloush.net/michkap/archive/index.html#2008-08">month</a> or <a href="http://archives.miloush.net/michkap/archive/index.html#2008-08-26">day</a></em></p></body>
<!-- Mirrored from archives.miloush.net/michkap/archive/2008/08/26/8890822.html by HTTrack Website Copier/3.x [XR&CO'2014], Thu, 25 May 2017 00:42:36 GMT -->
</html>