<html>
<!-- Mirrored from archives.miloush.net/michkap/archive/2008/11/04/9037027.html by HTTrack Website Copier/3.x [XR&CO'2014], Thu, 25 May 2017 00:42:35 GMT -->
<head><meta charset="utf-8" /><meta name="viewport" content="width=device-width" /><title>Strange control over CTRL and control characters</title></head><body>
<h1>Strange control over CTRL and control characters</h1>
<p><em>by Michael S. Kaplan, published on 2008/11/04 10:01 -05:00, original URI: http://blogs.msdn.com/b/michkap/archive/2008/11/04/9037027.aspx</em></p>
<hr/> <!-- Archival Source: ProcessPostNew -->
<p>Via the Contact link, Rich asks:</p>
<blockquote style="margin-left: 80px;">
<p><font face="times new roman,times">Hi Michael, I've been reading your (very detailed and useful) series on keyboard layouts. There's one thing that's puzzling me with respect to the post about the Caps Lock state (<b><a href="http://archives.miloush.net/michkap/archive/2006/04/10/570570.html" mce_href="http://archives.miloush.net/michkap/archive/2006/04/10/570570.html">Getting all you can out of a keyboard layout, Part #8</a></b>).<br><br>When you are processing a standard key that's not part of a dead key sequence, you have some special-case processing for control chars that tests whether the VK value minus 0x40 is the same as the control character.<br><br>if((rc == 1) &amp;&amp;<br>(ss == ShiftState.Ctrl || ss == ShiftState.ShftCtrl) &amp;&amp; )rgKey[iKey].VK == ((uint)sbBuffer[0] + 0x40))) { ... }<br><br>However, there is a subtle difference in the equivalent code that processes a dead key combining character:<br><br></font></p>
<blockquote><font face="times new roman,times">if((((ss == ShiftState.Ctrl) || (ss == ShiftState.ShftCtrl)) &amp;&amp;<br>(char.IsControl(basechar))) ||<br>(basechar.Equals(combchar)))<br>{ ... }<br></font></blockquote>
<p><font face="times new roman,times"><br>In this case, you use char.IsControl(basechar). What is the difference between this and the test for VK - 0x40?<br><br>Many thanks<br>Rich</font><br></p>
</blockquote>
<p>A very reasonable question, one that I don't really cover in the blog proper.</p>
<p>It is actually to avoid a situation that kind of happens in keyboards.</p>
<p>The very first (pre-alpha) version of the tool that eventually became known as MSKLC but at the time was just something we knew as "the keyboard tool", and a feature that I have talked about previously in <b><a href="http://archives.miloush.net/michkap/archive/2005/01/03/345719.html" mce_href="http://archives.miloush.net/michkap/archive/2005/01/03/345719.html">Accessibility, Internationalization, and Keyboards (#3: MSKLC's UI)</a></b> and <b><a href="http://archives.miloush.net/michkap/archive/2008/05/17/8516386.html" mce_href="http://archives.miloush.net/michkap/archive/2008/05/17/8516386.html">Do your utmost to be conventional (and then pimp, q.d. or p.r.n.)</a></b>. </p>
<p>The ability to load an existing keyboard layout.</p>
<p>The very first version of that code did not include the <b>CTRL</b> and <b>CTRL+SHFT</b> shift states, but the second version I demonstrated a week later did. And while I was working on that code I ran into a problem - the fact that the various keyboarding API calls I was using would treat almost every single keystroke in the particular shift states as if it had a control character in it -- unless a letter or something else was assigned.</p>
<p>We realized that the code was just always saying these were here unless something else was added.</p>
<p>There is a certain symmetry in CTRL putting in "&lt;Control&gt;" characters, and you can see why if you ever spend time in the DOS prompt and you actually hit some of these keystrokes -- because this is how the are sent.<br></p>
<p>After a conversation about this where Simon pointed out that just because Windows is going to simulate them being there is no reason to add them explicitly in the keyboard tool. So we decided to strip these automatically added characters, since they really were not part of the layout.</p>
<p>For MSKLC 1.3, we decided to just always strip anything that made <a href="http://msdn.microsoft.com/library/system.char.iscontrol.aspx" mce_href="http://msdn.microsoft.com/library/system.char.iscontrol.aspx">char.IsControl</a> return <b>true</b>.</p>
<p>Just 'cause, you know?</p>
<p>Anyway, it turned out that broke some stuff, namely some applications that work at lower levels and don't get the benefit of the automatic additions of these special characters. This is a bug I have mentioned previously in blogs like <b><a href="http://archives.miloush.net/michkap/archive/2007/05/28/2954171.html" mce_href="http://archives.miloush.net/michkap/archive/2007/05/28/2954171.html">Usage (customer intent) vs. Design (developer intent)</a></b> and when we broke TELNET as I mentioned in <b><a href="http://archives.miloush.net/michkap/archive/2007/11/20/6420601.html" mce_href="http://archives.miloush.net/michkap/archive/2007/11/20/6420601.html">Michael's Keyboard Laws for Developers, Part 3</a></b>. With a special blessing from the test team (the original triage team said the bug did not meet the bar) the fix for this bug was snuck into MSKLC 1.4.</p>
<p>To limit the impact while maximizing the chance of fixing all of the known problems, the original <a href="http://msdn.microsoft.com/library/system.char.iscontrol.aspx" mce_href="http://msdn.microsoft.com/library/system.char.iscontrol.aspx">char.IsControl</a> code was removed and replaced with the test limiting the "ignoring the character" when it was the exact control character under the letter in question or a small list of specific control characters that applications depended on.</p>
<p>But neither the tester nor I could see any reasonable purpose to doing the sane with dead keys -- who would involve a control character with a dead key? That would make no sense!</p>
<p>So the dead key check did not include the extra filtering.</p>
<p>And for this series, I essentially went through the same process as i had the first time the code was written, except I remembered what had been done -- so I just put the same checks in, to get comparable results.</p>
<p>It seemed obscure enough that the explanation would never be needed; a comment would only call attention to it.</p>
<p>Well, that was my thinking at the time. Clearly Rich proved to me that there are people who can be as detail-oriented as I can be. :-)</p>
<p>Anyway, that is why the two different checks exist. Because every reasonable keyboard should be able to be loaded properly with it, including a bunch of unusual cases....</p>
<p>&nbsp;</p>
<p><font color="#ff00ff"><i>This blog brought to you by <a href="http://www.fileformat.info/info/unicode/char/001d" mce_href="http://www.fileformat.info/info/unicode/char/001d">U+001d</a>, aka &lt;CONTROL&gt;, aka INFORMATION SEPARATOR THREE)</i></font> <br></p>
<hr/><div style="margin-left: 1em"><em>no comments</em></div><hr/><p><em>go to <a id="newer" href="http://archives.miloush.net/michkap/archive/2008/11/06/9046130.html" title="I think we&#39;re taking the wrong approach, mostly">newer</a> or <a id="older" href="http://archives.miloush.net/michkap/archive/2008/11/04/9035756.html" title="You think herding cats is hard? Try herding CATS. Hell, try herding KATS!">older</a> post, or back to <a href="http://archives.miloush.net/michkap/archive/index.html">index</a> or <a href="http://archives.miloush.net/michkap/archive/index.html#2008-11">month</a> or <a href="http://archives.miloush.net/michkap/archive/index.html#2008-11-04">day</a></em></p></body>
<!-- Mirrored from archives.miloush.net/michkap/archive/2008/11/04/9037027.html by HTTrack Website Copier/3.x [XR&CO'2014], Thu, 25 May 2017 00:42:35 GMT -->
</html>