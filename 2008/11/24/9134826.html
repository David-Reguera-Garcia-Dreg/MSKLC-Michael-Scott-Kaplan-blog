<html>
<!-- Mirrored from archives.miloush.net/michkap/archive/2008/11/24/9134826.html by HTTrack Website Copier/3.x [XR&CO'2014], Thu, 25 May 2017 00:42:35 GMT -->
<head><meta charset="utf-8" /><meta name="viewport" content="width=device-width" /><title>UCS-2 to UTF-16, Part 6: An exercise left for whoever needs some exercise</title></head><body>
<h1>UCS-2 to UTF-16, Part 6: An exercise left for whoever needs some exercise</h1>
<p><em>by Michael S. Kaplan, published on 2008/11/24 10:01 -05:00, original URI: http://blogs.msdn.com/b/michkap/archive/2008/11/24/9134826.aspx</em></p>
<hr/> <!-- Archival Source: ProcessPostNew -->
<p>Previous blogs in this series of blogs on this Blog:</p>

<ul>
<li><b><a href="http://archives.miloush.net/michkap/archive/2008/08/30/8907667.html" mce_href="http://archives.miloush.net/michkap/archive/2008/08/30/8907667.html">Part 0: 
The intro, sans content</a></b> 
</li>
<li><b><a href="http://archives.miloush.net/michkap/archive/2008/09/08/8931641.html" mce_href="http://archives.miloush.net/michkap/archive/2008/09/08/8931641.html">Part 1: 
Getting the obvious out of the way</a></b> 
</li>
<li><b><a href="http://archives.miloush.net/michkap/archive/2008/09/15/8952073.html" mce_href="http://archives.miloush.net/michkap/archive/2008/09/15/8952073.html">Part 2: 
A&amp;P of a 'linguistic character'</a></b> 
</li>
<li><b><a href="http://archives.miloush.net/michkap/archive/2008/09/18/8956650.html" mce_href="http://archives.miloush.net/michkap/archive/2008/09/18/8956650.html">Part 3: 
It starts with cursor movement (where MS simultaneously gets better and 
worse)</a></b> 
</li>
<li><b><a href="http://archives.miloush.net/michkap/archive/2008/10/06/8977552.html" mce_href="http://archives.miloush.net/michkap/archive/2008/10/06/8977552.html">Part 4: 
Talking about the ask&nbsp;</a></b></li>
<li><b><a href="http://archives.miloush.net/michkap/archive/2008/10/15/9000371.html" mce_href="http://archives.miloush.net/michkap/archive/2008/10/15/9000371.html">Part 5: What's on the Next Level?</a></b><br></li>
</ul>

<p>Now continuing on from prior blogs in the series, I thought I'd quote a bit from a recent email thread about a very similar issue to some of the prior discussion like especially <b><a href="http://archives.miloush.net/michkap/archive/2008/09/18/8956650.html" mce_href="http://archives.miloush.net/michkap/archive/2008/09/18/8956650.html">Part 3</a></b>, related to caret stops, aka the points where you can put the cursor as you navigate the string.</p>
<p>The thread had wandered a bit (as threads tend to do!), and then colleague Jerry Dunietz (an architect I have worked with before on issues related to Unicode and cultures and locales and such) offered a great description of many of the issues that I have discussed here in this series. With his permission, I will quote from his response:</p>
<blockquote>
<p><i><font face="times new roman,times">Logically, a Unicode string is a sequence of UCS-4 code-points.&nbsp; (I intend to carefully distinguish between “code-point” and “code-unit” in the text below.)<br><br>There are several way to encode a Unicode string in memory.&nbsp; Ignoring for today the existence of a byte-order-mark (and of byte-ordering variations), there are three ways that one could represent such a string in memory:<br><br>As a sequence of 32-bit code-units, each representing a single UCS-4 code-point.&nbsp; (UTF-32)<br>As a sequence of 16-bit code-units.&nbsp; Some UCS-4 code-points are represented by single code-unit, and some represented as a “surrogate pair” of two code-units.&nbsp; (UTF-16.)<br>As a sequence of 8-bit code-units.&nbsp; The code points from U+0000 to U+007F are represented as a single code-unit, but all other code-points are represented by a longer sequence of code-units (UTF-8.)<br><br>Now imagine that you’re a programmer, and you want to pick representation in memory for a Unicode string.&nbsp; UTF-32 seems like the easiest to work with.&nbsp; (But it is the fattest encoding of the three for any real-world corpus of text.)&nbsp; If you want the fifth code-point in a string, you just array-index to the fifth code-unit in the string.&nbsp; If seems (but wait) that if the user hits backspace after inputting a string, you just back up one-code-unit.&nbsp; Is seems that if a user hits an arrow key to move a caret from one character to the next, you would just advance the caret position by one code-unit. (Given all of this apparent simplicity, there seems to be a compelling argument for defining C++’s wchar_t to be 32-bits long.)<br><br>But it turns out that the stuff I wrote using the word “seems” is an over-simplification.&nbsp; Unicode has code-points that correspond to combining characters.&nbsp; Such characters combine with a previous code-point (or sequence thereof) to present to the user what appears to be a single character.&nbsp; Section 2.11 of the Unicode 5.0 spec provides lots of examples of different combining characters, in different languages.&nbsp; From a font-rendering glyph selection point of view, or from the point of a view of a user attempting to move a text cursor from character to character, a single glyph or character may correspond to a sequence of multiple UCS-4 code-points, and thus multiple UTF-32 code-units.&nbsp; Given that such situations exists, an internationally-robust program working with a UTF-32 string must be prepared for the concept that multiple-code code-units or code-points correspond to the user’s concept of a single character.<br><br>But if our program needs to deal with the possibility of a user’s concept of a character corresponding to multiple code-units, then the apparent advantage to the programmer of using a UTF-32 representation instead of a UTF-16 one goes away. (And given the real-world size advantages of UTF-16, it now seems that making wchar_t be 16 bits is a better choice than making it be 32-bits.)<br><br>Whether you choose UTF-16 or UTF-32 encoding, suppose you want to spec a file format that can be easily displayed, but for which a viewer program can easily support text selection.&nbsp; You could ask the viewer program to build in lots of smarts to determine where a logical caret-stop can occur.&nbsp; Or you can ask the program that built the file to encode the caret-stop information within the file itself, reducing the burden on the viewing program.</font></i><br></p>
</blockquote>
<p>This is really a great summary of the issues surrounding the UTF-16 vs. UTF-32 debate, as well as the whole UCS-2 vs. UTF-16 one I have been covering already. I can't really take full credit for his knowledge in this area since I was just one of several sources, but Iike now I'm in there somewhere and it is always good to know when one has been helpful in influencing an influencer (which indirectly puts me in mind of both the <b><a href="http://archives.miloush.net/michkap/archive/2008/03/08/8113913.html" mce_href="http://archives.miloush.net/michkap/archive/2008/03/08/8113913.html">influence vs. impact</a></b> issue and the fact that Ms. Phair might be wrong about <b><a href="http://archives.miloush.net/michkap/archive/2008/11/08/9053209.html" mce_href="http://archives.miloush.net/michkap/archive/2008/11/08/9053209.html">the influence of an Ant in Alaska</a></b>, sometimes!).<br></p>
<p>Now as to whether storing the information about the carets stops explicitly versus calculating them via a StringInfo-type technique (<a href="http://msdn.microsoft.com/library/system.globalization.stringinfo.aspx" mce_href="http://msdn.microsoft.com/library/system.globalization.stringinfo.aspx">StringInfo</a> is something I have talked about previously, in blogs like <b><a href="http://archives.miloush.net/michkap/archive/2005/04/29/413366.html" mce_href="http://archives.miloush.net/michkap/archive/2005/04/29/413366.html">this one</a></b>) is an interesting one.</p>
<p>Really in the end it depends on whether you think the pure "derived from Unicode data" answer is sufficient or whether you have additional sources of information. In the particular case Jerry was thinking of, they rely on much more sophisticated methods, such that constantly calculating on the fly could really impact performance. Since the data itself in his case is read-only there was never worry about the potential need for recalculation so the calc-once obnly and store the information was a no-brainer for them.</p>
<p>But even in a read-write situation, providing a sorted array of indexes for easy enumeration that allows for</p>
<ul>
<li>enumeration in either direction (for cursor movement and selection operations), and<br></li>
<li>insertion (for the insertion of text), and <br></li>
<li>deletion (for the deletion of text), and</li>
<li>an initial population that will be already sorted (for a string with no data that needs to build up its initial cache)<br></li>
</ul>
<p>is really just an ordinary interview question in disguise, and one that is pretty easily solved, too. Were it even vaguely "international" I'd say we should solve it here, but it's not so I'll leave that as an exercise for whoever feels that they need the exercise. :-)</p>
<p>Though of course I'll point a few issues to keep in mind for anyone who would want to implement such a cache....</p>
<p>Obviously one has to be ready to re-order the items after the point of change for the insertion/deletion case. this could be expensive, depending on where the action is happening and how mush text follows it (when to move to slightly more complex schemes then the doubly linked list that the initial problem suggests is also left as an exercise!).<br></p>
<p>But less obviously, in the area immediately preceding and following the insertion point, one can potentially need to recalculate caret stops due to changes in the text. For example if one has the letters "abcdef" then one will have seven indices (covering the points before each caret stop as one moves across the string, plus one for the end):<br></p>
<p>{0, 1, 2, 3, 4, 5, 6} </p>
<p>Then if one decides to add a combining umlaut after the initial "e", the new string is "abcdëf" and the indices would now have to be:</p>
<p>{0, 1, 2, 3, 4, 6, 7}</p>
<p>and so on. And in other cases a formerly combining character before or after might now not be....<br></p>
<p>From there the exact methods used for calculation of caret stops and how to integrate them together comes into play, as does how the different methods [might] interact. It really can become a rather fascinating technical question, in the end. Though mostly not for this blog, except more on the various methods eventually. :-)<br></p>
<p>Getting back to the series for a second, there are a few points left to cover, such as the actual means of support and then the whole UTF-8 question (which is still fair game here!).</p>
<p>I'll cover these in upcoming blogs.... </p>
<p><br></p>
<p><font color="#ff00ff"><i>This blog brought to you by</i><font size="6"> ឿ </font><i>(<a href="http://www.fileformat.info/info/unicode/char/17bf" mce_href="http://www.fileformat.info/info/unicode/char/17bf">U+17bf</a>, aka KHMER VOWEL SIGN YA)</i></font><br></p>
<hr/><div style="margin-left: 1em"><em>no comments</em></div><hr/><p><em>referenced by</em></p><div style="margin-left: 1em"><p>2009/06/29 <a href="http://archives.miloush.net/michkap/archive/2009/06/29/9800913.html">UCS-2 to UTF-16, Part 11: Turning it up to Eleven!</a></p><p>2009/06/10 <a href="http://archives.miloush.net/michkap/archive/2009/06/10/9723321.html">UCS-2 to UTF-16, Part 10: Variation[ Selector] on a theme...</a></p><p>2008/12/16 <a href="http://archives.miloush.net/michkap/archive/2008/12/16/9223301.html">UCS-2 to UTF-16, Part 9: The torrents of breaking CharNext/CharPrev</a></p><p>2008/12/09 <a href="http://archives.miloush.net/michkap/archive/2008/12/09/9187379.html">UCS-2 to UTF-16, Part 8: It's the end of the string as we know it (and I feel ellipses)</a></p><p>2008/12/04 <a href="http://archives.miloush.net/michkap/archive/2008/12/04/9173687.html">UCS-2 to UTF-16, Part 7: If it makes the SQL Server columns too small then it made the Oracle columns either too smallER or too smallEST</a></p></div><p><em>go to <a id="newer" href="http://archives.miloush.net/michkap/archive/2008/11/24/9135043.html" title="From I SCOOT to IBOT, #5 of ?? (sometimes it is phase 3 that is ????)">newer</a> or <a id="older" href="http://archives.miloush.net/michkap/archive/2008/11/19/9116067.html" title="Apocalypse Font (aka Guess they must have picked the wrong eight characters.)">older</a> post, or back to <a href="http://archives.miloush.net/michkap/archive/index.html">index</a> or <a href="http://archives.miloush.net/michkap/archive/index.html#2008-11">month</a> or <a href="http://archives.miloush.net/michkap/archive/index.html#2008-11-24">day</a></em></p></body>
<!-- Mirrored from archives.miloush.net/michkap/archive/2008/11/24/9134826.html by HTTrack Website Copier/3.x [XR&CO'2014], Thu, 25 May 2017 00:42:35 GMT -->
</html>