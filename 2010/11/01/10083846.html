<html>
<!-- Mirrored from archives.miloush.net/michkap/archive/2010/11/01/10083846.html by HTTrack Website Copier/3.x [XR&CO'2014], Thu, 25 May 2017 00:42:34 GMT -->
<head><meta charset="utf-8" /><meta name="viewport" content="width=device-width" /><title>The consequences of being unintuitive and nonconformant</title></head><body>
<h1>The consequences of being unintuitive and nonconformant</h1>
<p><em>by Michael S. Kaplan, published on 2010/11/01 07:01 -04:00, original URI: http://blogs.msdn.com/b/michkap/archive/2010/11/01/10083846.aspx</em></p>
<hr/> <!-- Archival Source: ProcessPostNew -->
<p>It was just days ago that Weijiang asked one of those questions that comes along every now and again that makes the way things work on microsoft platforms (known to some as&nbsp;<strong>The Way Things Work&trade;</strong>) seem a little off.</p>
<p>Weijiang's question was:</p>
<p style="padding-left: 60px;"><span style="font-family: times new roman,times;"><em>Hi. I met a unexpected problem when using string.IndexOf. The following code demonstrates the problem:<br /><br /></em><span style="font-family: courier new,courier;"><strong>string r = "\ufffd\ufffd\ufffd\ufffd";<br />string tar = "a";<br />Console.WriteLine(tar.IndexOf(r));</strong></span><br /><br /><em>Can you guess the output? The output is 0, which is very weird for me. Can someone explain why? Because this has broken my program, which assume if a.IndexOf(b)&gt;= 0 Then a.Length &gt;= b.Length.<br /><br />Thanks</em></span></p>
<p>Now this question had built into it the opportunity to both correct the question and shame the technology at the same time. Usually I would never turn such an opportunity down!</p>
<p>But before I really had an opportunity to craft a response, Pavel beat me to the punch with a very well-thought-out reply:</p>
<p style="padding-left: 30px;"><span style="font-family: times new roman,times;">First of all, s.IndexOf(&ldquo;&rdquo;) always returns 0 for a non-empty s, for obvious reasons.<br /><br />Going from there, your assumption about relation between IndexOf and Length is generally incorrect, even for characters other than U+FFFD. For example, U+2060 (word joiner) and U+00AD (soft hyphen) are also treated as &ldquo;empty&rdquo;, and thus string &ldquo;\u2060\u00ad&rdquo; would be treated the same as &ldquo;&rdquo; for the purposes of culture-sensitive comparisons, which is where your result comes from. This is also the case for Equals, CompareTo and other String methods so long as you request culture-sensitive comparison. It just so happens that IndexOf does so by default, while e.g. Equals and Contains do not.<br /><br />Generally speaking, this is consistent with user expectations, since those characters are not part of the &ldquo;semantic load&rdquo; of the string as far as user is concerned. E.g. consider user copy-pasting a string with a soft hyphen (which, unless the line break occurs, is not observable to him) into the search dialog. He&rsquo;d be quite surprised if your app says that it couldn&rsquo;t find it, while he can clearly see it in the text! <br /><br />On the other hand, String.Length is a simple counter of 16-bit code units (i.e. chars), without any special treatment to some over others. If you want to match that with IndexOf, use the overload which takes StringComparison.Ordinal to explicitly request code unit comparison.<br /><br />The difference in defaults is certainly quite error-provoking, though. So much so that many .NET coding styles require always requesting either culture-sensitive or ordinal comparison explicitly (by using StringComparison or CultureInfo) for methods which permit both, even when the requested mode is the default for that particular method. </span></p>
<p>Now in addition to his excellent examples, there are other trhings I would point out. </p>
<p>Like the fact that the original assumption "<em><span style="font-family: Times New Roman;">if a.IndexOf(b)&gt;= 0 Then a.Length &gt;= b.Length</span></em>" that was broken. all one needs is examples like "\u00e5".IndexOf("\u0061\u030a") to disprove that assumption (that is <strong>a ring</strong> and <strong>a </strong>plus <strong>combining ring</strong> for those who don't speak Unicode code points.</p>
<p>In fact, that is why all the extra work went into FindNLSString to provide not only a return value like IndexOf returns but also to return the length of the found string -- since one cannot make assumptions about the length of the found string based on the length of the string one is trying to find. The extra support in FindNLSString points to a real hole in the scenario of usefulness of several potential ways one might want to utilize culturally sensitive comparisons -- a limitation that still exists in .Net even in the latest version.</p>
<p>Given the lack of this support in earlier languages like Java, it isn't that surprising that .Net hasn't considered too important to add. </p>
<p>After all, me alone clamoring for something is generally not a good enough reason to do anything, since I clamor for so many things. :-)</p>
<p>But i digress....</p>
<p>Afterwards, I sent Pavel some mail complimeneting him on his response, and he replied that he did feel like his answer was perhaps a little incomplete:</p>
<p style="padding-left: 30px;"><span style="font-family: times new roman,times;">I dodged the original question somewhat, since I didn&rsquo;t explain why U+FFFD specifically is treated as a &ldquo;noncharacter&rdquo; (newspeak seems highly appropriate here somehow). And that&rsquo;s because I don&rsquo;t know, and don&rsquo;t have any good guess as to why. Logically speaking, it&rsquo;s &ldquo;something we didn&rsquo;t know how to handle&rdquo;, so whether it was meaningful to the end user or not, we do not know. It would seem that, by considering it unimportant, we&rsquo;re making a wild guess there.</span></p>
<p>A&nbsp;dodge? He may have been harder on himself than he had to be. </p>
<p>If a person is on trial for a crime and the prosecutor's evidence relies on an illegal search, then it may&nbsp; be a <strong>technicality</strong> to get the case thrown out (and therefore ignore the fact that the crime may have been committed), but I wouldn't consider it a <strong>dodge</strong>.</p>
<p>I find it kind of cool that Pavel didn't have a good guess as to why the behavior is what it is, since when I originally did the work in FindNLSString my goal was based on my own (naive) notions of intuitive behavior, many of which were different than the behavior eventually supported by the function -- on the basis of the need to match the .Net functionality (the function was added to upport synthetic locales in .Net, so that behavior matching was considered pretty crucial from a scenario perspective).</p>
<p>It turns out that must fo the acual behavior was done for the sake of expectational behavior based on behavior in Java, since it was assumed that lots of the .Net developers may have once been Java developers. A lot like the way DOS behavior was so often CP/M based (something I found helpful when I moved from CP/M on an Osborne 1 to DO on a PC all those years ago).</p>
<p>For me the chain of evidence runs dry, for two reasons:</p>
<ol>
<li>I took the word of others that many of the edge case behaviors in .Net in general and C# in particular had a Java basis, as that fact is much more <strong>told-truth</strong> to me than <strong>truth</strong>;</li>
<li>I do not know the reasons why Java might have chosen to behave as it does, so I can't answer the next anticipated question ("Well then why does Java do it that way?").</li>
</ol>
<p>The original question, focusing on U+FFFD (REPLACEMENT CHARACTER), hits issues I have often discussed in the past in other blogs:</p>
<ul>
<li><a href="http://archives.miloush.net/michkap/archive/2005/01/18/355210.html" title="The jury will give this string no weight"><strong>The jury will give this string no weight</strong></a> on the myriad of times that a Unicode code point may have no linguistic weight in our tables</li>
<li><a href="http://archives.miloush.net/michkap/archive/2005/08/07/448924.html" title="New in Vista Beta 1: giving more strings weight"><strong>New in Vista Beta 1: giving more strings weight</strong></a>on the various improvements in the 2/3 of the weightless strings that are as they are for non-linguistic reasons</li>
<li><a href="http://archives.miloush.net/michkap/archive/2007/09/17/4950277.html" title="The torrents of U+fffd (aka When security and conformance trump compatibility and reality)"><strong>The torrents of U+fffd (aka When security and conformance trump compatibility and reality)</strong></a> on the decisions to have a whole bunch of cases where our conversions and other operations now return REPLACEMENT CHARACTER</li>
<li><a href="http://archives.miloush.net/michkap/archive/2008/11/13/9065138.html" title="No need to throw out the baby with the streamwriter; they probably could have just put in a replacement"><strong>No need to throw out the baby with the streamwriter; they probably could have just put in a replacement</strong></a>on some of the real world consequences of the new U+fffd behavior</li>
<li><a href="http://archives.miloush.net/michkap/archive/2008/04/09/8367652.html" title="Microsoft is giving this character nada weight but lotsa importance"><strong>Microsoft is giving this character nada weight but lotsa importance</strong></a>on some of the real ironies on this U+fffd behavior, and&nbsp;the problems it can cause in terms of security</li>
<li><a href="http://archives.miloush.net/michkap/archive/2008/05/11/8488020.html" title="The vector of this spam is [apparently] indeterminate"><strong>The vector of this spam is [apparently] indeterminate</strong></a> on more real world consequences, and the need for some tools to perhaps not use .Net if they did not want this behavior because of the impact on their own</li>
</ul>
<p>And it is interesting how all those various connections occurred to me after the original question -- how it all ties in together on a bunch of design different not all entirely intuitive design decisions that now have far-ranging consequences on function/method behavior and security....</p>
<hr/><p><strong>Dom</strong> on 2 Nov 2010 12:01 AM:</p><div style="margin-left: 1em"><p>Java and to some degree .Net are the main choices because they have been consistently pegged as the “safe” choice to go with for mid-level project managers in the corporate world. No one was ever fired for choosing Java or Microsoft.</p>
<p>However, there are many large distributed applications these days that run primarily with technologies like Python, PHP, et al. Even companies like Google and Yahoo are heavily invested in these technologies. Java may be the main choice for enterprise development now, but it’s days are numbered as the only stalwart option to go with.</p>
<p>Let’s face it, many of these so called “enterprise applications” could easily have been written much faster and with less overhead using technologies like Python, PHP, et al.</p>
<p>&lt;a href=&quot;<a rel="nofollow" target="_new" href="http://www.developintelligence.com/catalog/ajax-training.php">ajax">www.developintelligence.com/.../ajax-training.php&quot;&gt;ajax</a> training&lt;/a&gt;</p>
</div>
<p><strong>j</strong> on 2 Nov 2010 7:14 AM:</p><div style="margin-left: 1em"><p>The main issue is .Net inconsistently and unexpectedly forcing cultural/linguistic notions into places developers don&#39;t expect them. </p>
<p>Some framework designers clearly made the decision to include surprising behavior (culture-sensitive comparison, for example) in places that it is known that developers would expect to be ordinal comparison. </p>
<p>Something like IndexOf is not something most developers think of as linguistic. Any more than getting the character at index i is linguistic. </p>
<p>There is clearly a political/religious aspect to this kind of behavior in the .Net Framework, as in teaching developers to be more internationalizable in their programming. But it leads directly to correctness issues (like the ones discussed in this article). </p>
<p>This isn&#39;t due to dumb developers not understanding their tools, it&#39;s due to tools designers making decisions inconsistently. The String decisions violated the Principle of Least Surprise and are an antipattern IMO. </p>
<p>Only UI related and user input code shouldhave these cultural notions forced on them. &nbsp;</p>
</div>
<p><strong>Michael S. Kaplan</strong> on 2 Nov 2010 7:03 PM:</p><div style="margin-left: 1em"><p>Hey j, Note that there is a built in difference between Equals and Compare that people hate because they figure the results should be the same. Intuitve doesn&#39;t always make sense, and it isn&#39;t always correct. Many see these kinds of compromnises as Solomon suggesting the baby be cut in half, if you know what I mean.</p>
<p>ref: <a href="http://archives.miloush.net/michkap/archive/2006/08/16/702104.html" title="Something .NET does more intuitively than Windows"><strong>Something .NET does more intuitively than Windows</strong></a></p></div>
<p><strong>Pavel Minaev</strong> on 4 Nov 2010 2:30 PM:</p><div style="margin-left: 1em"><p>Personally, I think that the choice of going with a mix of culture-sensitive-by-default and culture-insensitive-by-default operations on System.String was a design mistake, but it is what we have today. If you kept an eye on .NET 4 development, there was actually an attempt to get closer to a saner model where the default at least is the same, but it was shot down because it broke too much code, and often in a quiet way.</p>
<p>What I personally take away from this is that, if I were asked to design a new String class for some framework, I&#39;d make all methods explicit about culture-sensitivity: caller has to say what he wants and take responsibility for that choice. No defaults.</p>
<p>Maybe in a few decades we&#39;ll even get there. ;)</p>
</div>
<p><strong>Michael S. Kaplan</strong> on 4 Nov 2010 3:38 PM:</p><div style="margin-left: 1em"><p>They sort of do that now -- via FxCop, every use without an explicit culture etc. is flagged.</p>
</div>
<hr/><p><em>go to <a id="newer" href="http://archives.miloush.net/michkap/archive/2010/11/02/10084569.html" title="iOS &lt;= 4.1: ±1 hour from savoir faire?">newer</a> or <a id="older" href="http://archives.miloush.net/michkap/archive/2010/10/30/10083402.html" title="Why one LIP and not another?">older</a> post, or back to <a href="http://archives.miloush.net/michkap/archive/index.html">index</a> or <a href="http://archives.miloush.net/michkap/archive/index.html#2010-11">month</a> or <a href="http://archives.miloush.net/michkap/archive/index.html#2010-11-01">day</a></em></p></body>
<!-- Mirrored from archives.miloush.net/michkap/archive/2010/11/01/10083846.html by HTTrack Website Copier/3.x [XR&CO'2014], Thu, 25 May 2017 00:42:34 GMT -->
</html>