<html>
<!-- Mirrored from archives.miloush.net/michkap/archive/2013/03/26/10405272.html by HTTrack Website Copier/3.x [XR&CO'2014], Thu, 25 May 2017 00:42:21 GMT -->
<head><meta charset="utf-8" /><meta name="viewport" content="width=device-width" /><title>Sometimes, the painful truth is that YOU'RE DOING IT WRONG™!</title></head><body>
<h1>Sometimes, the painful truth is that YOU'RE DOING IT WRONG™!</h1>
<p><em>by Michael S. Kaplan, published on 2013/03/26 07:01 -04:00, original URI: http://blogs.msdn.com/b/michkap/archive/2013/03/26/10405272.aspx</em></p>
<hr/> <!-- Archival Source: ProcessPostNew -->
<p>It all started with an innocent question. the innocent questioner asked:</p>
<p style="padding-left: 60px;"><span style="font-family: times new roman,times; font-size: large;">Can you point me to any enhancements we are building for </span><span style="font-family: times new roman,times; font-size: large;">Datetime <br /></span><span style="font-family: times new roman,times; font-size: large;">parsing (string + datetime format to a Datetime structure) for </span><span style="font-family: times new roman,times; font-size: large;">Modern <br />C++ apps in the next version of Windows?</span></p>
<p style="padding-left: 60px;"><span style="font-family: times new roman,times; font-size: large;">thanks</span></p>
<p>Our questioner came armed with&nbsp;a dangerous thing: <strong>knowledge</strong>.</p>
<p>Knowledge of the&nbsp;rich history of datetime parsing and formatting in .NET, which was required to do this support on spec, as the heir apparent to COM/OLEAUT32 in the hearts and minds of developers.</p>
<p>And&nbsp;of an even richer history of&nbsp;datetime parsing and formatting in COM/OLEAUT32, the first brave knight to extend Win32 where even Win32 would not dare to go.</p>
<p>The Windows developers knew it was</p>
<p><span style="font-size: x-large;"><strong>The wrong thing to do&trade;</strong>.</span></p>
<p>But did those Developer Division developers listen?</p>
<p>Yeah right.</p>
<p>There was a long history of each group preaching sermons that the other one would ignore.</p>
<p>It's an ironic and unfortunate fact that there is a specific subset of the population that really dislikes being told <strong>YOU'RE DOING IT WRONG&trade;</strong>!</p>
<p>It is of course the people who are, in fact, doing it wrong!</p>
<p>The questioner's innocent question went down a few blind alleys, with people asking about the customer scenario requirements, etc.</p>
<p>Then, I lost patience with the blind alleys and answered the original question directly:</p>
<p style="padding-left: 30px;"><span style="font-family: times new roman,times; font-size: large;">To answer the original question:</span></p>
<p style="padding-left: 60px;"><em><span style="font-family: times new roman,times; font-size: large;">Can you point me to any </span><span style="font-family: times new roman,times; font-size: large;">enhancements we are building for Datetime <br />parsing (string + datetime format to </span><span style="font-family: times new roman,times; font-size: large;">a Datetime structure) for <span style="font-family: times new roman,times; font-size: large;">Modern <br />C++ apps in the next version of Windows?</span></span></em></p>
<p style="padding-left: 30px;"><span style="font-family: times new roman,times; font-size: large;">AFAIK, there are no specific improvements from Windows 8.<br /><br />Michael</span></p>
<p>This answered the original question and bombed the village of the innocent questioner's hopes.</p>
<p>But there was one more message to impart, which my colleague Eric readily strafed the survivors and bayoneted the wounded:</p>
<p style="padding-left: 60px;"><span style="font-family: times new roman,times; font-size: large;">We do not support date or time parsing on purpose. Almost invariably, the legitimate scenarios around this</span><br /><span style="font-family: times new roman,times; font-size: large;">should be handled by date or time picker controls. The illegitimate scenarios abound and by not providing </span><br /><span style="font-family: times new roman,times; font-size: large;">this, we can better direct people to use a standard format that can then be unambiguously parsed.</span></p>
<p style="padding-left: 60px;"><span style="font-family: times new roman,times; font-size: large;">It seems to me that if you have to convert the format using a regex, you already know the identities of the</span><br /><span style="font-family: times new roman,times; font-size: large;">components and you might as well just handle the rest of the parsing (I&rsquo;m not sure that time_get will add </span><br /><span style="font-family: times new roman,times; font-size: large;">enough value for you. It does have limitations in the scope of the dates that it can parse (I think the upper </span><br /><span style="font-family: times new roman,times; font-size: large;">limit is 2030 right now, though they have a bug to extend that out).</span></p>
<p>I don't know about you.</p>
<p>But buried in those two paragraphs is easily the most polite</p>
<p><span style="font-size: xx-large;"><strong>YOU'RE DOING IT WRONG&trade;</strong>!</span></p>
<p>that I have ever had the pleasure of reading in my email inbox! :-)</p>
<hr/><p><strong>Joshua</strong> on 29 Mar 2013 8:14 AM:</p><div style="margin-left: 1em"><p>The point of date parsing is to read user-entered dates. We are naïve if we can conclude these always come from something presenting the date picker control.</p>
</div>
<p><strong>Matthew Slyman</strong> on 15 Apr 2013 3:42 AM:</p><div style="margin-left: 1em"><p>Hah! I love this post! It&#39;s so true.</p>
<p>I developed a SQL database for one client (with non-technical but mostly reasonably smart end-users) where I insisted, for reasons of non-ambiguity, that we must use the date format &quot;YYYY-MM-DD&quot; throughout the entire application front-end. (Curse you Americans for muddying the waters with &quot;MM-DD-YYYY&quot;, and for making that the default date-parsing method in many old versions of MS Office programs! I can&#39;t even count how many SQL databases and spreadsheets I&#39;ve found over the years with serious data discrepancies arising from faulty/ambiguous/inconsistent parsing of dates!!! WORST of all, I remember several such cases where MS Access or Excel would silently convert all CSV-imported dates as per &quot;MM-DD-YYYY&quot;, wherever Gregorian calendar dates could be interpreted in that way, but otherwise, would follow &quot;DD-MM-YYYY&quot; within the same data-set!!!) AAAAARRRRRRRRGGGGGGGGGGGHHHHHHHHHHHH!!!!! Michael, will you give the &quot;innocent questioner&quot; a big slap in the face please from Europe (or, from everywhere in the world except North America); unless of course they implicitly meant that Access/Excel should either be internally consistent or otherwise throw errors and warnings for cases like these?</p>
</div>
<p><strong>Matthew Slyman</strong> on 15 Apr 2013 5:43 AM:</p><div style="margin-left: 1em"><p>p.s. Said SQL database customer got fed up with YYYY-MM-DD (due to repeated errors by data-entry staff who weren&#39;t used to the canonical SQL date format); and eventually insisted on switching to DD-MM-YYYY. So instead of hard-coding this format into my application, I wrote a module that read Windows date-format preferences via the API, and then applied that throughout Access/VBA. I wasn&#39;t going to get caught out if this company employed some American-educated folk at some point in the future...</p>
<p>AMERICANS: Please note, there are other places in the world!</p>
</div>
<p><strong>Matthew Slyman</strong> on 15 Apr 2013 7:19 AM:</p><div style="margin-left: 1em"><p>@Joshua: &quot;User-entered dates&quot; in what?</p>
<p>i.e., What might the user enter dates into???</p>
<p>I&#39;ve thought about this question a fair bit myself (in fact, I&#39;ve built a date-parsing system that was reasonably successful at reading plain English text and detecting/identifying dates and times). I reckon that the best example cases for a requirement for date-parsing are where one must interface with legacy systems like email that can&#39;t easily be changed for everyone; or, where one must interface with non-technically-minded human beings who sometimes do silly things that can&#39;t be trained out of them, like, typing appointment information in English into the plain-text description-field of an appointment before specifying the same information in action date and time fields.</p>
<p>The very best example application I can think of is email... Imagine receiving an email from someone suggesting a meeting (without attaching an actual MS Office meeting request or anything similar) where the email client automatically detects (using an array of regular expressions etc.) the date and time (if applicable) of the proposed appointment (taking into account factors such as when the email was sent, which time-zone it was sent from, and where the proposed meeting is likely to be so which time zone the appointment is in). Even just going by the second half of this last sentence (before counting daylight savings transitions, non-Gregorian calendars, multi-cultural/multi-lingual societies, Mars-24 time, the communication habits of individual contacts and all that jazz), you should at least BEGIN to understand some of the potential foibles with this sort of application!</p>
<p>Even if you cannot understand the complexity of the above, I hope you can at least acknowledge that any practical, broadly applicable plain-language date-parsing system is going to take a lot more processing power (ergo, make a much bigger hit on mobile device battery life) than the equivalent user-interface offering a simple unambiguous date-picker.</p>
<p>Mr. Kaplan&#39;s point is that date/time based applications that don&#39;t have a date-picker control are DOING IT WRONG! If you want me to support you against him and his mates, you&#39;ll have to come up with better applications than I can think of... Until then, I&#39;ll concur with his opinion that date-parsing belongs in applications like Nuance OmniPage, rather than in Windows itself; because the methods of date-parsing you will favor (and the patterns you prioritize) are fundamentally connected with your application or even with the specific data set you are working on at the moment.</p>
</div>
<hr/><p><em>go to <a id="newer" href="../27/10405277.html" title="Microsoft Word: 15 --- Microsoft Windows: 15">newer</a> or <a id="older" href="../25/10405053.html" title="Microsoft Word: 15 -- Microsoft Windows: 0">older</a> post, or back to <a href="../../../index-2.html">index</a> or <a href="../../../index-2.html#2013-03">month</a> or <a href="../../../index-2.html#2013-03-26">day</a></em></p></body>
<!-- Mirrored from archives.miloush.net/michkap/archive/2013/03/26/10405272.html by HTTrack Website Copier/3.x [XR&CO'2014], Thu, 25 May 2017 00:42:21 GMT -->
</html>