<html>
<!-- Mirrored from archives.miloush.net/michkap/archive/2005/09/13/465228.html by HTTrack Website Copier/3.x [XR&CO'2014], Thu, 25 May 2017 00:42:41 GMT -->
<head><meta charset="utf-8" /><meta name="viewport" content="width=device-width" /><title>Here is an interview question for you. :-)</title></head><body>
<h1>Here is an interview question for you. :-)</h1>
<p><em>by Michael S. Kaplan, published on 2005/09/13 17:17 -07:00, original URI: http://blogs.msdn.com/michkap/archive/2005/09/13/465228.aspx</em></p>
<hr/> <!-- Archival Source: ProcessPostOld -->
<P><FONT face=Tahoma>I am not doing interviews at the moment, but I could actually see using this one (another question will come along by the next time I an interviewing someone, so I don't think I am losing too much). But I thought I would ak it here for those who love a challenge.</FONT></P>
<P><FONT face=Tahoma>Remember the <A href="http://msdn.microsoft.com/library/en-us/winui/winui/windowsuserinterface/resources/strings/stringreference/stringfunctions/charnext.asp">CharNext</A> function? I talked about how it could be useful <a href="http://archives.miloush.net/michkap/archive/2005/01/14/352802.html">here</A>&nbsp;and how we broke it <a href="http://archives.miloush.net/michkap/archive/2005/01/30/363420.html">here</A>. Yes, it is fixed in Vista....</FONT></P>
<P><FONT face=Tahoma>Anyway, imagine the functionality -- we want a function that will increment us by one character, what the user might think of as a character.</FONT></P>
<P><FONT face=Tahoma>So, let us say that you have full access to the <A href="http://msdn.microsoft.com/library/en-us/winui/winui/windowsuserinterface/resources/strings/stringreference/stringfunctions/getstringtypew.asp">GetStringTypeW</A> function so you can find out all about characters. Now go ahead and write the CharNext function.</FONT></P>
<P><FONT face=Tahoma>And that part is easy enough that I'll make it a little harder. Pretend there is (in addition to the C3_DIACRITIC and C3_NONSPACING flags) flags for C3_HIGHSURROGATE and C3_LOWSURROGATE. So you can take care of supplementary characters as well.</FONT></P>
<P><FONT face=Tahoma>Ok, ready. set. Go!</FONT></P>
<hr/><p><a id="465306" href="#465306">#</a> <strong>Shaun Bedingfield</strong> on Tuesday, September 13, 2005 10:12 PM:</p><div style="margin-left: 1em">What language? Which sort order?  (Sql Server: collation?)  <br><br>When people ask you to do anything, the best response is usually a question.  <br><br>ie.  If someone asks you how to compress something.. <br><br>What type of compression?  Run length encoding?  Huffman encoding?  Pattern based (vector format encryption ie. bmp to vector format graphics)?  What does the data look like?  Usage patterns?</div>
<p><a id="465325" href="#465325">#</a> <strong>Michael S. Kaplan</strong> on Tuesday, September 13, 2005 10:33 PM:</p><div style="margin-left: 1em">Good questions, Shaun. I guess if I am looking for someone to rewrite CharNext then I am looking for C or C++, but since it is being treated as if it were an interview question I would accept any language. The Win32 function assumes the locale, so the new one probably should too.... No compression needed -- you are returning a pointer inside the string. You can actually look at the CharNext doc topic for spec details if you like. :-)</div>
<p><a id="465363" href="#465363">#</a> <strong>James Todd</strong> on Tuesday, September 13, 2005 11:48 PM:</p><div style="margin-left: 1em">Looking at the documentation for GetStringTypeW from the link you provide, it does define flags for C3_HIGHSURROGATE and C3_LOWSURROGATE. Or am I misunderstanding what you mean?<br><br>James</div>
<p><a id="465442" href="#465442">#</a> <strong>Michael S. Kaplan</strong> on Wednesday, September 14, 2005 2:00 AM:</p><div style="margin-left: 1em">Hi James -- Yep, newly added for Vista. :-)</div>
<p><a id="465598" href="#465598">#</a> <strong>Serge Wautier</strong> on Wednesday, September 14, 2005 3:16 AM:</p><div style="margin-left: 1em">&gt; When people ask you to do anything, the best response is usually a question.<br><br>Shaun, no offense intended but...<br>I just plain disagree with you. If I were the interviewee, these questions would just help you get burned. Because these questions show you're a programmer, not a developer: They can all be answered from the context.<br>And regarding your compression example, I'd rather ask questions such as: &quot;What's more important : compression efficiency or low development budget ?&quot; And then I'd justify the choice for a method accordingly.</div>
<p><a id="466233" href="#466233">#</a> <strong>Shaun Bedingfield</strong> on Wednesday, September 14, 2005 1:29 PM:</p><div style="margin-left: 1em">The compression part was just an example of asking questions to make sure you are solving the right problem.<br><br>I guess that you could look at questions as superfluous but in development solving the right problem is often more important than solving 'a' problem at least in my opinion.<br><br>Finding the next character is kind of silly in many contexts should kanji come after English?  Does this make sense at all?  Yes, you can assume we mean the next highest character in unicode but that is rather naive.  I didn't mean language as far as C++, C#.. I meant language as far as Korean, Hebrew, etc.  The next character is highly context sensitive.  I guess for character next, I would probably get the user's code page or set language.  Then, find the corresponding sort order.  If the current character is not a character in their language, I would return an error or else find the next character in the language's sort order.  Of course, I could be wrong about what Mike wants which is why I ask questions.<br><br>As far as compression efficiency versus low budget.. Efficiency can be defined as time to compress, size of compressed image, etc.  Budget may be a buy versus build trade off or it may mean balancing the time to implement the algorithm versus the efficiency in several different terms.  <br><br>I don't think I would want to encrypt a text file using &quot;lossy&quot; encryption.  Of course, maybe encryption in that case could be a tool that presents a summary of a document or rewords sentences to &quot;meaning&quot; equivalent shorter versions. It could also look for sentences that state the same thing (maybe authors don't proofread) and delete the copies.  Depending on your customers, any of these might be an innovative solution.<br><br>A good developer asks questions and figures out what they need to build before they start coding.  A bad developer assumes they know what the interviewer or customer wants and starts coding off the bat.  So I guess we would have to agree to disagree.  It is easy to assume all questions can be answered from contextual hints but I don't think that is the typical case.<br><br></div>
<p><a id="466247" href="#466247">#</a> <strong>Mihai</strong> on Wednesday, September 14, 2005 1:46 PM:</p><div style="margin-left: 1em">&gt; the best response is usually a question<br>Depends on the question :-)<br>Bad questions show you are playing with smoke and mirrors. Only good questions get you points.<br><br>And almost all your questions look like smoke :-)<br></div>
<p><a id="466403" href="#466403">#</a> <strong>Shaun Bedingfield</strong> on Wednesday, September 14, 2005 3:39 PM:</p><div style="margin-left: 1em">That hurts.. even though my questions were only sample questions and most people misread my first post as only the first 3 questions actually corresponded to the question at hand and the others were attempts to show how to ask intelligent questions when given a problem (in this case compressing something).  The second was admittedly a very generic problem.<br><br>My biggest problem with recruiters and people in general is that most people misread or misinterpret what I say.  This really hurts me on interviews even when I do know what I am talking about.  <br><br>I was told I knew nothing about object oriented analysis and design even though I have been studying it for years and blew everyone else away in a master's level OOA&amp;D class.  I also have produced some very good OOA&amp;D designs.  Oh, and this was for an entry level job where they were expecting someone with almost no exposure to OOA&amp;D. <br><br>I can talk to senior level people and have them in awe about my skills and then be told by a beginner that I don't know ***.<br><br>Now is the point where people usually jump at me and say, &quot;No, I understood what you said and it is full of sh*t.&quot;  Let me put it this way, yes, you probably misunderstood me and no it is probably not your fault.<br><br>I have Asperger's syndrome.  I think differently than almost everyone else.  This means that while what I say is often literally correct, almost everyone misinterprets me because I do not understand the connotations everyone else reads in.  I will not tell you how difficult this makes my life.  I have heard of people with phDs and Asperger's who have gone over 20 years without a job because they cannot communicate that they know what they know.<br><br>I have a genius level IQ and I was told that I was retarded most of my life.  I have failed homework assignments where my proof was identical to those who aced them because the graders didn't understand me.  <br><br>I had friends all through high school and most of college calling me the next Bill Gates and I can't find a job.  <br><br>Ok, what does this mean to you.. probably nothing and I probably still am full of shit and don't know a damn thing about programming but I really wish I could get someone to believe me.</div>
<p><a id="466416" href="#466416">#</a> <strong>Michael S. Kaplan</strong> on Wednesday, September 14, 2005 3:48 PM:</p><div style="margin-left: 1em">I guess I am most hurt by the fact that no one wanted to treat it like a pseudo-interview question to solve. I wanted to compare what I came up with to what other people did. :-)</div>
<p><a id="466426" href="#466426">#</a> <strong>Shaun Bedingfield</strong> on Wednesday, September 14, 2005 3:55 PM:</p><div style="margin-left: 1em">I am sorry Michael, I just get upset when people make thinly vieled personal attacks.<br><br>I was trying not to move things off subject but I feel obligated to respond to certain items.</div>
<p><a id="466427" href="#466427">#</a> <strong>Michael S. Kaplan</strong> on Wednesday, September 14, 2005 3:55 PM:</p><div style="margin-left: 1em">Shaun, no worries. I was not offended anyway. :-)<br><br>You don't sound full of it or retarded to me, fwiw.<br><br>But I answered your questions and you did not follow up with your answer to the question....</div>
<p><a id="466432" href="#466432">#</a> <strong>Shaun Bedingfield</strong> on Wednesday, September 14, 2005 3:59 PM:</p><div style="margin-left: 1em">I am also sorry for not reading it completely..  <br><br>I just saw increment a character and didn't note that you meant increment a character position.</div>
<p><a id="466455" href="#466455">#</a> <strong>Shaun Bedingfield</strong> on Wednesday, September 14, 2005 4:32 PM:</p><div style="margin-left: 1em">I am not sure this is correct but this is my first stab.. I am not a language junky so have fun.  I bet I am wrong.<br><br>// okay, I hope I know what these characters mean..<br>// I wonder why I don't work in localization<br>// I do have a nifty web page pattern for localization in dev at the<br>// moment though<br>LPTSTR CharNext(          LPCTSTR lpsz)<br>{<br>	// regular characters so just get the next character<br>	if(sizeof(lpsz[0]) == sizeof(char))<br>		retun lpsz[1];<br><br>	// we are at the end of the string<br>	if(lpsz[0] == '\0')<br>		return lpsz;<br><br>	WORD characterinfo;<br><br>	// See if we have a high surrogate<br>	if(GetStringType1(CT_CTYPE3, lpsz, 1, &amp;characterinfo))<br>	{<br>		// high surrogate must be followed by a low surrogate<br>		if((characterinfo &amp; C3_HIGHSURROGATE) != 0)<br>			if(wcslen(lpsz) &gt;= 2) // remember the null 0<br>				lpsz = lpsz[2];	// eat two characters<br>			else <br>				lpsz = lpsz[1]; // go to the end<br>		else<br>			lpsz = lpsz[1]; // eat one character<br>	}<br><br>	if(wcslen(lpsz) &gt; 0 &amp;&amp; GetStringType(CT_CTYPE3, lpsz, 1, &amp;characterinfo))<br>	{<br>		// eat extra diacritical or nonspacing characters<br>		// I think there can only be 1<br>		// I am just guessing that a diacritic can follow a surrogate pair<br>		if(((characterinfo &amp; C3_DIACRITIC) |<br>			(characterinfo &amp; C3_NONSPACING)) != 0)<br>		lpsz = lpsz[1];<br>	}<br><br>	return lpsz;	<br>}<br></div>
<p><a id="466471" href="#466471">#</a> <strong>Mihai</strong> on Wednesday, September 14, 2005 5:00 PM:</p><div style="margin-left: 1em">Shaun --<br>Sorry Shaun, but from my &quot;playing with smoke and mirrors&quot; to your &quot;retarded&quot; is a big difference. This was definitely not my interpretation.<br><br>I agree 100% that asking questions is really good when the original question is not clear. Also, sometimes new questions might highlight hidden assumptions in the original question, assumptions that sometimes are not clear the one asking the original question.<br><br>Also, thinking differently is sometimes a disadvantage for communication, but is also a big advantage if it means creative, out of the box ideas.<br>And, in general, I think no good programmer is &quot;normal&quot; by the generally accepted standards :-)<br><br>No, let me shortly explain why I had something with your questions:<br>The request was &quot;we want a function that will increment us by one character, what the user might think of as a character&quot; ... &quot;Now go ahead and write the CharNext function.&quot;<br><br>- What language? Which sort order?<br>Language + region + sort == locale.<br>So you don't ask about language and sort order, you do what the actual CharNext does: use the current locale.<br>And, really, sort order does not affect things like CharNext.<br>And yes, Japanese mixed with English very common (see <a rel="nofollow" target="_new" href="http://www.microsoft.com/japan/msdn/campaign/">http://www.microsoft.com/japan/msdn/campaign/</a>)<br>Exactly what Sarge said: &quot;They can all be answered from the context&quot;<br><br>(Sql Server: collation?) <br>We where talking Windows API. Why bring SQL Server here?<br><br>But this would not be enough to fail an interview with me. If (after I answer your questions) you come up with something that seem to have reasonable chances to solve the problem. In general I do not expect someone to come up with my solution. It would not be fair. Maybe I am thinking daily about this problem, for the last few weeks. In fact, I think I would even like better to get 2-3 different solutions. And if you don't narrow down the problem with too many questions, then you have more space to develop &quot;if we want something with same signature with CharNext then ...&quot;, &quot;if all we care is 'technically correct', meaning don't split before combining characters or in surrogates, then ...&quot;<br><br>But in a real interview (not in writing) this is much easyer. It takes 10 seconds to clarify something. Writing is way easier to misinterpret. Especially that I am not a native English speaker (writer :-) I have tried to add smiley(s), but it did not help. <br><br>MishKa - &quot;no one wanted to treat it like a pseudo-interview&quot;<br>I had three things stopping me from doing that:<br> - not much time<br> - doing it in writing (see above)<br> - showing that in fact I know much less than what I seem to know :-)<br>But if is more like a validation of you ideas than an exercise for your readers, than I can come up with something (maybe over the week-end).<br></div>
<p><a id="466563" href="#466563">#</a> <strong>Shaun Bedingfield</strong> on Wednesday, September 14, 2005 6:50 PM:</p><div style="margin-left: 1em">To be honest, I misread the question.. and I am and was laughing a bit at myself.<br><br>I read that CharNext &quot;increments&quot; a character without looking at the actual function which just moves to the next character in a string.  In this question locale information is very important and it is possible that one character could be used in multiple locales with a different sort order and GetStringTypeW might not be much of a help.. hence my questions.<br><br>I was mainly responding to the point that &quot;these questions would get you burned&quot; as I feel that asking questions is generally something people do too little of. <br><br>I think the reason why I eventually posed the questions is because I felt the idea of a CharNext function as stated was kind of ridiculous.  Incrementing characters just does not make sense.<br><br>In this country in general, people tend to be &quot;polite&quot; which doesn't mean they are really polite but more that we phrase things as being a less severe cricisim than it really is.  I would have expected things like &quot;Did you read the question?  I might agree with your idea of asking questions but I feel that a lot of what you said lacked relevance.&quot; which is a polite way to say that you missed the boat (which I did).   Whitty statements in particular are often especially biting but made more &quot;polite&quot;.<br><br>The problem is that statements which criticize (especially whitty ones) put me on the defensive.. fast.  I have had some very mean things said to me over the years and the comment about being retarded has more to do with my actual life than the contents of the board. <br><br>Like everyone here, I sometimes don't take proper care when reading things.  On top of that, I am definitely &quot;not&quot; a morning person.<br><br>Enjoy my short code snippet.. I am not much of a localization type so it should be a fun read to see what mistakes I made.</div>
<p><a id="466587" href="#466587">#</a> <strong>Jerry Pisk</strong> on Wednesday, September 14, 2005 7:13 PM:</p><div style="margin-left: 1em">Shaun, we can't enjoy your code much as it won't even compile. The construct:<br><br>lpsz = lpsz[x];<br><br>assigns a char into a char* variable.<br><br>If compiled without UNICODE (i.e. sizeof(lpsz[0] wil be the same as sizeof(char)) your code will overrun the buffer if lpsz already points to the terminating '\0'.<br><br>I'll see if I can find more, I'm not sure whether you should be skipping diacritic marks.</div>
<p><a id="466588" href="#466588">#</a> <strong>Shaun Bedingfield</strong> on Wednesday, September 14, 2005 7:14 PM:</p><div style="margin-left: 1em">I guess I can be glad that this is not my area of expertise..<br><br>My areas of expertise are..<br><br>Design - especially hard and bleeding edge, I get bored with routine things unfortunately.. I am kind of a research developer.<br><br>Iterative Development <br><br>Algorithms and Performance Optimization - I am not the best code optimizer but I am defintely not bad.  I am really good at figuring out how to solve new problems.<br><br>Software construction - ie. programming (16+ years in C/C++ by 26.. If someone needs a programmer, I am very good).  I probably could build software faster than many teams of software engineers.<br><br>Innovative ideas and technology - I think up some really great stuff.<br><br>Learning - I am very quick at picking up new material.. very very quick.<br><br>Areas where I suck..<br><br>Communication - I can speak tech but I tend to rub people the wrong way.  I also am sometimes a bad listener and I tend to open my mouth before I think (ie. this article).  My high school UIL team sans one hated me which is the only reason I was not on it.  People also tend to think I am an ignorant jerk.  <br><br>I spend a huge amount of time trying to improve my social skills but it is frustrating.<br><br>UI - I have no idea how the average user uses software.  To be honest, I have trouble understanding how they think.. a lot of trouble.<br><br>Depression, issues, chronic illness - Yep, I have them and it doesn't help.  <br><br>If anyone wants the good and can live with bad, give me a call.  Sometimes I think I am never going to find employment.<br><br>Shaun Bedingfield<br>blogsb.blogspot.com<br>shaunbed@houston.rr.com</div>
<p><a id="466619" href="#466619">#</a> <strong>Shaun Bedingfield </strong> on Wednesday, September 14, 2005 8:06 PM:</p><div style="margin-left: 1em">Yep.. you are write..<br>It is meant to be &amp;lpsz[1].. <br><br>And yes, I am assuming you are not making char = wchar which can be done with certain flags.. You could also assume sizeof returns the size in bytes and make it equal to 1.</div>
<p><a id="466620" href="#466620">#</a> <strong>Shaun Bedingfield </strong> on Wednesday, September 14, 2005 8:07 PM:</p><div style="margin-left: 1em">Yep.. you are right..<br>It is meant to be &amp;lpsz[1].. <br>This is C++ trick to move the pointer to the next integer.<br><br>And yes, I am assuming you are not making char = wchar which can be done with certain flags.. You could also assume sizeof returns the size in bytes and make it equal to 1.<br><br>Please don't shoot me, I wrote the code in about 3 or 4 minutes.</div>
<p><a id="466630" href="#466630">#</a> <strong>Shaun Bedingfield</strong> on Wednesday, September 14, 2005 8:10 PM:</p><div style="margin-left: 1em"><br>// okay, I hope I know what these characters mean..<br>// I wonder why I don't work in localization<br>// I do have a nifty web page pattern for localization in dev at the<br>// moment though<br>LPTSTR CharNext(          LPCTSTR lpsz)<br>{<br>	// regular characters so just get the next character<br>	if((sizeof(lpsz[0]) == sizeof(char)) &amp;&amp; (sizeof(lpsz) &gt; 0))<br>		return &amp;lpsz[1];<br><br>	// we are at the end of the string<br>	if(lpsz[0] == '\0')<br>		return lpsz;<br><br>	WORD characterinfo;<br><br>	// See if we have a high surrogate<br>	if(GetStringTypeW(CT_CTYPE3, lpsz, 1, &amp;characterinfo))<br>	{<br>		// high surrogate must be followed by a low surrogate<br>		if((characterinfo &amp; C3_HIGHSURROGATE) != 0)<br>			if(wcslen(lpsz) &gt;= 2) // remember the null 0<br>				lpsz = &amp;lpsz[2];	// eat two characters<br>			else <br>				lpsz = &amp;lpsz[1]; // go to the end<br>		else<br>			lpsz = &amp;lpsz[1]; // eat one character<br>	}<br><br>	if(wcslen(lpsz) &gt; 0 &amp;&amp; GetStringTypeW(CT_CTYPE3, lpsz, 1, &amp;characterinfo))<br>	{<br>		// eat extra diacritical or nonspacing characters<br>		// I think there can only be 1<br>		// I am just guessing that a diacritic can follow a surrogate pair<br>		if(((characterinfo &amp; C3_DIACRITIC) |<br>			(characterinfo &amp; C3_NONSPACING)) != 0)<br>		lpsz = &amp;lpsz[1];<br>	}<br><br>	return lpsz;	<br>}<br></div>
<p><a id="466635" href="#466635">#</a> <strong>Shaun Bedingfield</strong> on Wednesday, September 14, 2005 8:21 PM:</p><div style="margin-left: 1em">I shouldn't have put it down without testing it first.. I didn't intend that code to actually run, it was just high level pseudocode.<br><br>Give me a second while I hit myself in the head and build a copy that will actually compile and please ignore my earlier post.</div>
<p><a id="466640" href="#466640">#</a> <strong>Shaun Bedingfield</strong> on Wednesday, September 14, 2005 8:29 PM:</p><div style="margin-left: 1em">Here it is.. This is the last time I post code before testing it.. I thought people would note things like the fact that I never changed<br>GetStringType1 to GetStringTypeW and realize that it was just low level pseudocode that I had never intended to run as is.<br><br>// okay, I hope I know what these characters mean..<br>// I wonder why I don't work in localization<br>// I do have a nifty web page pattern for localization in dev at the<br>// moment though<br>LPTSTR CharNextTest(          LPCTSTR lpsz)<br>{	<br>	// regular characters so just get the next character<br>	if(sizeof(lpsz[0]) == 1 &amp;&amp; lpsz[0] != '\0')<br>	{<br>		return (LPTSTR)&amp;lpsz[1];<br>	}<br><br>	// we are at the end of the string<br>	if(lpsz[0] == '\0')<br>	{	<br>		return (LPTSTR)lpsz;<br>	}<br><br>	WORD characterinfo;<br><br>	// See if we have a high surrogate<br>	if(GetStringTypeW(CT_CTYPE3, (LPCWSTR)lpsz, 1, &amp;characterinfo))<br>	{<br>		// high surrogate must be followed by a low surrogate<br>		if((characterinfo &amp; C3_HIGHSURROGATE) != 0)<br>			if(wcslen((const wchar_t *)lpsz) &gt;= 2) // remember the null 0<br>				lpsz = &amp;lpsz[2];	// eat two characters<br>			else <br>				lpsz = &amp;lpsz[1]; // go to the end<br>		else<br>			lpsz = &amp;lpsz[1]; // eat one character<br>	}<br><br>	if(wcslen((const wchar_t *)lpsz) &gt; 0 &amp;&amp; GetStringTypeW(CT_CTYPE3, (LPCWSTR)lpsz, 1, &amp;characterinfo))<br>	{<br>		// eat extra diacritical or nonspacing characters<br>		// I think there can only be 1<br>		// I am just guessing that a diacritic can follow a surrogate pair<br>		// diacritics follow the character so this is part of the character we already ate.<br>		if(((characterinfo &amp; C3_DIACRITIC) |<br>			(characterinfo &amp; C3_NONSPACING)) != 0)<br>		lpsz = &amp;lpsz[1];<br>	}<br><br>	return (LPTSTR)lpsz;	<br>}<br></div>
<p><a id="466646" href="#466646">#</a> <strong>Shaun Bedingfield</strong> on Wednesday, September 14, 2005 8:37 PM:</p><div style="margin-left: 1em">Um.. Mehai et al.. Can I say some really choice things about myself right now?<br><br>Let me do this..<br><br>Shaun, you are a piece of work.  You must be the greatest #$#$%J@(#* I have ever seen.  Not only do you defend your ignorance by your talkitive blathering but you feel that your utter nonsense will have persuade us to feel that a kindergartener isn't better equiped to solve this problem than you.<br><br>Let me spell this out for you.. GET A LIFE.. I have met window washers with better technical accumen?  Have you ever thought of a job as a sanitary engineer?  Don't.  The idea of you doing engineering on that level is a pathetic.  <br><br>By the way your code rox my world.. Not only does my compiler feel it is garbage but even with some considerable effort all I could get it to do is display a certain blue screen.. I do not want you anywhere near my computer.  I don't even like the color blue and you give it to me in spades.<br><br>Let me try to polite.. I really do think there is a future for you.  Stick to what you know and you should be alright.. I may even one day figure out something that you do know.. like perhaps how to butcher the english language and waste my time.<br><br></div>
<p><a id="467255" href="#467255">#</a> <strong>Maurits</strong> on Thursday, September 15, 2005 4:03 AM:</p><div style="margin-left: 1em">Here's my initial thoughts on the matter.<br><br>/* TODO:<br> * What about non-W version(s)?<br> * How to go boom, exactly?<br> * What if the string is a row of 50 nonspacing characters?<br> * Should I really return the null terminator in this case,<br> * considering them all one mega-character?<br> * Or should I blow up?<br> * Or should I return each individually as their own non-combining character?<br> * Or perhaps I should periodically call FoldString until I get a char-count of 2,<br> * and then back up one?<br> * overall this is too generous in its assumptions<br> */<br><br>LPTSTR CharNext(LPCWSTR ps)<br>{<br><br>if (ps == 0)<br>{<br>	/* go boom somehow */<br>}<br><br>/* grab GetStringTypeW info three times */<br>/* first get length of input string in wchars */<br>int l = wcslen(ps) + 1; /* +1 is for null */<br><br>/* allocate an array of 16-bit elements - one for each wchar */<br>LPWORD t3 = (LPWORD)malloc(sizeof(WORD) * l);<br><br>if (<br>	!GetStringTypeW(<br>		CT_CTYPE3,<br>		ps,<br>		l, /* or -1 I suppose */<br>		t3 /* &amp;t3[0] if you like */<br>	)<br>{<br>	/* go boom somehow */<br>	/* make sure t3 gets free()d */<br>}<br><br>BOOL found = 0;<br><br>/* start offset at 1... */<br>/* i &lt; l will stop walking off the end, even if string is just null */<br>for (int i = 1; !found &amp;&amp; i &lt; l; i++)<br>{<br>	/* is this offset ... */<br>	if (	t3[i] &amp;<br>		(<br>			C3_NONSPACING | /* a nonspacing character? */<br>			C3_DIACRITIC | /* a nonspacing diacritic? */<br>			C3_VOWELMARK | /* a nonspacing vowel mark? */<br>			C3_LOWSURROGATE /* I ASSUME ... */<br>				/* that the previous character was a high surrogate */<br>				/* so this is the second half of that character */<br>		) != 0 /* for the pedantic */<br>	)<br>	{<br>		/* yup, sure is -- NOT SUITABLE, SKIP */<br>	} else<br>	{<br>		found = 1; /* no problems, passes the test */<br>	}<br>}<br><br>if (!found)<br>{<br>	/* set offset to position of null character */<br>	i = l - 1; /* should already be this, but better safe than sorry */<br>}<br><br>free(t3);<br><br>// next character is &quot;i&quot;th away<br>// could be 0, if *ps == '\0'<br>// could be 1, 2, 3, ...<br>// note it's very possible for i != 0 and *(ps + i) == '\0'<br>// if ps was last &quot;real&quot; character but there was nonspacing stuff after<br>// or if ps was a high/low surrogate character combination<br>return ps + i;<br><br>}</div>
<p><a id="467257" href="#467257">#</a> <strong>Maurits</strong> on Thursday, September 15, 2005 4:05 AM:</p><div style="margin-left: 1em">ROFL the comments box eats leading whitespace on every line :) :) :)</div>
<p><a id="467314" href="#467314">#</a> <strong>Maurits</strong> on Thursday, September 15, 2005 4:32 AM:</p><div style="margin-left: 1em">Hmmm... if the data string is large, GetStringTypeW will take a long time to return, even though I really only care about the second character most of the time.<br><br>Also, surrogate characters confuse me.<br><br>Suppose I had a high/low pair A/B<br>Is it possible that this high/low pair's &quot;real&quot; Unicode code point could be a nonspacing character?  If so a FoldString call or two may be necessary after all.</div>
<p><a id="467371" href="#467371">#</a> <strong>Michael S. Kaplan</strong> on Thursday, September 15, 2005 4:53 AM:</p><div style="margin-left: 1em">There are not currently any non-spacing characters off the BMP, so one could assume that case does not yet need to be handled; it is worth a thought for the future, though.... I agree that GetStringType for the whole string is usually too much; smaller calls are better.</div>
<p><a id="467407" href="#467407">#</a> <strong>Maurits</strong> on Thursday, September 15, 2005 5:10 AM:</p><div style="margin-left: 1em">OK, let me turn it around and ask you, then.<br><br>Given a properly-formed UTF-16 encoded string, how many wchar's do I need to look ahead to be sure that I see at least the start of the next character?  In your linked example you give an example of a Vietnamese character that is three wchar's long.  Are there any that are four?  Five?<br><br>I could easily take this max (say, five) and compare it to the known remaining wchar-length of the string and take the lesser of the two.<br><br>(In fact if the known remaining wchar-length of the string is 0 I can just return the input pointer and leave it at that.)<br><br>But the thing that really bugs me is...<br><br>Suppose I have an invalid Unicode string that is nothing more than a very long series of the same combining-character code point?  Should I throw an error?</div>
<p><a id="467415" href="#467415">#</a> <strong>Michael S. Kaplan</strong> on Thursday, September 15, 2005 5:14 AM:</p><div style="margin-left: 1em">Well, the best way to handle it (in my opinion) is to go one at a time, always. In the truly abberant case of the long series of diacritics, it will be slightly slower, but there is no need to optimize for the abberant cases....</div>
<p><a id="467470" href="#467470">#</a> <strong>Maurits</strong> on Thursday, September 15, 2005 5:37 AM:</p><div style="margin-left: 1em">Take two... if you like I could email you a .txt version of this so you can fully appreciate my magnificent indentation technique ;) ;) ;)<br><br>LPTSTR CharNext(LPCWSTR ps) <br>{ <br><br>if (ps == 0) <br>{ <br>	/* go boom somehow -- string pointer is null */ <br>}<br><br>if (*ps == '\0') /* zero-length string */<br>{<br>	return ps; /* already at end of string */<br>}<br><br>int l = wcslen(ps); /* no +1 necessary this time around */<br><br>/* start checking at wchar after this one (ps + 1) */<br>/* note i &lt; l condition still holds - just doesn't check the '\0' this time */<br>for (int i = 1; i &lt; l; i++)<br>{<br><br>	WORD t; /* just one please */<br>	if (<br>		!GetStringTypeW( <br>			CT_CTYPE3, /* only CT_CTYPE3 is interesting */ <br>			ps + i, <br>			1, /* JUST 1 */<br>			&amp;t /* forgive me for skipping the array nonsense */<br>		)<br>	)<br>	{ <br>		/* go boom somehow -- GetStringTypeW failed */ <br>	} <br><br>	/* is this wchar... */ <br>	if (	t &amp; <br>		(<br>			C3_NONSPACING | /* a nonspacing character? */ <br>			C3_DIACRITIC | /* a nonspacing diacritic? */ <br>			C3_VOWELMARK | /* a nonspacing vowel mark? */ <br>			C3_LOWSURROGATE /* see following note */<br><br>/* I ASSUME, for C3_LOWSURROGATE <br> * that the previous character was a high surrogate<br> * so this is the second half of that character<br> * TODO: production code should check ALSO check for C3_HIGHSURROGATE<br> * then pull the two halves of the pair together<br> * and join them (via FoldString)<br> * then check whether that joined character is a nonspacing character<br> * there aren't any yet<br> * but who knows what the Consortium will do in the future?<br> * probably still within scope of an interview question to expect this<br> * but I'm a little tired ;)<br> */<br><br>		) != 0 /* for the pedantic */ <br>	) <br>	{ <br>		/* yup, sure is -- NOT SUITABLE, SKIP */<br>		/* I'm sorely tempted to keep a counter of */<br>		/* consecutive nonspacing or surrogate characters */<br>		/* if it gets higher than (say) seven, go boom */<br>		/* better to error on insane data sooner than later */<br>	} else <br>	{ <br>		/* found it!  break to avoid i++ */<br>		break; /* is there a &quot;for&quot; break in Microsoft C? */<br>	}<br>}<br><br>/* biggest i could be is l - in this case ps + i is the '\0' wchar */<br><br>return ps + i; <br><br>}<br></div>
<p><a id="467474" href="#467474">#</a> <strong>Maurits</strong> on Thursday, September 15, 2005 5:54 AM:</p><div style="margin-left: 1em">/* I'm sorely tempted to keep a counter of */ <br>/* consecutive nonspacing or surrogate characters */ <br><br>Duh, it's called &quot;i&quot; (or technically, i - 1)<br><br>So add the following lines of code:<br><br>#define MAX_WCHARS_BETWEEN_CHARACTERS 7 /* say */<br>...<br>/* MAX_ stops for loop from spinning too many times on big bad data */<br>for (int i = 1; i &lt; l &amp;&amp; i &lt; MAX_WCHARS_...; i++)<br>{<br>...<br>}<br><br>if (i &gt;= MAX_WCHARS_...)<br>{<br> /* blow up */<br>}<br><br>return ps + i;</div>
<p><a id="467515" href="#467515">#</a> <strong>Shaun Bedingfield</strong> on Thursday, September 15, 2005 7:28 AM:</p><div style="margin-left: 1em">I am really sorry for the mood in my posts yesterday.  I am near suicidal and I am going to post my farewells before I blow up and tick off too many people.<br><br>I am going to take a vacation from everything for a while.<br><br>You can read details at blogsb.blogspot.com which I am closing.<br><br>Hopefully, I will return someday.</div>
<p><a id="467541" href="#467541">#</a> <strong>Michael S. Kaplan</strong> on Thursday, September 15, 2005 8:53 AM:</p><div style="margin-left: 1em">Shaun -- I will say it once more if you are still reading -- there are no worries about anything you said. I assume you don't believe me, but I really hope you will. I've yet to find a line of code worth that high of a price....</div>
<p><a id="467548" href="#467548">#</a> <strong>Michael S. Kaplan</strong> on Thursday, September 15, 2005 8:57 AM:</p><div style="margin-left: 1em">Hi Maurits -- by using a wcslen in there, you are walking the entire string when in almost all non-abberant cases you never need to walk past a WCHAR or two. It might be best to make sure that only the people who cause such a need are the ones who have to pay a penalty, from a perf. standpoint....<br><br>Also, I am really unconvinced about MAX_WCHARS_BETWEEN_CHARACTERS because if they have 50 discritics after a letter then they may just be wanting to test the limits of the function, and we do not currently doc such a limit....</div>
<p><a id="467583" href="#467583">#</a> <strong>Shaun Bedingfield</strong> on Thursday, September 15, 2005 9:30 AM:</p><div style="margin-left: 1em">No, this is personal.  I haven't been able to find a job in 4 years and I hate myself, blame myself, etc.  I am starting to believe I am a loser and I am being very mean to myself at the moment.  It's my problem.  I just don't want to involve others in World War 3 (sans world)<br><br>Good point by the way on wcslen.  If you have to call it, it might be best to only call it once.  Though it doesn't have to be as slow as a CharNext walk as you can use SIMD calls to really speed it up.  Doing things like bit masks to check multiple bytes at a time.  I totally forgot about that in my code.  Pascal strings don't have this problem as the length is the first character.  Of course since the parameter is a constant, a good compiler might be able to optimize the call to wcslen away.  If it is constant in the program, the compiler will be able to supply the length.  Also if the code is being used via interop, the compiler may be able to find the string length when passed in.<br><br>Recoding the thing in assembly or an unsafe cast to an array of 64 bit integers, you could read multiple WCHARs at once. By avoiding GetStringTypeW and using actual masking to get the diacritics, etc yourself you could also test multiple characters at once.  It would be easy to make this point to a hash which points to array (ie. hashtable) and then figure out how many characters to skip.  <br><br>So 4 characters in one read and a couple logical ops which is really fast..  You can also detect null 0s using binary ands since they are 0s.  Basically, first check to see if the run has any 0s and if so find the first null 0.  This will work unless the architecture you are building for coughs when the allocated memory for the string is exceeded.  In this case you can still use longs (most of the time) but you need additional checking for boundary conditions.<br><br>MAXCHAR is beautiful but unfortunately it is not perfect and can still lead to flaws.  You really need to check how much memory is allocated for the string and check when that is exceeded for perfect code.  Unfortunately, I know of no quick way to do this.  So really you are usually stuck depending on the coder having the null zero there.  MAXCHAR might keep the program from crashing but you might still get a buffer overflow.  Why do you think StrSafe has character counts?<br><br>Most of the time, you do not want the routine to blow up.. My advice is have it return the original string and SetLastError if people need to find out if something occurs.<br><br>I could rewrite this and make it really fast but I didn't get any sleep last night.  I was mad at myself.</div>
<p><a id="467586" href="#467586">#</a> <strong>Shaun Bedingfield</strong> on Thursday, September 15, 2005 9:37 AM:</p><div style="margin-left: 1em">Silly me with no sleep.. Use sizeof to find out how big the buffer is... <br><br>A good sizeof function does not have to read the string to find the sizeof.. The sizeof is stored in the memory alocation tables.</div>
<p><a id="467637" href="#467637">#</a> <strong>Maurits</strong> on Thursday, September 15, 2005 11:27 AM:</p><div style="margin-left: 1em">I know I'm on the right track because my code keeps getting shorter. :)<br><br>/*<br> * TODO: C3_HIGHSURROGATE<br> * What on earth is C3_NOTAPPLICABLE?<br> * I can't even test for it, it's a zero bit<br> * Wait... let me guess...<br> * GetStringTypeW(CT_CTYPE3, &amp;'\0', 1, &amp;t) puts t = C3_NOTAPPLICABLE<br> * so it's a null sentinel<br> *<br> */<br><br>LPTSTR CharNext(LPCWSTR ps)<br>{<br><br>	if (ps == 0)<br>	{<br>		/* go boom somehow -- string pointer is null */<br>	}<br><br>/* hope we don't get dropped in a sea of diacritics<br> * or this &quot;for&quot; could last a long, long time<br> */<br>	for(; *ps != '\0'; ps++)<br>	{<br>		/* There are arguments for and against pre-declaring t */<br>		WORD t; /* just one please */<br>		if (<br>			!GetStringTypeW(<br>				CT_CTYPE3, /* only CT_CTYPE3 is interesting */<br>				ps,<br>				1, /* JUST 1 */<br>				&amp;t /* forgive me for skipping the array nonsense */<br>			)<br>		)<br>		{<br>			/* go boom somehow -- GetStringTypeW failed */<br>		}<br><br>		/* is this wchar... */<br>		if (	t &amp;<br>			(<br>				C3_NONSPACING | /* a nonspacing character? */<br>				C3_DIACRITIC | /* a nonspacing diacritic? */<br>				C3_VOWELMARK | /* a nonspacing vowel mark? */<br>				C3_LOWSURROGATE /* see following note */<br>				/* The beauty of this is it compiles to a constant */<br>			) != 0 /* for the pedantic */<br>		)<br>/* TODO: production code should check for C3_HIGHSURROGATE and peek<br> * If the one after a high surrogate is a low surrogate that's a malformed wide string<br> */<br>		{<br>			/* semantic continuation of the previous wchar - skip it */<br>		} else<br>		{<br>			/* found it! break to avoid ps++ */<br>			break; /* is there a &quot;for&quot; break in Microsoft C? */<br>		}<br>	}<br><br>/* Made it out of the for loop<br> * this might be the null terminator or it might be the next real character<br> */<br>	return ps;<br><br>}</div>
<p><a id="467649" href="#467649">#</a> <strong>Maurits</strong> on Thursday, September 15, 2005 11:36 AM:</p><div style="margin-left: 1em">Er,<br>If the one after a high surrogate is a low surrogate that's a malformed wide string<br>should of course be<br>If the one after a high surrogate is not a low surrogate that's a malformed wide string</div>
<p><a id="467652" href="#467652">#</a> <strong>Maurits</strong> on Thursday, September 15, 2005 11:49 AM:</p><div style="margin-left: 1em">last code is missing a ps++ in the beginning...<br><br>LPTSTR CharNext(LPCWSTR ps)<br>{<br><br>	if (ps == 0)<br>	{<br>		/* go boom somehow -- string pointer is null */<br>	}<br><br>	if (*ps == '\0') { return ps; } /* at end of string */<br><br>	for(ps++; *ps != '\0'; ps++)<br>	{<br>		WORD t; /* just one please */<br>		if (<br>			!GetStringTypeW(<br>				CT_CTYPE3, /* only CT_CTYPE3 is interesting */<br>				ps,<br>				1, /* JUST 1 */<br>				&amp;t /* forgive me for skipping the array nonsense */<br>			)<br>		)<br>		{<br>			/* go boom somehow -- GetStringTypeW failed */<br>		}<br><br>		/* is this wchar... */<br>		if (	t &amp;<br>			(<br>				C3_NONSPACING | /* a nonspacing character? */<br>				C3_DIACRITIC | /* a nonspacing diacritic? */<br>				C3_VOWELMARK | /* a nonspacing vowel mark? */<br>				C3_LOWSURROGATE /* see following note */<br>				/* The beauty of this is it compiles to a constant */<br>			) != 0 /* for the pedantic */<br>		)<br>/* TODO: production code should check for C3_HIGHSURROGATE and peek<br> * If the one after a high surrogate is not a low surrogate that's a malformed wide string<br> */<br>		{<br>			/* semantic continuation of the previous wchar - skip it */<br>		} else<br>		{<br>			/* found it! break to avoid ps++ */<br>			break;<br>		}<br>	}<br><br>/* Made it out of the for loop<br> * this might be the null terminator or it might be the next real character<br> */<br>	return ps;<br>}</div>
<p><a id="467735" href="#467735">#</a> <strong>Shaun Bedingfield</strong> on Thursday, September 15, 2005 1:36 PM:</p><div style="margin-left: 1em">Since Michael was remarking about performance with wcslen, here is another performance question.  Which is faster ++c or c++ and why?<br>Neither is the wrong answer.</div>
<p><a id="467739" href="#467739">#</a> <strong>Shaun Bedingfield</strong> on Thursday, September 15, 2005 1:41 PM:</p><div style="margin-left: 1em">I hate that people always think production code means that something will test for every given eventuallity.  This is great but sometimes it is not efficient enough.<br><br>Sometimes a malformed input occurs rarely enough and is costly enough that you are better off just documenting the precondition and letting people know that in some cases behavior is undefined.  <br><br>Don't get me wrong, I think be aware of malformed input is great but there are reasons why products have checked and free builds or even different build configurations sometimes.</div>
<p><a id="467747" href="#467747">#</a> <strong>Shaun Bedingfield</strong> on Thursday, September 15, 2005 1:52 PM:</p><div style="margin-left: 1em">In light of recent posts, I would like to introduce a feature that I feel should be added to blogs.<br><br>I call this feature an exhibit.<br><br>The exhibit is a document,code snippit, or production that parallels blog communication but is not constantly repeated. <br><br>Recommended features for exhibits are change/evolution tracking and the ability for people to write comments on the exhibit so as to easily point out details.<br><br>Think of an exhibit as a virtual canvas that tells a visual store to parallel the textual story told by the main blog.  It would be really neat if products like Sharepoint integrated with .TEXT (Community Server) to support what I term exhibits.<br><br>Nested comments would also be a great feature for allowing the management of large blog discussions allowing for enhanced integration of both blog and forum worlds.   I like the idea of an exhibit though..<br><br>Just my random comments of dubious value.</div>
<p><a id="467752" href="#467752">#</a> <strong>Maurits</strong> on Thursday, September 15, 2005 2:03 PM:</p><div style="margin-left: 1em">&gt; Which is faster ++c or c++ and why?<br>&gt; Neither is the wrong answer...<br><br>The answer you're looking for is, ++c is faster because it doesn't make a temporary copy of the variable.<br><br>But if you have a decent compiler, and the increment is in a void context, the compiler will auto-convert c++ to ++c for you.</div>
<p><a id="467769" href="#467769">#</a> <strong>Shaun Bedingfield</strong> on Thursday, September 15, 2005 2:16 PM:</p><div style="margin-left: 1em">Correct.. That's an easy one but I am not sure people always think about it.</div>
<p><a id="467835" href="#467835">#</a> <strong>Maurits</strong> on Thursday, September 15, 2005 3:24 PM:</p><div style="margin-left: 1em">I suppose taking out<br>for(ps++; *ps != '\0'; ps++) <br><br>and replacing it with<br>while (*++ps != '\0')<br><br>might ease the compiler's burden a little :)</div>
<p><a id="467917" href="#467917">#</a> <strong>Shaun Bedingfield</strong> on Thursday, September 15, 2005 5:12 PM:</p><div style="margin-left: 1em">Anyone up for writing a nondeterministic version of CharNext?  You could use prolog or something.  This really wouldn't be efficient.<br><br></div>
<p><a id="468811" href="#468811">#</a> <strong>Michael S. Kaplan</strong> on Friday, September 16, 2005 10:17 AM:</p><div style="margin-left: 1em">Ok Maurits, I like the approach you took here, it is quite similar to what I was thinking (I had to add a little more stuff for back-compat with the existing function).</div>
<p><a id="469946" href="#469946">#</a> <strong>Michael S. Kaplan</strong> on Saturday, September 17, 2005 3:12 AM:</p><div style="margin-left: 1em">Ok, the big problem is that the current code Maurits has here will continue on a low surrogate -- when that is the one where you would want stop. It is a high surrogate that has you wanting to continue in the same way that a diacritic does....<br><br>Which then raises the next question -- in the case of invalid surrogate code units like a row of high surrogates, would one skip past them all? Or would one actually stop at the first high surrogate that did not have a low surrogate after it?</div>
<p><a id="471540" href="#471540">#</a> <strong>Maurits</strong> on Monday, September 19, 2005 7:34 PM:</p><div style="margin-left: 1em">I made the same goof again...<br><br>if (t &amp; (...) != 0) // WRONG<br><br>if (t &amp; (...)) // OK<br><br>or<br><br>if ((t &amp; (...)) != 0) // OK</div>
<p><a id="473037" href="#473037">#</a> <strong>Maurits</strong> on Thursday, September 22, 2005 7:42 PM:</p><div style="margin-left: 1em">&gt;Ok, the big problem is that the current code Maurits has here will continue on a low surrogate -- when that is the one where you would want stop. It is a high surrogate that has you wanting to continue in the same way that a diacritic does....<br><br>Sorry, I still don't understand that.  Can you elaborate?  It would be very easy to skip high surrogates too, if that would be more appropriate.  I can't see why skipping high surrogates but not low surrogates would be the right thing.<br><br>&gt;Which then raises the next question -- in the case of invalid surrogate code units like a row of high surrogates, would one skip past them all? Or would one actually stop at the first high surrogate that did not have a low surrogate after it?<br><br>The code I have would return each high surrogate as &quot;the next character&quot;, blissfully ignorant that each character is in fact malformed.  I did consider how better to handle malformed input and came up with this:<br>// consider high-elements first<br>if (this is high)<br>{<br>  <br>  if (next is low)<br>  {<br>    high/low pair -- what to do? Could<br>    ALWAYS SKIP: Consider high/low pair as a non-spacing text element<br>    in which case, skip them both and continue looking<br>    OR<br>    ALWAYS RETURN: Consider high/low pair as the &quot;next character&quot; we're looking for<br>    in which case, return the address of the high part<br>    OR<br>    COME UP WITH A FORMULA: Come up with some means of determining whether this particular pair is &quot;spacing&quot; or not<br>  }<br>  else<br>  {<br>    MALFORMED STRING!  Undefined behavior?  Could<br>    Blow up<br>    Return the high surrogate<br>    Return this non-low surrogate<br>  }<br>}<br><br>// consider low-elements now<br>if (this is low)<br>{<br>  if (previous was high)<br>  {<br>    Yes, I can look at the previous character without worrying about string ranges<br>    Why?  Because I did a ps++ to get here in the first place.<br>    Anyway, if this is the second half of a high/low pair, it's certainly not the next character.<br>    Unilaterally skip.<br>  }<br>  else<br>  {<br>    MALFORMED STRING! Undefined behavior as above.<br>  }<br>}<br></div>
<p><a id="473109" href="#473109">#</a> <strong>Michael S. Kaplan</strong> on Thursday, September 22, 2005 10:33 PM:</p><div style="margin-left: 1em">Hi Maurits!<br>What I meant was that was what you laid out in the the pseudo code below -- you can't always continue on the low since in the normal case you would return there....</div>
<p><a id="476979" href="#476979">#</a> <strong>Maurits</strong> on Tuesday, October 04, 2005 2:59 PM:</p><div style="margin-left: 1em">It strikes me the fundamental problem with my approach is it relies on GetStringTypeW<br><br>This is a UTF-16-specific analysis function that only provides full metadata for characters in the BMP!<br><br>In order to handle supplementary code points correctly, I need a way to find metadata for all UTF-32 characters, including those &gt; U+FFFF<br><br>So I need another helper function that takes UTF-32 data and returns metadata.  Or perhaps a series of functions.<br><br>Of these flags...<br><br>C1_UPPER<br>C1_LOWER<br>C1_DIGIT<br>C1_SPACE<br>C1_PUNCT<br>C1_CNTRL<br>C1_BLANK<br>C1_XDIGIT<br>C1_ALPHA<br>C1_DEFINED<br>C2_LEFTTORIGHT<br>C2_RIGHTTOLEFT<br>C2_EUROPENUMBER<br>C2_EUROPESEPARATOR<br>C2_EUROPETERMINATOR<br>C2_ARABICNUMBER<br>C2_COMMONSEPARATOR<br>C2_BLOCKSEPARATOR<br>C2_SEGMENTSEPARATOR<br>C2_WHITESPACE<br>C2_OTHERNEUTRAL<br>C2_NOTAPPLICABLE<br>C3_NONSPACING<br>C3_DIACRITIC<br>C3_VOWELMARK<br>C3_SYMBOL<br>C3_KATAKANA<br>C3_HIRAGANA<br>C3_HALFWIDTH<br>C3_FULLWIDTH<br>C3_IDEOGRAPH<br>C3_KASHIDA<br>C3_LEXICAL<br>C3_ALPHA<br>C3_HIGHSURROGATE<br>C3_LOWSURROGATE<br>C3_NOTAPPLICABLE<br><br>the &quot;odd ones out&quot; are C3_HIGHSURROGATE and C3_LOWSURROGATE.  These apply not to Unicode code points in general, but only to the UTF-16 encoding system!<br><br>I'd also like to see a Cn_PRIVATE for characters in a private plane range, and a Cn_RESERVED for characters in a reserved plane or range.<br><br>I suppose a lot of this comes from the Microsoft commitment to UTF-16 as a default encoding system... instead of picking between UTF-8/UTF-16/UTF-32 &quot;as appropriate&quot;* on a case-by-case basis<br><br>* Where the definition of &quot;as appropriate&quot; is left as an exercise ;)</div>
<p><a id="476982" href="#476982">#</a> <strong>Michael S. Kaplan</strong> on Tuesday, October 04, 2005 3:07 PM:</p><div style="margin-left: 1em">I am not sure you can call this a flaw since the input to CharNext is UTF-16, so it makes sense that the input to GetStringTypeW is also UTF-16. It is not a flaw....<br><br>Every flag there applies to UTF-16 code units, not just the surrogate ones.<br><br>The key is the most efficient way to make use of that. :-)</div>
<p><a id="477026" href="#477026">#</a> <strong>Maurits</strong> on Tuesday, October 04, 2005 4:28 PM:</p><div style="margin-left: 1em">Alright, so how can I get metadata on supplementary code points?<br><br>For example, how can I determine programmatically that OLD ITALIC LETTER A<br><a rel="nofollow" target="_new" href="http://www.fileformat.info/info/unicode/char/010300/index.htm">http://www.fileformat.info/info/unicode/char/010300/index.htm</a><br><br>is a letter (C1_ALPHA) and is not nonspacing (!C3_NONSPACING)?<br><br>I notice that the &quot;Microsoft-proprietary dotNet Properties&quot; listed on the fileformat.info page don't display correct answers... and that UrlEncodeUnicode mis-encodes it as a combining grave accent (oops!)<br>COMBINING GRAVE ACCENT<br><a rel="nofollow" target="_new" href="http://www.fileformat.info/info/unicode/char/0300/index.htm">http://www.fileformat.info/info/unicode/char/0300/index.htm</a><br><br>Or is that data not yet available programmatically?</div>
<p><a id="477028" href="#477028">#</a> <strong>Michael S. Kaplan</strong> on Tuesday, October 04, 2005 4:36 PM:</p><div style="margin-left: 1em">You can't, on Windows, exceot by using the new macros (IS_HIGH_SURROGATE, IS_LOW_SURROGATE, IS_SURROGATE_PAIR), but no metadata is availble.<br><br>In the .NET Framework 2.0, CharUnicodeInfo is your friend. I suspect he is not using that yet?</div>
<p><a id="477035" href="#477035">#</a> <strong>Maurits</strong> on Tuesday, October 04, 2005 4:48 PM:</p><div style="margin-left: 1em">You're referring to<br><br>CharUnicodeInfo.GetUnicodeCategory(Char)?<br><a rel="nofollow" target="_new" href="http://msdn2.microsoft.com/en-us/library/h6sx68ke">http://msdn2.microsoft.com/en-us/library/h6sx68ke</a><br><br>This returns a UnicodeCategory enumeration, sure enough:<br><br>UnicodeCategory<br><a rel="nofollow" target="_new" href="http://msdn2.microsoft.com/en-us/library/3hay9k69">http://msdn2.microsoft.com/en-us/library/3hay9k69</a><br><br>which could easily be checked for<br>if ((u | UnicodeCategory.NonSpacingMark) != 0)<br><br>... but how do I feed the supplemental code point to GetUnicodeCategory in the first place?  It only takes a Char, which is a UTF-16 code point:<br><br>Char<br><a rel="nofollow" target="_new" href="http://msdn2.microsoft.com/en-us/library/3hay9k69">http://msdn2.microsoft.com/en-us/library/3hay9k69</a><br>&quot;a character that is encoded as a base character, *surrogate pair*, and/or combining character sequence is represented by *multiple Char objects*&quot; (my emphasis)</div>
<p><a id="477037" href="#477037">#</a> <strong>Maurits</strong> on Tuesday, October 04, 2005 4:51 PM:</p><div style="margin-left: 1em">er, instead of<br>u | UnicodeCategory.NonSpacingMark<br>I mean, of course,<br>u &amp; UnicodeCategory.NonSpacingMark</div>
<p><a id="477040" href="#477040">#</a> <strong>Maurits</strong> on Tuesday, October 04, 2005 4:54 PM:</p><div style="margin-left: 1em">Char.ConvertToUtf32<br><a rel="nofollow" target="_new" href="http://msdn2.microsoft.com/en-us/library/wdh8k14a">http://msdn2.microsoft.com/en-us/library/wdh8k14a</a><br><br>It returns an int, natch... so I can easily get my supplementary code point... but I can't test it. :'(</div>
<p><a id="477051" href="#477051">#</a> <strong>Michael S. Kaplan</strong> on Tuesday, October 04, 2005 5:01 PM:</p><div style="margin-left: 1em">CharUnicodeInfo's methods have overrides that take a string and an index -- if it points to a high surrogate and is followed by a low sdurrogate, you will get the property for the supplementary character.<br><br>HOWEVER, since the question was about solving the issue for Win32, the .NET Framework cannot be used. Lucvkily, no supplementary characters are combining at this point, so it is a non-idue at the moment....</div>
<p><a id="477094" href="#477094">#</a> <strong>Maurits</strong> on Tuesday, October 04, 2005 6:44 PM:</p><div style="margin-left: 1em">Ah, that's actually quite helpful... but it's not mentioned in the documentation or the examples, only in your blog post of 1/28/05:<br><a rel="nofollow" target="_new" href="http://archives.miloush.net/michkap/archive/2005/01/28/362305.html">http://blogs.msdn.com/michkap/archive/2005/01/28/362305.aspx</a><br><br>So if I'm walking the string in UTF-16 characters, 0 to s.Length - 1, and I run across a high surrogate character at position i..<br><br>GetUnicodeCategory(s, i) will give me the categories of the supplementary code point<br>BUT<br>GetUnicodeCategory(s[i]) will give me the categories of the high surrogate?<br><br>Whereas both<br>GetUnicodeCategory(s, i + 1)<br>AND<br>GetUnicodeCategory(s[i + 1])<br>will give me the categories of the low surrogate?  (That is, UnicodeCategory.Surrogate)<br><br>*sigh* once again the UTF-16 nature of the string is artificially exposed...<br><br>I'm beginning to think that String.Length is too ambiguous to be useful.  How about a family of new properties to replace it...<br><br>String.LengthInBytesUnderCurrentInternalRepresentation<br>String.LengthInBytesAsUTF8<br>String.LengthInBytesAsUTF16<br>String.LengthInBytesAsUTF32<br>String.LengthInUTF32CodePoints<br>String.LengthInUTF16BytePairs<br>String.LengthInUTF8Bytes<br>String.LengthInUnicodeCharacters (= UTF32CodePoints)<br>String.LengthInTextElements (ParseCombiningCharacters)<br>String.LengthInCharacters (= number of times CharNext can be called)<br><br>(whew!)</div>
<p><a id="477131" href="#477131">#</a> <strong>Michael S. Kaplan</strong> on Tuesday, October 04, 2005 8:12 PM:</p><div style="margin-left: 1em">Well, you can think of this blog as being where no doc has gone before? :-)<br><br>It is not artificial -- UTF-16 is what it is, and a method that can take a Unicode code point whether it is made up of one or two Unicode c ode units is useful.<br><br>No way I am going to touch that list of yours, though -- I don't agree with most of them. :-)<br><br>Have we officially abandoned the original Win32 problem?</div>
<p><a id="477461" href="#477461">#</a> <strong>Maurits</strong> on Wednesday, October 05, 2005 3:22 PM:</p><div style="margin-left: 1em">Here's my latest iteration of the Win32 problem...<br><a rel="nofollow" target="_new" href="http://www.geocities.com/mvaneerde/charnext.html">http://www.geocities.com/mvaneerde/charnext.html</a><br><br>I decided on how to handle errors. Still no ANSI version.<br><br>I'm about halfway through the VS2005 Beta 2 install to verify the CharUnicodeInfo thing.</div>
<p><a id="477471" href="#477471">#</a> <strong>Michael S. Kaplan</strong> on Wednesday, October 05, 2005 3:40 PM:</p><div style="margin-left: 1em">That actually looks pretty amazing, Maurits!</div>
<p><a id="477473" href="#477473">#</a> <strong>Michael S. Kaplan</strong> on Wednesday, October 05, 2005 3:41 PM:</p><div style="margin-left: 1em">Note that no change is required for the non-Unicode version, since you cannot have supplementary characters there!</div>
<p><a id="477505" href="#477505">#</a> <strong>Maurits</strong> on Wednesday, October 05, 2005 5:06 PM:</p><div style="margin-left: 1em">This is going on my resume :)<br><br>&quot;That actually looks pretty amazing, Maurits!&quot;<br>  -- Michael Kaplan<br></div>
<p><a id="477526" href="#477526">#</a> <strong>Michael S. Kaplan</strong> on Wednesday, October 05, 2005 5:48 PM:</p><div style="margin-left: 1em">They may think you mean this guy:<br><br><a rel="nofollow" target="_new" href="http://www.mathematik.tu-muenchen.de/~kaplan/">http://www.mathematik.tu-muenchen.de/~kaplan/</a><br><br>or this guy:<br><br><a rel="nofollow" target="_new" href="http://www.imdb.com/name/nm0438325/">http://www.imdb.com/name/nm0438325/</a><br><br>or this guy:<br><br><a rel="nofollow" target="_new" href="http://med.stanford.edu/ohns/faculty/kaplan.html">http://med.stanford.edu/ohns/faculty/kaplan.html</a><br><br>etc. :-)</div>
<hr/><p><em>referenced by</em></p><div style="margin-left: 1em"><p>2006/07/15 <a href="http://archives.miloush.net/michkap/archive/2006/07/15/666717.html">How long is that non-Unicode string?</a></p></div><p><em>go to <a id="newer" href="http://archives.miloush.net/michkap/archive/2005/09/14/463569.html" title="One more thing about Korean....">newer</a> or <a id="older" href="http://archives.miloush.net/michkap/archive/2005/09/13/464733.html" title="Now available: Extend Your Code&#39;s Global Reach With New Features In The .NET Framework 2.0">older</a> post, or back to <a href="http://archives.miloush.net/michkap/archive/index.html">index</a> or <a href="http://archives.miloush.net/michkap/archive/index.html#2005-09">month</a> or <a href="http://archives.miloush.net/michkap/archive/index.html#2005-09-13">day</a></em></p></body>
<!-- Mirrored from archives.miloush.net/michkap/archive/2005/09/13/465228.html by HTTrack Website Copier/3.x [XR&CO'2014], Thu, 25 May 2017 00:42:41 GMT -->
</html>