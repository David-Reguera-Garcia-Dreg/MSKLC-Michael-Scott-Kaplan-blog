<html>
<!-- Mirrored from archives.miloush.net/michkap/archive/2005/08/23/455339.html by HTTrack Website Copier/3.x [XR&CO'2014], Thu, 25 May 2017 00:42:41 GMT -->
<head><meta charset="utf-8" /><meta name="viewport" content="width=device-width" /><title>What if my strings are > 2 gb?</title></head><body>
<h1>What if my strings are > 2 gb?</h1>
<p><em>by Michael S. Kaplan, published on 2005/08/23 15:30 -07:00, original URI: http://blogs.msdn.com/michkap/archive/2005/08/23/455339.aspx</em></p>
<hr/> <!-- Archival Source: ProcessPostOld -->
<P><FONT face=Tahoma>We do get our fair share of silly questions here in NLS.</FONT></P>
<P><FONT face=Tahoma>I should perhaps explain what I mean by silly. :-)</FONT></P>
<P><FONT face=Tahoma>I don't think I'd ever consider a question where somebody is asking about language and how it might work in a certain situation and call <EM>that</EM> silly. I mean, that's how people learn. It's the kinds of questions that I ask of native speakers and of linguists, and even if they smile or laugh I never get the sense that they are thinking me&nbsp;silly for the question.</FONT></P>
<P><FONT face=Tahoma>But today, somebody who is thinking about 64-bit Windows and who assumed that one day strings that are greater than 2 GB would be common looked at our signature for </FONT><A href="http://msdn.microsoft.com/library/en-us/winui/winui/windowsuserinterface/resources/strings/stringreference/stringfunctions/comparestring.asp"><FONT face=Tahoma>CompareString</FONT></A><FONT face=Tahoma>:</FONT></P>
<BLOCKQUOTE dir=ltr style="MARGIN-RIGHT: 0px">
<P><FONT face="Courier New" size=2><STRONG>int&nbsp;CompareString(<BR>&nbsp;&nbsp;&nbsp;&nbsp;LCID&nbsp;<I>Locale</I>,<BR>&nbsp;&nbsp;&nbsp;&nbsp;DWORD&nbsp;<I>dwCmpFlags</I>,<BR>&nbsp;&nbsp;&nbsp;&nbsp;LPCTSTR&nbsp;<I>lpString1</I>,<BR>&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;<I>cchCount1</I>,<BR>&nbsp;&nbsp;&nbsp;&nbsp;LPCTSTR&nbsp;<I>lpString2</I>,<BR>&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;<I>cchCount2</I><BR>);</STRONG></FONT></P></BLOCKQUOTE>
<P dir=ltr><FONT face=Tahoma>and suggested that perhaps those <STRONG>int</STRONG> parameters containing the string lengths ought to be <STRONG>size_t</STRONG> instead.</FONT></P>
<P dir=ltr><FONT face=Tahoma>Now I would like to forget about the argument that this is a public API that is been around since NT 3.1. It's obviously important here, and makes a suggestion a little bit silly, but not everyone really pays attention to what's in NLS API or how long it's been there.</FONT></P>
<P dir=ltr><FONT face=Tahoma>I'd also like to forget about the argument that 2 GB strings are uncommon, because one day they may not be. Especially in the 64-bit world. There may be a perfectly valid reason to have huge strings.</FONT></P>
<P dir=ltr><FONT face=Tahoma>The real problem I have here, and what makes the question in silly to me, is the notion that you need to do linguistic comparisons on strings that are greater than 2 GB in size.</FONT></P>
<P dir=ltr><FONT face=Tahoma>There is simply no way to justify this is a reasonable use of the collation functionality in NLS API.</FONT></P>
<P dir=ltr><FONT face=Tahoma>Perhaps some of you may disagree with this notion, and I'll be curious how people respond to this post. If you are somebody disagrees, please be sure to include information about your "reasonable example" so that people have a chance to appropriately judge the judgment being used. :-)</FONT></P>
<P dir=ltr><FONT face=Tahoma></FONT>&nbsp;</P>
<P dir=ltr><FONT face=Tahoma color=#ff0000><EM>This post brought to you by</EM> "ยง" <EM>(<A href="http://www.fileformat.info/info/unicode/char/00a7/index.htm">U+00A7</A>, a.k.a. SECTION SIGN)</EM></FONT></P>
<hr/><p><a id="455354" href="#455354">#</a> <strong>shaunbed</strong> on Tuesday, August 23, 2005 7:14 PM:</p><div style="margin-left: 1em">I don't know.. Maybe someone would one day want to compare several hundred copies of &quot;War and Piece&quot; at the same time.<br><br>Nah..</div>
<p><a id="455355" href="#455355">#</a> <strong>Wesner Moise</strong> on Tuesday, August 23, 2005 7:18 PM:</p><div style="margin-left: 1em">In the distant future, when AI takes over and the world moves from 32bit to 1024bit computers, and computers being much smarter than humans are able to process a lot (lot) more information, machines may want to talk to other machines.<br><br>Of course Windows 2100 will be available and the NLS APIs may long be obsolete.</div>
<p><a id="455358" href="#455358">#</a> <strong>CN</strong> on Tuesday, August 23, 2005 7:22 PM:</p><div style="margin-left: 1em">Well, first I want to know:<br><br>Does CompareString succeed with 2 GB strings on Win64? Is there some slight non-linearity in the runtime behavior that makes it practically impossible (with expected running time in the range of several years or something)?<br><br>That would be the REAL showstopper! What if you can't even do a lingustic comparison of two CDs with a single API call?</div>
<p><a id="455360" href="#455360">#</a> <strong>Michael S. Kaplan</strong> on Tuesday, August 23, 2005 7:28 PM:</p><div style="margin-left: 1em">Hi shaunbed -- exactly!<br><br>Hi Wesner -- even if we process more information, the need to compare that much information is simply not a huge scenario. :-)<br><br>Hi CN -- well, we will have to stop the show, in that case. But I think you are mistaken -- a binary comparison is what you would want in that fairly obscure scenario....</div>
<p><a id="455372" href="#455372">#</a> <strong>Dean Harding</strong> on Tuesday, August 23, 2005 8:14 PM:</p><div style="margin-left: 1em">Well, if you think about it, even &quot;War and Peace&quot; is only about 600,000 words, which is probably around 5,000,000 characters (maybe?) - *much* less that the theoretical maximum of 2 billion.  You'd have to be comparing something 400 times longer than &quot;War and Peace&quot; to hit the limit!!<br><br>But even if you wanted to compare something that long, then surely a more sensible way would be to do it line-by-line.  It would seem obvious that any comparison that big would take a loooong, and at least that way you could provide some feedback to the user that *something* was happening (a progress bar, for example).</div>
<p><a id="455378" href="#455378">#</a> <strong>shaunbed</strong> on Tuesday, August 23, 2005 8:51 PM:</p><div style="margin-left: 1em">The compare will not take long enough for a progress bar.<br><br>I once had &quot;War and Peace&quot; and all of Shakespeare's plays on my PDA with 8 MB or RAM.  That is any easy squeeze for memory.<br><br>Efficiency depends on the comparison but with a binary comparison you can compare several bytes at one time.  The operation is memory limited as the cpu will outperform the memory accesses.  DDR400 has a peak theoretical bandwidth of 3.2 GB/s without considering dual channel.  This means that a 2 GB compare will probably run in less than 1 s.  Why you would want to do this is a mystery...  <br><br>What does take time is the time to copy the file to memory.  Reading a 2 GB harddrive would probably take about 1 minute on most systems.  This operation would need a bar.</div>
<p><a id="455382" href="#455382">#</a> <strong>Michael S. Kaplan</strong> on Tuesday, August 23, 2005 9:06 PM:</p><div style="margin-left: 1em">Hey Dean!<br><br>Luckily, there is no need -- the first character that has a different primary weight will cause CompareString to exit -- and therefore it is fast.<br><br>The string loading is something the caller controls -- so the caller can put up UI if they want to....</div>
<p><a id="455391" href="#455391">#</a> <strong>Dean Harding</strong> on Tuesday, August 23, 2005 9:24 PM:</p><div style="margin-left: 1em">&gt; Luckily, there is no need -- the first character that has a different primary weight will cause CompareString to exit<br><br>Well, I was assuming that you would be comparing two 2GB strings that were equal, in which case it'd have to go through the whole thing...<br><br>In fact, I had a look at the download for &quot;War and Peace&quot; on Project Gutenburg, and it's only 3.15MB which means my estimate of 5 million characters was a bit over.  You'd have to be comparing something *650 times longer* than &quot;War and Peace&quot; to hit the 2GB &quot;limit&quot;.<br><br>I can't imagine why there would be any reason to have two strings 650 times longer than the entire text of &quot;War and Peace&quot; loaded into memory, ready to be compared with CompareString.<br><br>Oh, another thought: if you pass -1 as the sizes, would it work with strings longer than 2GB then?  Depends how it works internally, I suppose.  At least if it does at the moment, and strings &gt; 2GB really were needed, you could *make* it work in the case of a NULL-terminated string without changing the public interface...</div>
<p><a id="455397" href="#455397">#</a> <strong>shaunbed</strong> on Tuesday, August 23, 2005 9:48 PM:</p><div style="margin-left: 1em">Not that it makes any difference but..<br><br>Project Gutenberg's W&amp;P is not in Unicode..</div>
<p><a id="455398" href="#455398">#</a> <strong>shaunbed</strong> on Tuesday, August 23, 2005 9:53 PM:</p><div style="margin-left: 1em">Actually int can handle strings up to approximately 4 GB in size as long as they are in 16 bit Unicode.  It just can't handle strings over ~2^31 characters long :)</div>
<p><a id="455400" href="#455400">#</a> <strong>Michael S. Kaplan</strong> on Tuesday, August 23, 2005 10:02 PM:</p><div style="margin-left: 1em">Actually, we were talking about the parameter that controls the length in WCHARs -- we can handle 2^31 - 1 WCHARs, or 2147483647. This is approximately 2gb. :-)</div>
<p><a id="455442" href="#455442">#</a> <strong>Piotrek</strong> on Wednesday, August 24, 2005 12:37 AM:</p><div style="margin-left: 1em">&quot;Data density in DNA is also hugely bigger than standard computers. A DNA strand has the bases A, T, C, and G spaced evenly 0.35 nanometers apart on it. This means that, if there is one base per square nanometer, the data density of one square inch is close to a million gigabytes. In a standard computer, data density is close to 100,000 time smaller, around 7 gigabytes per square inch&quot;<br><br>but tell him not to use a string :)))</div>
<p><a id="455447" href="#455447">#</a> <strong>Michael S. Kaplan</strong> on Wednesday, August 24, 2005 12:48 AM:</p><div style="margin-left: 1em">Hi Piotrek -- Ah yes, but not only is string probably the wrong way to store it, but (more importantly for our purposes) CompareString is definitely not the right way to try to compare it!</div>
<p><a id="455452" href="#455452">#</a> <strong>Rosyna</strong> on Wednesday, August 24, 2005 1:04 AM:</p><div style="margin-left: 1em">dur, because I download my stargate SG-1 season sets to a string. Then i compare what I have versus what someone else has using a client-server process on the internets.</div>
<p><a id="455453" href="#455453">#</a> <strong>Michael S. Kaplan</strong> on Wednesday, August 24, 2005 1:09 AM:</p><div style="margin-left: 1em">Hi Rosyna -- there is still nothing useful that CompareString can do here -- they will not be equal, ever. You can have the answer that CompareString would give you without even making the call....<br><br>To tell the truth, not even a binary compare would help you. To get such a comparison done, you would need something that could read out title info from the file?</div>
<p><a id="455650" href="#455650">#</a> <strong>Maurits</strong> on Wednesday, August 24, 2005 1:08 PM:</p><div style="margin-left: 1em">sToday = System.Disk(0).ToString() -&gt; formats contents of C: drive as an XML string<br><br>sYesterday = System.History(Date() - 1).Disk(0).ToString() -&gt; formats yesterday's contents of the C: drive as an XML string<br><br>bHasAnythingChangedSinceYesterday = (0 &lt;&gt; CompareString(sToday, sYesterday)<br><br>Only a little contrived.</div>
<p><a id="455658" href="#455658">#</a> <strong>Rosyna</strong> on Wednesday, August 24, 2005 1:15 PM:</p><div style="margin-left: 1em">I was talking more using the CompareString as a really, really lame checksum type check. CompareString wouldn't return two if you loaded the same string twice from the same file?</div>
<p><a id="455659" href="#455659">#</a> <strong>Michael S. Kaplan</strong> on Wednesday, August 24, 2005 1:16 PM:</p><div style="margin-left: 1em">Maurits -- A binary comparison is still perfect there -- you expect a rash of people changing to equivalent forms of characters?<br><br>Remember the challenge -- a reasonable scenario for a LINGUISTIC comparison....</div>
<p><a id="455660" href="#455660">#</a> <strong>Michael S. Kaplan</strong> on Wednesday, August 24, 2005 1:17 PM:</p><div style="margin-left: 1em">Dean -- I somehow doubt that passing -1 would work here. Greater than 2gb is just a bad idea, all the way around.</div>
<p><a id="455663" href="#455663">#</a> <strong>Michael S. Kaplan</strong> on Wednesday, August 24, 2005 1:19 PM:</p><div style="margin-left: 1em">Rosyna -- not even a binary comparison would work there -- two people recording the sa,e episode is two different binary representations.<br><br>A LINGUISTIC conmparison will not do any better.</div>
<p><a id="456026" href="#456026">#</a> <strong>josh</strong> on Wednesday, August 24, 2005 11:26 PM:</p><div style="margin-left: 1em">shaunbed's right, it can be up to 4GB minus two bytes.  #define UNICODE and try the math again.  ;)</div>
<p><a id="456030" href="#456030">#</a> <strong>Michael S. Kaplan</strong> on Wednesday, August 24, 2005 11:35 PM:</p><div style="margin-left: 1em">Sorry Josh, we are not talking about how much space UTF-16 code points take up. We are talking about the count of WCHARs -- and you can have up to almost 2gb of them. Since the function is not asking for bytes, neither is the blog entry....</div>
<p><a id="456613" href="#456613">#</a> <strong>josh</strong> on Friday, August 26, 2005 1:04 AM:</p><div style="margin-left: 1em">Ok, well next time you want GB to mean something other than gigabyte, it'd be nice if you'd say so up front.  :P</div>
<p><a id="9555538" href="#9555538">#</a> <strong>Yuhong Bao</strong> on Sunday, April 19, 2009 3:52 AM:</p><div style="margin-left: 1em"><p>Remind me of the REP string instructions on x64. In 64-bit mode they use RCX, which is 64-bit. Problem is, many x64 CPUs have errata relating to RCX values exceeding 32-bit being used with these instructions.</p></div>
<hr/><p><em>go to <a id="newer" href="http://archives.miloush.net/michkap/archive/2005/08/23/455359.html" title="What the hell does HTTP_ACCEPT_LANGUAGE mean?">newer</a> or <a id="older" href="http://archives.miloush.net/michkap/archive/2005/08/23/455240.html" title="Yellow and blue make green">older</a> post, or back to <a href="http://archives.miloush.net/michkap/archive/index.html">index</a> or <a href="http://archives.miloush.net/michkap/archive/index.html#2005-08">month</a> or <a href="http://archives.miloush.net/michkap/archive/index.html#2005-08-23">day</a></em></p></body>
<!-- Mirrored from archives.miloush.net/michkap/archive/2005/08/23/455339.html by HTTrack Website Copier/3.x [XR&CO'2014], Thu, 25 May 2017 00:42:41 GMT -->
</html>