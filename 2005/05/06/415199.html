<html>
<!-- Mirrored from archives.miloush.net/michkap/archive/2005/05/06/415199.html by HTTrack Website Copier/3.x [XR&CO'2014], Thu, 25 May 2017 00:42:41 GMT -->
<head><meta charset="utf-8" /><meta name="viewport" content="width=device-width" /><title>Making SQL Server index usage a bit more deterministic</title></head><body>
<h1>Making SQL Server index usage a bit more deterministic</h1>
<p><em>by Michael S. Kaplan, published on 2005/05/06 17:06 -04:00, original URI: http://blogs.msdn.com/b/michkap/archive/2005/05/06/415199.aspx</em></p>
<hr/> <!-- Archival Source: ProcessPostNew -->
<P><A href="http://weblogs.asp.net/taganov/"><FONT face=Tahoma>Chris McKenzie</FONT></A><FONT face=Tahoma> blogged about a situation that I will be talking about in my upcoming TechEd 2005 presentations (<EM>particularly&nbsp;<STRONG>DBA319</STRONG>!</EM>), so I thought I might talk about the issue a bit here.</FONT></P>
<P><FONT face=Tahoma>In his post <A href="http://weblogs.asp.net/taganov/archive/2005/05/06/405944.aspx"><STRONG>Note to Self</STRONG></A>, Chris said:</FONT></P><FONT face=Tahoma>
<BLOCKQUOTE dir=ltr>
<DIV class=postcontent>
<P><FONT size=2><EM>Don't put ORDER BY Statements in Views.</EM></FONT></P>
<P><FONT size=2><EM>Delay sorting until you're actually about to use the data.</EM></FONT></P>
<P><FONT size=2><EM>If you end up sorting differently than the default sort specified by the ORDER BY in the view, it comes as an expensive performance hit. Witness a stored procedure that was breaking a unit test due to a SqlClient.SqlTimeout Exception (took 2.5 minutes to run). Removing the ORDER BY statements from the underlying views brought execution time down to 6 seconds.</EM></FONT></P></DIV></BLOCKQUOTE></FONT>
<P><FONT face=Tahoma>Luckily it is not that as bad as all that (or it does not have to be). Though I actually said as much in my <A href="http://msdn.microsoft.com/library/techart/IntlFeaturesInSQLServer2000.htm">International Features in SQL Server 2000</A>&nbsp;white paper, which was reviewed and approved by the SQL Server International team (and several people on the Engine and at least one architect!):</FONT></P><FONT face=Tahoma>
<BLOCKQUOTE dir=ltr>
<H4 class=dtH1><FONT size=2><EM>Issues with defining collation at the column level</EM></FONT></H4>
<P><FONT size=2><EM>How often would you have a database that needs one sort order (for example, Latin1_General) and a column that needs a different one (for example Greek)? Sometimes, this may be crucial, but in other cases if the data in your database does not use a single collation, then it is probably multilingual data that may need to be sorted according to more than one collation. Being able to define multiple collations, each of which can be indexed, allows you to access the Greek data by specifying the Greek collation, and to have this query be an indexed search.</EM></FONT></P>
<P><FONT size=2><EM>That last clause "and to have this query be an indexed search" is the crux of the matter. In the </EM></FONT><A href="http://msdn.microsoft.com/library/en-us/dnsql2k/html/intlfeaturesinsqlserver2000.asp?frame=true#intlfeaturesinsqlserver2000_collationsspecified" target=_self><FONT size=2><EM>example</EM></FONT></A><FONT size=2><EM> provided earlier, using a COLLATE expression in the ORDER BY clause of a query gives you the functionality; however, this will not be an indexed ordering, so it will be slower for large datasets. As it stands, column-level collation makes sense only if you do not have monolingual data in a column, or if you denormalize your database to store different languages in different columns.</EM></FONT></P></BLOCKQUOTE></FONT>
<P><FONT face=Tahoma>It was later pointed out to me that there was a way to make this work in Shiloh (SQL Server 2000), a way which gets much better in Yukon (SQL Server 2005). </FONT><FONT face=Tahoma>You can basically create multi-lingual indexes! </FONT></P>
<P><FONT face=Tahoma>It works like this:</FONT></P>
<P dir=ltr><FONT face=Tahoma>Say you have a Table tbl with column c with collation of Latin1_General_CI_AS</FONT></P>
<BLOCKQUOTE dir=ltr>
<P><FONT face="Courier New" size=4><STRONG>select * from tbl<BR>order by c COLLATE Japanese_CI_AS</STRONG></FONT></P></BLOCKQUOTE>
<P dir=ltr><FONT face=Tahoma>No Japanese index exists here -- so everything done with this uery will be slower.</FONT></P>
<BLOCKQUOTE dir=ltr>
<P dir=ltr><FONT face="Courier New" size=4><STRONG>create table tbl (c nvarchar(100), c2 as c COLLATE Japanese_CI_AS)<BR>create index itc2 on tbl(c2)</STRONG></FONT></P></BLOCKQUOTE>
<P dir=ltr><FONT face=Tahoma>The original query can now use the Japanese index!</FONT></P>
<P dir=ltr><FONT face=Tahoma>Now, In SQL Server 2000, you must explicitly use that field <STRONG>c2</STRONG> to get the index to work. </FONT></P>
<P dir=ltr><FONT face=Tahoma>But in SQL Server 2005, the work was done in the engine to allow deterministic index usage that would not treat all indexes as "equal" and arbitrarily pick one. If an index exists on a column that matches the characteristice of the query, then the QPE will make intelligent use of that index.</FONT></P>
<P dir=ltr><FONT face=Tahoma>Pretty cool trick, if you ask me. I wish I had known about in several of the applications I did, and before I wrote the white paper!</FONT></P>
<P dir=ltr><FONT face=Tahoma>I will be delving into this sort of item and more in Orlando and in Amsterdam, so if you are going to TechEd 2005 then be sure to sign up for <EM><STRONG>DBA 319</STRONG>:&nbsp;Best Practices for Search in Multilingual Data Sets (Using SQL Server Collation for Sorting and Indexing)</EM>.</FONT></P>
<P dir=ltr><FONT face=Tahoma></FONT>&nbsp;</P>
<P dir=ltr><FONT face=Tahoma><FONT color=#ff0000><EM>This post brought to you by</EM> "ยง" <EM>(<A href="http://www.fileformat.info/info/unicode/char/00a7/index.htm">U+00a7</A>, a.k.a. SECTION SIGN)</EM></FONT></P></FONT>
<hr/><p><a id="415246" href="#415246">#</a> <strong>Chris McKenzie</strong> on 6 May 2005 7:00 PM:</p><div style="margin-left: 1em">Thanks for posting this. I solved my earler problem by delaying sorting until the stored procedure.  I identified the problem as being that the ORDER BY clause in my stored proc was sorting the data on a different set of columns than the default sort specified by the underlying view.  Are you saying that I could also have improved performance by adding indexes to the columns or column-groups that I will most often be sorting on?  I may have to compare and benchmark the two approaches.<br><br>This was a very interesting blog. Thanks again.</div>
<p><a id="415256" href="#415256">#</a> <strong>Michael S. Kaplan</strong> on 6 May 2005 8:23 PM:</p><div style="margin-left: 1em">Yes, that is what I am saying. :-)<br><br>And of course in SQLS 2005 the syntax is more natural since you never have to think about the indexes after you have created them; they will just work....<br><br>Glad you liked it! I'll be doing more SQL server posts as I get closer and closer to TechEd.</div>
<hr/><p><em>referenced by</em></p><div style="margin-left: 1em"><p>2008/08/26 <a href="http://archives.miloush.net/michkap/archive/2008/08/26/8890822.html">Making SQL Server operations slower (without explicitly trying)</a></p><p>2007/09/18 <a href="http://archives.miloush.net/michkap/archive/2007/09/18/4971376.html">A&P of Sort Keys, part 8 (aka You can often think of ignoring weights as a form of ignorance)</a></p><p>2006/06/07 <a href="http://archives.miloush.net/michkap/archive/2006/06/07/620277.html">Performance issues with language specific sorts?</a></p><p>2006/01/29 <a href="http://archives.miloush.net/michkap/archive/2006/01/29/518777.html">Handling multilingual data in SQL Server</a></p><p>2006/01/01 <a href="http://archives.miloush.net/michkap/archive/2006/01/01/508503.html">Sorting multilingual data</a></p><p>2005/05/15 <a href="http://archives.miloush.net/michkap/archive/2005/05/15/417601.html">Not all SQL Server collations are created equal</a></p><p>2005/05/11 <a href="http://archives.miloush.net/michkap/archive/2005/05/11/416293.html">Case/kana/accent/width sensitive SQL Server, for testing</a></p><p>2005/05/11 <a href="http://archives.miloush.net/michkap/archive/2005/05/11/416290.html">Achieving case insensitivity</a></p></div><p><em>go to <a id="newer" href="http://archives.miloush.net/michkap/archive/2005/05/07/415376.html" title="VB6 isn&#39;t using Unicode, most of the time">newer</a> or <a id="older" href="http://archives.miloush.net/michkap/archive/2005/05/06/415187.html" title="Mixed feelings about the new Steve Ballmer mail">older</a> post, or back to <a href="http://archives.miloush.net/michkap/archive/index.html">index</a> or <a href="http://archives.miloush.net/michkap/archive/index.html#2005-05">month</a> or <a href="http://archives.miloush.net/michkap/archive/index.html#2005-05-06">day</a></em></p></body>
<!-- Mirrored from archives.miloush.net/michkap/archive/2005/05/06/415199.html by HTTrack Website Copier/3.x [XR&CO'2014], Thu, 25 May 2017 00:42:41 GMT -->
</html>