<html>
<!-- Mirrored from archives.miloush.net/michkap/archive/2005/05/22/420822.html by HTTrack Website Copier/3.x [XR&CO'2014], Thu, 25 May 2017 00:42:41 GMT -->
<head><meta charset="utf-8" /><meta name="viewport" content="width=device-width" /><title>You may want to rethink your choice of UTF, #2 (Speed of operations)</title></head><body>
<h1>You may want to rethink your choice of UTF, #2 (Speed of operations)</h1>
<p><em>by Michael S. Kaplan, published on 2005/05/22 02:01 -04:00, original URI: http://blogs.msdn.com/b/michkap/archive/2005/05/22/420822.aspx</em></p>
<hr/> <!-- Archival Source: ProcessPostNew -->
<P><FONT face=Tahoma>In the first post in this series, I talked about <a href="http://archives.miloush.net/michkap/archive/2005/05/20/420317.html">size considerations</A>, but even then I hinted that there is more to the decision than just size. I mean, I am not saying that size does not matter, but there are other facts that can matter more....</FONT></P>
<P><FONT face=Tahoma>In this second post, I am going to talk about the speed of operations.</FONT></P>
<P><EM><FONT face=Tahoma>(As before, I am assuming you will always want to use Unicode of some form, but I will include the code page answer as an initial strawman each time.)(I am assuming you will always want to use Unicode of some form, but I will include the code page answer as an initial strawman each time.)</FONT></EM></P>
<P><FONT face=Tahoma>Starting with our strawman of the legacy code page, if everything you need to do will fit in one single-byte code page, then often it will be the winner here. Unluckily for the code pages, there is no language for which that solution is good enough except maybe perhaps English. This is a point covered many times in this blog, in posts such as <a href="http://archives.miloush.net/michkap/archive/2005/03/01/382289.html">Code pages are really not enough....</A></FONT></P>
<P><FONT face=Tahoma>Of course if you need to work with a multibyte code page then this solution is&nbsp;clearly a big loser -- the world of lead bytes, trail bytes, <A href="http://msdn.microsoft.com/library/en-us/intl/unicode_0o2t.asp">IsDBCSLeadByte</A> API calls, and more is a truly unhappy one, in many senses (I lived in that world for a time, and while I would not think of it as hell per se, in many senses it will live on in my memory&nbsp;as utter pandemonium). And this is even before considering the fact that every single MBCS code page is officially infufficient to cover all of the languages.</FONT></P>
<P><FONT face=Tahoma>I'll split out GB-18030 from this mix, since clearly it is sufficient. However, it has the same problem&nbsp;with lead bytes and trail bytes, to which you can add&nbsp;the logic for the four-byte sequences. I might wish such a processing effort on a developer I did not like very much, but only if I were in a really bad mood.</FONT></P>
<P><FONT face=Tahoma>Moving on to UTF-32, obviously it is the uber-choice for ease of operations with code points since every code point has the exact same size. However, speed is also a factor of working set so this ease (leading to development "speed") must be balanced with the larger memory footprint that could affect the speed of any operations that are done, depending on the platform (this will be covered more another day).</FONT></P>
<P><FONT face=Tahoma>UTF-16 is just as good of a choice as UTF-32 if you do not need supplementary characters (Unicode code points from <A href="http://www.fileformat.info/info/unicode/char/10000/index.htm">U+10000</A> to <A href="http://www.fileformat.info/info/unicode/char/10ffff/index.htm">U+10ffff</A>). With the bonus of a smaller memory footprint. If you need to extensively use supplementary characters, however, you do lose some of the speed in order to do range checking and such. </FONT></P>
<P><FONT face=Tahoma>If you like, you can borrow the following definitions, which will be available in the winnls.h header file in the upcoming&nbsp;Platform SDK release for Longhorn Beta 1 (just remember to remove yours if you get new SDK header so you can avoid the "duplicate definition" compile errors!):</FONT></P>
<BLOCKQUOTE dir=ltr>
<P><FONT face="Courier New"><STRONG>#define HIGH_SURROGATE_START&nbsp; 0xd800<BR>#define HIGH_SURROGATE_END&nbsp;&nbsp;&nbsp; 0xdbff<BR>#define LOW_SURROGATE_START&nbsp;&nbsp; 0xdc00<BR>#define LOW_SURROGATE_END&nbsp;&nbsp;&nbsp;&nbsp; 0xdfff</STRONG></FONT></P>
<P><FONT face=Tahoma><FONT face="Courier New"><STRONG>#define IS_HIGH_SURROGATE(wch) (((wch) &gt;= HIGH_SURROGATE_START) &amp;&amp; ((wch) &lt;= HIGH_SURROGATE_END))<BR>#define IS_LOW_SURROGATE(wch)&nbsp; (((wch) &gt;= LOW_SURROGATE_START) &amp;&amp; ((wch) &lt;= LOW_SURROGATE_END))<BR>#define IS_SURROGATE_PAIR(hs, ls) (IS_HIGH_SURROGATE(hs) &amp;&amp; IS_LOW_SURROGATE(ls)) </STRONG></FONT></P></BLOCKQUOTE></FONT>
<P><FONT face=Tahoma>These additions are actually directly due to customer feedback (both internal and external to Microsoft)&nbsp;in this area -- these macros answer basic questions about supplmentary character processing in UTF-16, and it really does not make sense to force every developer to define their own. </FONT></P>
<P><FONT face=Tahoma>The header file also includes a cool comment block with sample conversions between UTF-32 and UTF-16, which for single code points or surrogate pairs could perhaps also be put in a macro but there has not really been as much demand for that, yet. Obviously there will be future releases for such things to be considered, if the demand picks up. :-)</FONT></P>
<P><FONT face=Tahoma>Now I already spake volumes about UTF-8 speed of operations yesterday with&nbsp;the simple pseudo-interview question post&nbsp;<a href="http://archives.miloush.net/michkap/archive/2005/05/21/420708.html">Getting exactly ONE Unicode code point out of UTF-8</A>. There may be good reasons to go to UTF-8 sometimes (I will talk bout them more later in the series) but speed of operations on code points is not a time that it will really shine.</FONT></P>
<P><FONT face=Tahoma>These is not much to say about <A href="http://www.unicode.org/reports/tr26/">CESU-8</A> in this context -- it essentially took everything that stinks about UTF-16 processing and everything that stinks about UTF-8 processing and combined them together. You might need to do some actual performance tests to see which would be worse for processing: MBCS code pages or CESU-8.</FONT></P>
<P><FONT face=Tahoma>In future posts, other considerations such as platform, endian issues, compression capabilities, and more will be covered. If you could limit comments to the speed of operations issue and hold off on the other issues until the relevant post come up, it would save me having to delete comments until they are relevant and I would appreciate it. :-)</FONT></P>
<P><FONT face=Tahoma></FONT>&nbsp;</P>
<P><FONT face=Tahoma><FONT color=#ff0000><EM>This post brought to you by</EM> "â‚¡" <EM>(<A href="http://www.fileformat.info/info/unicode/char/20a1/index.htm">U+20a1</A>, a.k.a. COLON SIGN)</EM></FONT></FONT></P>
<hr/><p><a id="420869" href="#420869">#</a> <strong>MGrier</strong> on 22 May 2005 2:21 PM:</p><div style="margin-left: 1em">I very strongly suspect that UTF-8 and/or using custom code pages is almost always faster because of the decreased memory footprint.<br><br>Cache lines are typically 8 bytes lately I believe, so my guess is that the only time utf-32 always wins is when you only have strings with 1-2 characters.  Utf-16: 2-4.  Utf8 is actually harder because there's greater variance based on the input size; if all your characters are in the supplementary range (and thus took 4-5 byte encodings) you'll lose but almost always otherwise, given a good enough utf-8 decoding implementation, you'll win with utf-8.<br><br>A good utf-8 decoding implementation that takes advantage of cache lines may or may not be easy depending on the compiler and CPU.<br><br>This sounds like a fun experiment to try some time.<br><br>Note that this is a statistically based argument - you can certainly find data where any one of the encodings is clearly &quot;the best&quot;.  If bounded/guaranteed worst case time is more important than better typical time, you should definitely use UTF-32.</div>
<p><a id="420881" href="#420881">#</a> <strong>Michael S. Kaplan</strong> on 22 May 2005 4:24 PM:</p><div style="margin-left: 1em">Hmmm.... I am not sure I would agree with that assessment, especially given the fact that most of UTF-8 is bigger than UTF-16 (and almost all of what is not is the same size), and most of the MBCS code pages are the same size but require more operations to be done on them.<br><br>So they lose on both size and speed in operations, on all but the ASCII scenarios. So if it isn't English, both of them will cost....</div>
<p><a id="421473" href="#421473">#</a> <strong>Michael Dunn_</strong> on 24 May 2005 12:46 PM:</p><div style="margin-left: 1em">UTF-16 has an advantage over every other encoding in that you can pass UTF-16 strings directly to Win32 APIs. If you use another encoding, you'll have to spend time converting your strings to/from UTF-16 before/after calling APIs.</div>
<p><a id="421492" href="#421492">#</a> <strong>Michael S. Kaplan</strong> on 24 May 2005 2:06 PM:</p><div style="margin-left: 1em">Hey Mike!<br><br>Yes, I cover this poin in a future article about the platform issues. :-)</div>
<p><strong>Dallas</strong> on 20 Aug 2008 5:56 AM:</p><div style="margin-left: 1em"><p>If UTF-8 is commonly called Multibyte, and UTF-16 is commonly called wide character, what common name do we give UTF-32? So do we have mbstowcs() and mbsto??s()</p>
<p>If in a UFT-8 VC++ source file, UTF-16 strings use L"" notation, how to represent UTF-32 strings? </p>
<p>In a Unicode VC++ source file (UTF-16), how do you stop Unicode character in the ASCII strings? Is there an A"" notation?</p>
<p>Even though UTF-32 exists, and when we meet up with aliens, UTF-64 may exist too, but why should we use them commonly in our programming environment? The font files will be enormous. Why not just have a different font for each language and rather than an BOM, have a language marker?</p></div>
<hr/><p><em>referenced by</em></p><div style="margin-left: 1em"><p>2010/11/24 <a href="http://archives.miloush.net/michkap/archive/2010/11/24/10095816.html">UTF-8 on a platform whose support is overwhelmingly, almost oppressively, UTF-16</a></p><p>2005/05/25 <a href="http://archives.miloush.net/michkap/archive/2005/05/25/421828.html">You may want to rethink your choice of UTF, #3 (Platform?)</a></p><p>2005/05/24 <a href="http://archives.miloush.net/michkap/archive/2005/05/24/421343.html">Encoding scheme, encoding form, or other</a></p></div><p><em>go to <a id="newer" href="http://archives.miloush.net/michkap/archive/2005/05/22/420879.html" title="For every expert...">newer</a> or <a id="older" href="http://archives.miloush.net/michkap/archive/2005/05/21/420796.html" title="Recompiling with the new version">older</a> post, or back to <a href="http://archives.miloush.net/michkap/archive/index.html">index</a> or <a href="http://archives.miloush.net/michkap/archive/index.html#2005-05">month</a> or <a href="http://archives.miloush.net/michkap/archive/index.html#2005-05-22">day</a></em></p></body>
<!-- Mirrored from archives.miloush.net/michkap/archive/2005/05/22/420822.html by HTTrack Website Copier/3.x [XR&CO'2014], Thu, 25 May 2017 00:42:41 GMT -->
</html>