<html>
<!-- Mirrored from archives.miloush.net/michkap/archive/2005/05/04/414562.html by HTTrack Website Copier/3.x [XR&CO'2014], Thu, 25 May 2017 00:42:41 GMT -->
<head><meta charset="utf-8" /><meta name="viewport" content="width=device-width" /><title>Why does MSLU wrap ________ ?</title></head><body>
<h1>Why does MSLU wrap ________ ?</h1>
<p><em>by Michael S. Kaplan, published on 2005/05/04 07:13 -04:00, original URI: http://blogs.msdn.com/b/michkap/archive/2005/05/04/414562.aspx</em></p>
<hr/> <!-- Archival Source: ProcessPostNew -->
<P><FONT face=Tahoma>Most of the APIs that MSLU wraps are on the list for obvious reasons. But in that huge list, there are several that are not....</FONT></P>
<P><FONT face=Tahoma>1) There is, for example, the <A href="http://msdn.microsoft.com/library/en-us/dllproc/base/getprocaddress.asp">GetProcAddress</A>&nbsp;function. It takes a string, but never a Unicode string, on NT or otherwise. So why would it need to be wrapped?</FONT></P>
<P><FONT face=Tahoma>Well, it turns out that the <A href="http://msdn.microsoft.com/library/en-us/gdi/monitor_27e7.asp">GetMonitorInfo</A> function, defined in multimon.h, is not just a simple prototype. There is a bunch of complex code in it that conditionally calls various APIs, including GetProcAddress, to get a function pointer to replace any call to GetMonitorInfo. Because of this, MSLU could not wrap the GetMonitorInfo function, because the wrapper would never be used. The only way to allow the to wrapper to work was to wrap GetProcAddress and look for where someone was trying to retrieve the address of GetMonitorInfoA or GetMonitorInfoW!</FONT></P>
<P><FONT face=Tahoma>2) And then there is the <A href="http://msdn.microsoft.com/library/en-us/winui/winui/windowsuserinterface/userinput/keyboardinput/keyboardinputreference/keyboardinputfunctions/enablewindow.asp">EnableWindow</A> function, which does not even take a string. Why on earth would MSLU need to wrap <EM>it</EM>?</FONT></P>
<P><FONT face=Tahoma>Back in the early days, MSLU was eager to convince people who had Unicode layers of their own to consider switching to MSLU. As a part of that, it picked up several bug fixes from other layers so that people would not have to feel like they were losing functionality for switching. One of those layers was the "VSAnsi" layer used by Visual Studio, which had an EnableWindow fix best described in a comment in the MSLU source code:</FONT></P>
<P><FONT face="Courier New" size=2>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // We wrap this API in order to get consistent behavior on both<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // NT and Win9x. It seems that on NT, any non-zero value of bEnable <BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // will enable the window.&nbsp; Based on empirical data, Win9x seems to <BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // look at only the low 16 bits of bEnable.&nbsp; This causes a problem, <BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // for example, if the caller passes a count of items with the intent <BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // to enable a window when the count is &gt;0.&nbsp; That will fail when the <BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // count is a multiple of 64K, but will be nearly impossible to find <BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // and fix the problem. See Visual Studio 7 <STRONG>######</STRONG> for an example<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // of such a bug.</FONT></P>
<P><FONT face=Tahoma>Now there were not many APIs that were taken to this kind of extreme, but the VSAnsi library was at that time owned by Lars Bergstrom (a very smart developer) and was probably the second most useful source of interesting buglets for MSLU to fix while wrapping (right after Office, which had a vitual monopoly on interesting Win9x GDI bug fixes that even external customers had found by spluenking through the exports in the MSO library, over the years). Given the unique expertise the wrapper code writing seemed to require, Lars and I probably did a ton of code reviews of each others' work before MSLU and the VSAnsi that shipped in VS 7.0 first got released. The EnableWindow bug fix was one of those little extra bug fixes that we picked up.</FONT></P>
<P><FONT face=Tahoma>3) Then there are the <A href="http://msdn.microsoft.com/library/en-us/winui/winui/windowsuserinterface/resources/introductiontoresources/resourcereference/resourcefunctions/findresource.asp">FindResourceW</A> and <A href="http://msdn.microsoft.com/library/en-us/winui/winui/windowsuserinterface/resources/introductiontoresources/resourcereference/resourcefunctions/findresourceex.asp">FindResourceExW</A> functions. Now note that Unicode versions of these functions actually exist on Win9x, so there is no good reason to wrap them, right?</FONT></P>
<P><FONT face=Tahoma>Well, actually, wrong. Both APIs took resource type and name parameters that could be either strings or numbers, but there was a bug in Windows 95 and Windows 98 (fixed in Windows Me) where in some cases the LocalFree function was being called on the parameter even though the LocalAlloc function was never called to allocate&nbsp;the string (it was a passed in parameter). This would potentially corrupt the heap. So MSLU would do the extra work to copy string parameters to stack variables, because an attempt to call LocalFree on a stack variable would simply fail with a last error of ERROR_INVALID_HANDLE. On Windows Me it would just call the OS directly since the bug had been fixed....</FONT></P>
<P><FONT face=Tahoma></FONT>&nbsp;</P>
<P><FONT face=Tahoma><FONT color=#ff0000><EM>This post brought to you by </EM>"ã††" <EM>(<A href="http://www.fileformat.info/info/unicode/char/3186/index.htm">U+3186</A>, a.k.a. HANGUL LETTER YEORINHIEUH)</EM></FONT></FONT></P>
<hr/><p><a id="414563" href="#414563">#</a> <strong>Michael S. Kaplan</strong> on 4 May 2005 5:23 AM:</p><div style="margin-left: 1em">I could be going senile, but I believe Raymond Chen was the one who tracked down the bug in FindResourceExW when it was fixed in Windows Me. <br><br>I do know he is the one who suggested to me the clever stack workaround for the problem which MSLU used to rehabilitate the function years later, though. :-)</div>
<p><a id="414592" href="#414592">#</a> <strong>Dean Harding</strong> on 4 May 2005 8:22 AM:</p><div style="margin-left: 1em">How come GetMonitorInfo is so complex?  From the documentation, it looks like all it should do is copy info from an internal data structure to the user's buffer... ?</div>
<p><a id="414597" href="#414597">#</a> <strong>Michael S. Kaplan</strong> on 4 May 2005 8:38 AM:</p><div style="margin-left: 1em">I believe the complexities were due to an attempt to handle platform differences transparently in the header file, so you could call code the same way without worrying about the all multimon support changes.</div>
<p><strong>Yuhong Bao</strong> on 10 Oct 2007 10:53 PM:</p><div style="margin-left: 1em"><p>&quot;but there was a bug in Windows 95 and Windows 98 (fixed in Windows Me) where in some cases the LocalFree function was being called on the parameter even though the LocalAlloc function was never called to allocate the string (it was a passed in parameter). This would potentially corrupt the heap. So MSLU would do the extra work to copy string parameters to stack variables, because an attempt to call LocalFree on a stack variable would simply fail with a last error of ERROR_INVALID_HANDLE.&quot;</p>
<p>Why not use LocalAlloc to allocate a buffer and copy a string to it?</p></div>
<p><strong>Michael S. Kaplan</strong> on 11 Oct 2007 12:09 AM:</p><div style="margin-left: 1em"><p>Because we wouldn't always know when it was freed and when it was not across the various versons of Windows without writing a much more complex wrapper -- this way MSLU could have simpler code that would work in all versions....</p>
</div>
<p><strong>Yuhong Bao</strong> on 9 Nov 2008 4:12 AM:</p><div style="margin-left: 1em">

<p>// NT and Win9x. It seems that on NT, any non-zero value of bEnable<br>// will enable the window. &nbsp;Based on empirical data, Win9x seems to<br>// look at only the low 16 bits of bEnable. &nbsp;This causes a problem, </p>
<p>Do you know that the majority of USER32 and GDI32 functions in Win9x thunks to the 16-bit USER and GDI? I think what is happening here is that during thunking, bEnable got truncated to 16-bit and so EnableWindow can only look at the low 16-bits.</p></div>
<p><strong>Michael S. Kaplan</strong> on 9 Nov 2008 8:42 AM:</p><div style="margin-left: 1em"><p>While much of what you say is true for USER, it is largely untrue for GDI...</p>
</div>
<p><strong>Yuhong Bao</strong> on 2 May 2009 11:44 PM:</p><div style="margin-left: 1em"><p>&quot;I think what is happening here is that during thunking, bEnable got truncated to 16-bit and so EnableWindow can only look at the low 16-bits.&quot;</p>
<p>In fact, that is why the thunk compiler provides a special bool type. Because if you use the int type for BOOLs in thunk scripts, things like this can happen.</p></div>
<hr/><p><em>referenced by</em></p><div style="margin-left: 1em"><p>2012/08/01 <a href="http://archives.miloush.net/michkap/archive/2012/08/01/10335466.html">When my decisions come back to haunt me (and/or others!)</a></p></div><p><em>go to <a id="newer" href="http://archives.miloush.net/michkap/archive/2005/05/05/414845.html" title="A few of the gotchas of CompareString">newer</a> or <a id="older" href="http://archives.miloush.net/michkap/archive/2005/05/04/414520.html" title="Collation data -- must be stable, but it must not stand still">older</a> post, or back to <a href="http://archives.miloush.net/michkap/archive/index.html">index</a> or <a href="http://archives.miloush.net/michkap/archive/index.html#2005-05">month</a> or <a href="http://archives.miloush.net/michkap/archive/index.html#2005-05-04">day</a></em></p></body>
<!-- Mirrored from archives.miloush.net/michkap/archive/2005/05/04/414562.html by HTTrack Website Copier/3.x [XR&CO'2014], Thu, 25 May 2017 00:42:41 GMT -->
</html>