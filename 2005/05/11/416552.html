<html>
<!-- Mirrored from archives.miloush.net/michkap/archive/2005/05/11/416552.html by HTTrack Website Copier/3.x [XR&CO'2014], Thu, 25 May 2017 00:42:41 GMT -->
<head><meta charset="utf-8" /><meta name="viewport" content="width=device-width" /><title>UCS-2 vs. UTF-16 (not quite Kramer vs. Kramer)</title></head><body>
<h1>UCS-2 vs. UTF-16 (not quite Kramer vs. Kramer)</h1>
<p><em>by Michael S. Kaplan, published on 2005/05/11 17:01 -04:00, original URI: http://blogs.msdn.com/b/michkap/archive/2005/05/11/416552.aspx</em></p>
<hr/> <!-- Archival Source: ProcessPostNew -->
<P><FONT face=Tahoma>Rasqual asked, in the suggestion box:</FONT></P>
<BLOCKQUOTE dir=ltr style="MARGIN-RIGHT: 0px">
<P><FONT face=Tahoma size=2>Windows associates the idea of Unicode with 'Wide char', that is a 2-byte long character (currently). </FONT></P>
<P><FONT face=Tahoma size=2>A comment on Raymond Chen's blog stated that Windows 2000 uses the UCS-2 representation of Unicode <BR>and Windows XP and higher use UTF-16 (both little-endian). </FONT></P>
<P><FONT face=Tahoma size=2>Can you put up an explanation of whether a UCS-2 byte stream may be considered valid UTF-16? </FONT></P>
<P><FONT face=Tahoma size=2>The point is: can I use UTF-16 generically to handle "wide char" text or are there some caveats? Would a <BR>call to, say, CreateFileW with a filename containing surrogates fail on Windows 2000? </FONT></P>
<P><FONT face=Tahoma size=2>Is it unsafe to assume 1 WCHAR == 1 Unicode character? <BR><BR>Note that this has no practical application, just things I'm wondering about.</FONT></P></BLOCKQUOTE>
<P><FONT face=Tahoma>Well, in an absolutely technical sense, at the file system level -- or even at the level where CreateFileW works, Windows is neither. The OS simply takes an array of WCHAR values with a maximum size and a null WCHAR at the end, with a small number of illegal WCHAR values representing doublequotes and such. There are all sorts of obnoxious things you can put in there -- illegal Thai sequences, unpaired surrogate code units, undefined code points -- and they will simply work. The only thing that is done is an uppercase table is consulted to create case insensitivity.</FONT></P>
<P><FONT face=Tahoma>However, when you move up to the level of displaying&nbsp;the list of files in a directory -- the Windows Shell (which is indeed where Raymond Chen works!), suddenly we start becoming conformant to all sorts of different standards and practices. And all of those misbehaving strings suddenly don't look very good (a fact that you do not notice when its just a small array of WCHAR values). And here is where the issue of surrogate pairs gets interesting....</FONT></P><FONT face=Tahoma>
<P><FONT face=Tahoma>Now when Windows 2000 first shipped, there were not any actual defined supplementary characters (other than the Plane 14 language tags that no one liked or the Plane 15 and 16 private use characters that no one used).</FONT></P></FONT>
<P><FONT face=Tahoma>Because of this more than anything else, Windows 2000 is not really "surrogate-enabled" by default. But there is nothing to stop surrogate code units from being used legally with valid pairings of high and low surrogates to represent supplementary characters. So people (if they said anything) would tend to just say it supports "UCS-2" as a shorthand for saying that it was "surrogate neutral." It had no knowledge or understanding&nbsp;of what these code points are, but is not actively destructive. But usually it would not come up....</FONT></P>
<P><FONT face=Tahoma>By the time Windows XP, the landscape had changed a bit.</FONT></P>
<P><FONT face=Tahoma>The OpenType spec extensions to support supplementary characters were mature and people were making use of them. Although there were not yet fonts shippng in the operating system, there were fonts out there, some available in Micrsosoft products and others from third parties. And anytime Uniscribe was turned on, the extra work to make sure that surrogate pairs got treated as one character (showing just one NULL GLYPH if no font was available), paryially supported in Windows 2000, became more fully supported.</FONT></P>
<P><FONT face=Tahoma>At some point, a switch was flipped and everyone started talking about all of the work that had been done. But how do you describe infrastructure when you do not have fonts to actually display the characters? The only way it could be described was that we now support UTF-16, whereas before it was just UCS-2. And the whole distinction between the two platforms was made, kind of after the fact.</FONT></P>
<P><FONT face=Tahoma></FONT>&nbsp;</P>
<P><FONT face=Tahoma><FONT color=#ff0000><EM>This post brought to you by</EM> "êíÄ" <EM>(U+10480, a.k.a. OSMANYA LETTER ALEF)<BR><FONT size=2>(or U+d801 U+dc80 for people who prefer to work in surrogate pairs!)</FONT></EM></FONT></FONT></P>
<hr/><p><a id="416647" href="#416647">#</a> <strong>MGrier</strong> on 11 May 2005 6:20 PM:</p><div style="margin-left: 1em">Well actually if you're a /good/ UCS-2 citizen you should have rejected any 2-byte sequences in the surrogate pair range.<br><br>Maybe it's fortunate that everyone wasn't good and thus tends to just be a pipe for byte-pairs that we can redefine to USHORT, UCS-2 or UTF-16 as we see fit...</div>
<p><a id="416662" href="#416662">#</a> <strong>Michael S. Kaplan</strong> on 11 May 2005 7:07 PM:</p><div style="margin-left: 1em">Well, that point is one others would disagree with (it would make an applictation not forward compatible).</div>
<p><a id="417563" href="#417563">#</a> <strong>Qflash</strong> on 15 May 2005 2:21 AM:</p><div style="margin-left: 1em">RePost:<br><a rel="nofollow" target="_new" href="http://www.yeyan.cn/SoftwareEngineering/UTF16UCS2.aspx">http://www.yeyan.cn/SoftwareEngineering/UTF16UCS2.aspx</a></div>
<p><a id="418783" href="#418783">#</a> <strong>Ben Bryant</strong> on 17 May 2005 12:51 PM:</p><div style="margin-left: 1em">Good information, but I am not sure if the simplest part of the question was answered, and I think I can handle it: yes, &quot;a UCS-2 byte stream may be considered valid UTF-16&quot;. i.e. if it was valid UCS-2, it surely is valid UTF-16. It gets complicated when you're talking about whether parts of the platform are really dealing with UCS-2 or UTF-16.</div>
<p><a id="418909" href="#418909">#</a> <strong>Michael S. Kaplan</strong> on 17 May 2005 5:04 PM:</p><div style="margin-left: 1em">Yes -- what was valid UCS-2 is valid UTF-16.<br><br>Also, since each version has some rules about allowing future version code to work in it, one could say that any valid UTF-16 is vali UCS-2, also. :-)</div>
<hr/><p><em>referenced by</em></p><div style="margin-left: 1em"><p>2008/09/08 <a href="http://archives.miloush.net/michkap/archive/2008/09/08/8931641.html">UCS-2 to UTF-16, Part 1: Getting the obvious out of the way</a></p><p>2006/01/17 <a href="http://archives.miloush.net/michkap/archive/2006/01/17/513635.html">They don't make Null Glyphs like they used to!</a></p><p>2005/05/12 <a href="http://archives.miloush.net/michkap/archive/2005/05/12/416735.html">Thinking beyond the BMP of Unicode</a></p></div><p><em>go to <a id="newer" href="http://archives.miloush.net/michkap/archive/2005/05/11/416624.html" title="Why UnicoWS.dll forwards to the OS on Unicode platforms">newer</a> or <a id="older" href="http://archives.miloush.net/michkap/archive/2005/05/11/416293.html" title="Case/kana/accent/width sensitive SQL Server, for testing">older</a> post, or back to <a href="http://archives.miloush.net/michkap/archive/index.html">index</a> or <a href="http://archives.miloush.net/michkap/archive/index.html#2005-05">month</a> or <a href="http://archives.miloush.net/michkap/archive/index.html#2005-05-11">day</a></em></p></body>
<!-- Mirrored from archives.miloush.net/michkap/archive/2005/05/11/416552.html by HTTrack Website Copier/3.x [XR&CO'2014], Thu, 25 May 2017 00:42:41 GMT -->
</html>