<html>
<!-- Mirrored from archives.miloush.net/michkap/archive/2005/05/11/416717.html by HTTrack Website Copier/3.x [XR&CO'2014], Thu, 25 May 2017 00:42:41 GMT -->
<head><meta charset="utf-8" /><meta name="viewport" content="width=device-width" /><title>Dealing with backcompat across many versions</title></head><body>
<h1>Dealing with backcompat across many versions</h1>
<p><em>by Michael S. Kaplan, published on 2005/05/11 22:40 -07:00, original URI: http://blogs.msdn.com/michkap/archive/2005/05/11/416717.aspx</em></p>
<hr/> <!-- Archival Source: ProcessPostOld -->
<P><a href="http://blogs.msdn.com/LarryOsterman/"><FONT face=Tahoma>Larry Osterman</FONT></A><FONT face=Tahoma> posted earlier today about </FONT><A id=_ctl0__ctl0__ctl0__ctl0_RecentPosts__ctl0_postlist__ctl0_EntryItems__ctl0_PostTitle href="http://blogs.msdn.com/larryosterman/archive/2005/05/11/416497.aspx"><FONT face=Tahoma>Turning the blog around - End of Life issues</FONT></A><FONT face=Tahoma>&nbsp;and I thought about the issue. I think I have talked about the backcompat issues enough in the past that it is pretty clear where I stand on the issue of when we say that some particular API set or feature or function or behavior is done. </FONT></P>
<P><FONT face=Tahoma>I don't think we really can. At all.</FONT></P>
<P><FONT face=Tahoma>I feel that way b</FONT><FONT face=Tahoma>ecause in my opinion the one customer we cannot <EM>ever</EM> let down is the one who figured out how to leverage our API sets, use our features, call&nbsp;our functions, &nbsp;and rely on our behaviors. The one who wrote an application that used all of these things. Because that application will have customers and they will be relying on everything working in the same way. When there are changes there must be clear and unambiguous reasons for why.</FONT></P>
<P><FONT face=Tahoma>So should we fix the sort order if for some reason it thought that <STRONG>Z</STRONG> came before <STRONG>B</STRONG> in English? </FONT></P>
<P><FONT face=Tahoma><STRONG>Yes</STRONG>, because English speaking users of today would have noticed this and considered it a bug. </FONT></P>
<P><FONT face=Tahoma>But should we change the underlying nature of the <A href="http://msdn.microsoft.com/library/en-us/winui/winui/windowsuserinterface/resources/strings/stringreference/stringfunctions/comparestring.asp">CompareString</A> API to start returning an Enum instead of an int because it makes debugging more convenient? </FONT></P>
<P><FONT face=Tahoma><STRONG>Hell no</STRONG>, because debugging would suddenly become less important as we just caused every application in the universe to start failing to compile -- meaning they would never get to the place easier debugging would be a useful feature.</FONT></P>
<P><FONT face=Tahoma>Now obviously those two examples&nbsp;are extremes, and the issues about which people fight are not always this obvious. But as a guideline it is where I would draw that line, and the standard I would hold us to. And where I do hold us to, whenever it is either up to me or when I have a voice. </FONT></P>
<P><FONT face=Tahoma>Let's look at the summary:</FONT></P><FONT face=Tahoma>
<UL>
<LI><FONT face=Tahoma>Some things are not going to change -- their users must deal with that;</FONT> 
<LI><FONT face=Tahoma>Other things can and might change in any version (like updated Unicode properties or collation values)&nbsp;-- their users must deal with that as well;</FONT> 
<LI><FONT face=Tahoma>Still other things change which were not anticipated but there is a good reason for the change -- but backcompat is given a high priority.</FONT></LI></UL></FONT>
<P><FONT face=Tahoma>A good example of that third category (which contains many items!) is if we change the behavior of a function that takes a structure. Like if we changed <A href="http://msdn.microsoft.com/library/en-us/intl/nls_5e7i.asp">GetNLSVersion</A>&nbsp;in some way, we'd do in the typical Win32 way -- we would change the <A href="http://msdn.microsoft.com/library/en-us/intl/nls_6faq.asp">NLSVERSIONINFO</A>'s <EM>dwNLSVersionInfoSize</EM> member to a new size to fit whatever the new features are. And people who call it the old way will get the old behavior.</FONT></P>
<P><FONT face=Tahoma>One major agenda item we have had that does break compatibility and which we live with the break is for security. For obvious reasons.</FONT></P><FONT face=Tahoma>
<P><FONT face=Tahoma>But (as a PM colleague of mine likes to say) why don't we take a step back for a moment?</FONT></P>
<P>Now there are other products which obviously have to deal with the same problem. </FONT></P>
<P><FONT face=Tahoma>Do any of them deal with the juggling of "compatibility versus correctness" (to use a simplifying statement of the clash) in a different way? </FONT></P>
<P><FONT face=Tahoma>And if so, can we learn from them?</FONT></P>
<P><FONT face=Tahoma>What about the C/C++ compiler? Although not a part of the operating system, it is used to <STRONG>build</STRONG> the operating system, so clearly its methods of dealing with the problem affect the OS. How do they solve this problem?</FONT></P>
<P><FONT face=Tahoma>Well, they tey to not change behavior. And as they struggle to become more and more comformant to the official C++ standard (breaking more and more&nbsp;developers), they add flags to make sure that people who need the old behavior have a way to get to it. And there are some features (like the format of the .PDB files and the syntax of C++ function name decoration) that changes every version and no one should ever rely on for that reason.</FONT></P>
<P><FONT face=Tahoma>Which in a way indirectly answers how they handle the situation, both things that are the same and things that are different:</FONT></P>
<UL>
<LI><FONT face=Tahoma>Some things are not going to change -- their users must deal with that;</FONT> 
<LI><FONT face=Tahoma>Other things can and do change every version (think .PDB format or C++ namd decoration)&nbsp;-- their users must deal with that as well;</FONT> 
<LI><FONT face=Tahoma>Still other things change which were not anticipated but there is a good reason for the change -- users must deal with that, but they are given tools to assist.</FONT></LI></UL>
<P><FONT face=Tahoma>I'd say that in Windows as well as in NLS we clearly have the first two bit but they handle the third a bit differently&nbsp;a lot of the time. There are many cases where a change in the way flags work might happen, but a flag was added to get the old behavior for people who really need it. But in a lot of other cases, the new flags are nor the new behavior, like adding new warnings for new platforms. </FONT></P>
<P><FONT face=Tahoma>It is probably my "external" view but I think with their important "agenda" items for change have caused more issues to come up, or maybe just ones that are harder to justify (obviously everyone has to close their mouths and take it on security but the folks who care about backward compatibility vs. C++ standards conformance are two different groups. Therefore they are more likely to have customers who are not even willing to justify the premise, whereas noi one likes to be on the side of arguing for less secure products).</FONT></P>
<P><FONT face=Tahoma>But in any case, there is really not much that they do differently that we could learn from in terms of techniques for affecting change. So we'll set them to the side for the moment.</FONT></P>
<P><FONT face=Tahoma>Let's look at other options.</FONT></P>
<P><FONT face=Tahoma>Products like Office tend to handle things just like Windows does, but moreso -- they might even still support the Excel 4.0 XLM macro stuff or .XLA dlls, for people who have Office applications that use such features. So I don't kno if there is much we can learn there.</FONT></P>
<P><FONT face=Tahoma>But I will cover this more another day.</FONT></P>
<P><FONT face=Tahoma>Then there are products like SQL Server, which have a very different model than any of these people use.</FONT></P><FONT face=Tahoma>
<P><FONT face=Tahoma>They do have those same three categories, but they handle that third one very differently.</FONT></P>
<P>The goal in SQL Server is to make an upgrade seem like nothing has happened at all, with the same behavior everywhere. And then people can jump into features as they need them. </FONT></P>
<P><FONT face=Tahoma>It is why there are so many compatibility collations that refer to SQL Server behavior as far back as 4.21 or further. And why there are compatibility constants that can take DMO and Server behavior back as far as SQL Server 6.0 in the Yukon release. And why there are so many flags with which you can start the server that give it specific old behaviors that large adoptions have been found to rely on.&nbsp; Some of these features are avalab;le only to the&nbsp;server's administrator, but other features are available to everyone</FONT></P>
<P><FONT face=Tahoma>And I wonder at that -- we don't really have such a model that is consistently used throughout Windows. </FONT></P>
<P><FONT face=Tahoma>For example, the assumptions in GDI and in typography are that even a one pixel difference with a font can cause issues for an application, and there is no global setting to say "it is okay to change anything you need to" other than just using a whole new font. And even in NLS where we have added the notion of collation versions, there is no capability present there to use a prior version's collation. </FONT></P>
<P><FONT face=Tahoma>Windows does have group policy settings to (for example) revert the way the way Shell treats digits to no longer make it like numbers (which is a lot like those various SQL Server compatibility flags) but the database administrator is not the same kind of person as the sysadmin of a large organization handling a bunch of Windows installations, so the audiences are very different.</FONT></P>
<P><FONT face=Tahoma>Is there something that can be done at the install level, the process level, or maybe at the function call level to assist developers here? A way to either o</FONT><FONT face=Tahoma>pt in to new behavior that we provide as a non-default option or o</FONT><FONT face=Tahoma>pt out of new default behavior that they do not like? Something that we can glean from the behavior of one of these other products?</FONT></P>
<P><FONT face=Tahoma>I don't have answers here (at this point), but I think I have a handle on&nbsp;a lot of the issues and (due to my past life as one of those developers who relied on the stability!) an over developed sense of how evil we would be if we violated any of the reasonable assumptions that developers would make about our API set's behavior. So I guess my answer to Larry's question is mostly the same:</FONT></P><FONT face=Tahoma>
<P><EM><FONT size=4><FONT face=Tahoma>We cannot completely drop support for anything at this point, b</FONT><FONT face=Tahoma>ecause in my opinion the one customer we cannot ever let down is the one who figured out how to leverage our API sets, use our features, call&nbsp;our functions, &nbsp;and rely on our behaviors. The one who wrote an application that used all of these things. Because that application will have customers and they will be relying on everything working in the same way. When there are changes there must be clear and unambiguous reasons for why.</FONT></FONT></EM></P>
<P>But I think we need to start building in more support for both the opt-in and opt-out technologies to make it easier to help migrate people away from what needs to go away and toward what we are doing now. Because the platform is only going to get more complex, and to fulfull the contract of the preceeding paragraph we must give those developers the tools they need.</P>
<P>Ok, that is a lot to chew on. I'd wager that the only way someone made it to this paragraph would be if they had skipped to the end, but just in case you have a thought on this, feel free to leave a comment either&nbsp;to <a href="http://blogs.msdn.com/larryosterman/archive/2005/05/11/416497.aspx">Larry's post</A>&nbsp;or these blatherings....</P></FONT>
<hr/><p><a id="416730" href="#416730">#</a> <strong>LarryOsterman</strong> on Wednesday, May 11, 2005 11:52 PM:</p><div style="margin-left: 1em">Actually, IMHO, there is ONE (and only one) time when it's possible to end-of-life an API set.<br><br>A number of people have hinted at it in the comments on my blog (which have been extraordinary, btw - some really good ideas have been tossed out), but nobody has yet hit on what I consider the one key element.<br><br>And I'll talk about the time (recently) when we tried to end-of-life an API and failed miserably.</div>
<p><a id="416733" href="#416733">#</a> <strong>Michael S. Kaplan</strong> on Wednesday, May 11, 2005 11:56 PM:</p><div style="margin-left: 1em">I tend to agree -- its why I am aiming to how best to morph functionality using opt-in or opt-out methods, depending on which is more appropriate)....</div>
<hr/><p><em>go to <a id="newer" href="http://archives.miloush.net/michkap/archive/2005/05/12/416735.html" title="Thinking beyond the BMP of Unicode">newer</a> or <a id="older" href="http://archives.miloush.net/michkap/archive/2005/05/11/416624.html" title="Why UnicoWS.dll forwards to the OS on Unicode platforms">older</a> post, or back to <a href="http://archives.miloush.net/michkap/archive/index.html">index</a> or <a href="http://archives.miloush.net/michkap/archive/index.html#2005-05">month</a> or <a href="http://archives.miloush.net/michkap/archive/index.html#2005-05-11">day</a></em></p></body>
<!-- Mirrored from archives.miloush.net/michkap/archive/2005/05/11/416717.html by HTTrack Website Copier/3.x [XR&CO'2014], Thu, 25 May 2017 00:42:41 GMT -->
</html>