<html>
<!-- Mirrored from archives.miloush.net/michkap/archive/2005/11/23/495193.html by HTTrack Website Copier/3.x [XR&CO'2014], Thu, 25 May 2017 00:42:40 GMT -->
<head><meta charset="utf-8" /><meta name="viewport" content="width=device-width" /><title>100% roundtrip ASCII? 100% roundtrip ANSI?</title></head><body>
<h1>100% roundtrip ASCII? 100% roundtrip ANSI?</h1>
<p><em>by Michael S. Kaplan, published on 2005/11/23 04:01 -05:00, original URI: http://blogs.msdn.com/b/michkap/archive/2005/11/23/495193.aspx</em></p>
<hr/> <!-- Archival Source: ProcessPostNew -->
<P><FONT face=Tahoma>Back in January I was talking about <a href="http://archives.miloush.net/michkap/archive/2005/01/05/347394.html">the new compiler error C4819</A> and <a href="http://archives.miloush.net/michkap/archive/2005/01/08/349230.html">how the compiler detected invalid characters</A>.</FONT></P>
<P><FONT face=Tahoma>And anyone who has been reading here knows that the <a href="http://archives.miloush.net/michkap/archive/2005/11/01/487665.html">reverse solidus is always the path separator</A>, even when it looks like a yen or a won.</FONT></P>
<P><FONT face=Tahoma>So among the so-called 'ANSI' code pages, ASCII (0x00 - 0x7f) will roundtrip 100% of the time.</FONT></P>
<P><FONT face=Tahoma>How many "invalid" slots are there in the 'ANSI' code pages in the 0x80 - 0xff range, exactly?</FONT></P>
<P><FONT face=Tahoma>Let's take a look at the <A href="http://www.microsoft.com/globaldev/reference/WinCP.mspx">Windows code pages</A>:</FONT></P>
<UL>
<LI><FONT face=Tahoma>874 (<A href="http://www.microsoft.com/globaldev/reference/sbcs/874.mspx">Thai</A>) - 31 invalid</FONT> 
<LI><FONT face=Tahoma>932 (<A href="http://www.microsoft.com/globaldev/reference/dbcs/932.mspx">Japanese Shift-JIS</A>) - 5 invalid, 45 lead bytes, 15 reserved lead bytes = up to 65 invalid</FONT> 
<LI><FONT face=Tahoma>936 (<A href="http://www.microsoft.com/globaldev/reference/dbcs/936.mspx">Simplified Chinese GBK</A>) -&nbsp;1 invalid, 126 lead bytes, 0 reserved lead bytes = up to 127 invalid</FONT> 
<LI><FONT face=Tahoma>949 (<A href="http://www.microsoft.com/globaldev/reference/dbcs/949.mspx">Korean</A>) - 2 invalid, 124 lead bytes, 2 reserved lead bytes = up to 128 invalid</FONT> 
<LI><FONT face=Tahoma>950 (<A href="http://www.microsoft.com/globaldev/reference/dbcs/950.mspx">Traditional Chinese Big5</A>) - 2 invalid, 87 lead bytes, 39 reserved lead bytes&nbsp; = up to 128 invalid</FONT> 
<LI><FONT face=Tahoma>1250 (<A href="http://www.microsoft.com/globaldev/reference/sbcs/1250.mspx">Central Europe</A>) - 5 invalid</FONT> 
<LI><FONT face=Tahoma>1251 (<A href="http://www.microsoft.com/globaldev/reference/sbcs/1251.mspx">Cyrillic</A>) - 1 invalid</FONT> 
<LI><FONT face=Tahoma>1252 (<A href="http://www.microsoft.com/globaldev/reference/sbcs/1252.mspx">Latin I</A>) -&nbsp;5 invalid</FONT> 
<LI><FONT face=Tahoma>1253 (<A href="http://www.microsoft.com/globaldev/reference/sbcs/1253.mspx">Greek</A>) - 17 invalid</FONT> 
<LI><FONT face=Tahoma>1254 (<A href="http://www.microsoft.com/globaldev/reference/sbcs/1254.mspx">Turkish</A>) - 7 invalid</FONT> 
<LI><FONT face=Tahoma>1255 (<A href="http://www.microsoft.com/globaldev/reference/sbcs/1255.mspx">Hebrew</A>) - 23 invalid</FONT> 
<LI><FONT face=Tahoma>1256 (<A href="http://www.microsoft.com/globaldev/reference/sbcs/1256.mspx">Arabic</A>) - 0 invalid</FONT> 
<LI><FONT face=Tahoma>1257 (<A href="http://www.microsoft.com/globaldev/reference/sbcs/1257.mspx">Baltic</A>) - 12 invalid</FONT> 
<LI><FONT face=Tahoma>1258 (<A href="http://www.microsoft.com/globaldev/reference/sbcs/1258.mspx">Vietnam</A>) - 9 invalid</FONT></LI></UL>
<P><FONT face=Tahoma>There you have it. Code page 1256 is the only one that is guaranteed to be able to roundtrip every single code point without losing any of the bytes....</FONT></P>
<P><FONT face=Tahoma></FONT>&nbsp;</P>
<P><FONT face=Tahoma color=#ff1493><EM>This post brought to you by</EM> "<FONT size=6>Â¿</FONT>" <EM>(</EM><A href="http://www.fileformat.info/info/unicode/char/00bf"><EM>U+00bf</EM></A><EM>, INVERTED QUESTION MARK)</EM></FONT></P>
<hr/><p><a id="496267" href="#496267">#</a> <strong>Ben Bryant</strong> on 23 Nov 2005 10:54 AM:</p><div style="margin-left: 1em">100% roundtrip ANSI is a novel concept -- I am not sure of the purpose but anyway I noticed you glossed over the fact that the double byte sets are hard to quantify the same as the single byte ones by saying &quot;up to&quot; rather than trying to get into how the lead bytes depend on the trail bytes, and a byte like 0x30 that looks like ASCII can fail the round-trip if it is a trail byte. (geeks!)</div>
<p><a id="496273" href="#496273">#</a> <strong>Michael S. Kaplan</strong> on 23 Nov 2005 11:08 AM:</p><div style="margin-left: 1em">The 100% roundtrp question comes up in ways to encode bytes without having to worry about what someone may or may not consider invalid (UTF-8 has rules as does UTF-16, and they get stricter all the time). Nice that the Arabic code page stands before us as a safe haven from all that meddling. :-)<br><br>I suppose I could have written a program to go through each of the trail bytes for those lead bytes and gotten the % of invalids per lead byte and maybe averaged them, but it seemedlik a strange exercise that may not yield much additional info. <br><br>In the end, I guess I was mostly being lazy. Vacation does that....</div>
<p><a id="496288" href="#496288">#</a> <strong>Maurits [MSFT]</strong> on 23 Nov 2005 11:27 AM:</p><div style="margin-left: 1em">You say that 1252 has 1 invalid character.  I count 5.</div>
<p><a id="496297" href="#496297">#</a> <strong>Michael S. Kaplan</strong> on 23 Nov 2005 11:40 AM:</p><div style="margin-left: 1em">Whoops, you are correct -- sorry, small transcription error!</div>
<p><a id="496330" href="#496330">#</a> <strong>Mihai</strong> on 23 Nov 2005 12:26 PM:</p><div style="margin-left: 1em">I am not sure I understand.<br>Roundtrip to what?<br></div>
<p><a id="496639" href="#496639">#</a> <strong>Nick Lamb</strong> on 24 Nov 2005 5:27 AM:</p><div style="margin-left: 1em">So, to use UTF-8 with the current/next Microsoft compiler you need to tell the OS that your locale uses Arabic codepage 1256 ?<br><br>And that's a &quot;cool feature&quot; ?</div>
<p><a id="496679" href="#496679">#</a> <strong>Michael S. Kaplan</strong> on 24 Nov 2005 9:25 AM:</p><div style="margin-left: 1em">Nick, huh? That is not what I said.<br><br>What I am saying is that there are times when a person may not be sure of the code page. If you are not, then assuming it is UTF-8 and converting is guaranteed to cause problems -- because illegal sequences cannot be emitted. But cp1256 is a code page you can szafely roundtrip any byte sequence through without losing any bytes because all bytes are legal there.<br><br>Obviously if you know the code page you do not need this. So the times that this is needed will hopefully be rare. But most people roundtrip data through code pages 1252 when they have to do this sort of thing, which is incredibly dangerous since you can actually lose information!</div>
<p><a id="496741" href="#496741">#</a> <strong>Nick Lamb</strong> on 24 Nov 2005 1:18 PM:</p><div style="margin-left: 1em">Maybe I'm jumping ahead here...<br><br>1. C4819 is generated for input which contains &quot;invalid characters&quot;<br><br>2. Windows isn't really UTF-8 capable because, well basically because Windows wasn't very well designed twenty years ago.<br><br>3. So to avoid C4819 you need a locale where all your 8-bit data, which Windows can't conceive of as Unicode, is &quot;valid&quot; even if meaningless.<br><br>4. In this post we find out that the locale needed is cp1256, Arabic.</div>
<p><strong>Medinoc</strong> on 6 Sep 2011 8:04 AM:</p><div style="margin-left: 1em"><p>The short internal links are dead...</p>
</div>
<p><strong>Michael S. Kaplan</strong> on 6 Sep 2011 10:26 AM:</p><div style="margin-left: 1em"><p>Yes, six years later, they moved everything. You have to go <a href="http://msdn.microsoft.com/en-us/goglobal/bb964653">the new site</a> to find them now....</p></div>
<hr/><p><em>referenced by</em></p><div style="margin-left: 1em"><p>2008/11/25 <a href="http://archives.miloush.net/michkap/archive/2008/11/25/9140152.html">Azeri serious bug for non-Unicode SQL Server columns?</a></p><p>2008/07/03 <a href="http://archives.miloush.net/michkap/archive/2008/07/03/8682656.html">Ignore what the label says -- it's Japanese</a></p><p>2006/05/26 <a href="http://archives.miloush.net/michkap/archive/2006/05/26/608230.html">Two chickens in every pot, and an ASCII in every code page</a></p><p>2006/03/17 <a href="http://archives.miloush.net/michkap/archive/2006/03/17/553499.html">On the fuzzier definition of a 'Unicode application' on Win9x....</a></p><p>2006/02/14 <a href="http://archives.miloush.net/michkap/archive/2006/02/14/531572.html">Every character has a story #18: U+06cc and U+064a (ARABIC LETTER FARSI YEH and ARABIC LETTER YEH)</a></p><p>2005/12/03 <a href="http://archives.miloush.net/michkap/archive/2005/12/03/499661.html">The default character is not always the question mark</a></p></div><p><em>go to <a id="newer" href="http://archives.miloush.net/michkap/archive/2005/11/24/495349.html" title="And you can&#39;t set all of the properties all of the time...">newer</a> or <a id="older" href="http://archives.miloush.net/michkap/archive/2005/11/22/495033.html" title="More on the fabled EqualString">older</a> post, or back to <a href="http://archives.miloush.net/michkap/archive/index.html">index</a> or <a href="http://archives.miloush.net/michkap/archive/index.html#2005-11">month</a> or <a href="http://archives.miloush.net/michkap/archive/index.html#2005-11-23">day</a></em></p></body>
<!-- Mirrored from archives.miloush.net/michkap/archive/2005/11/23/495193.html by HTTrack Website Copier/3.x [XR&CO'2014], Thu, 25 May 2017 00:42:40 GMT -->
</html>