<html>
<!-- Mirrored from archives.miloush.net/michkap/archive/2005/11/17/492197.html by HTTrack Website Copier/3.x [XR&CO'2014], Thu, 25 May 2017 00:42:40 GMT -->
<head><meta charset="utf-8" /><meta name="viewport" content="width=device-width" /><title>Parse vs. ParseExact, revisited</title></head><body>
<h1>Parse vs. ParseExact, revisited</h1>
<p><em>by Michael S. Kaplan, published on 2005/11/17 03:01 -05:00, original URI: http://blogs.msdn.com/b/michkap/archive/2005/11/17/492197.aspx</em></p>
<hr/> <!-- Archival Source: ProcessPostNew -->
<P><FONT face=Tahoma>It is hard to believe that it has been almost a year since I talked about <STRONG><a href="http://archives.miloush.net/michkap/archive/2004/11/26/270769.html">'Evil date parsing', Parse, and ParseExact</A></STRONG>. But that post was done on November 26, 2004, so it must be true.</FONT></P>
<P><FONT face=Tahoma>But the same sort of issue has come up recently in all sorts of other areas beyond that of dates. For example:</FONT></P>
<UL>
<LI><FONT face=Tahoma>Using the following in XAML:<BR><BR><SPAN style="FONT-SIZE: 10pt; COLOR: navy; FONT-FAMILY: 'Courier New'">&lt;Rectangle Width="3,3" /&gt;<BR></SPAN></FONT>
<LI><FONT face=Tahoma>Noticing that all of the following values are legal in LengthConverter:<BR><BR><FONT face="MS Shell Dlg" size=2>Height="1,,00,0", Height="1,000" and Height="1000"</FONT><BR></FONT></LI></UL>
<P><FONT face=Tahoma>Both of these examples boil down to the fundamental distinction between Parse and ParseExact:</FONT></P>
<UL>
<LI><FONT face=Tahoma><STRONG>Parse</STRONG> assumes the data is valid and does its best to fit it into the type, forcing things that seem vaguely ridiculous when a developer has a chance to invoke common sense.</FONT> 
<LI><FONT face=Tahoma><STRONG>ParseExact</STRONG> only allows the exact format specified and will throw on any variation.</FONT></LI></UL>
<P><FONT face=Tahoma>For better or worse (using those criteria)&nbsp;both <STRONG>3,3</STRONG> and <STRONG>1,,00,0</STRONG>&nbsp;are perfectly valid to the former and unrecoverable gibberish to the latter.</FONT></P>
<P><FONT face=Tahoma>In many cases&nbsp;it can be worse, if you ask me. Especially when these values are filled in programatically where there is no user looking at the number to notice the typo (which may very well indicate a bug in an algorthim of some sort), but even in many cases of strings in the user interface since few users are immune to typos and there are many UI situations where people will type without recognizing the mistake.</FONT></P>
<P><FONT face=Tahoma>But this is hardly the fault of either method, though -- if there is a fault, it would be in the consumers of the method who use their choice to make their interfaces either very strict or very casual.</FONT></P>
<P><FONT face=Tahoma>I can understand the decision to allow more flexibility, especially considering the wide range of skills among developers who use the .NET Framework and Visual Studio. </FONT><FONT face=Tahoma>But for you non-Mirosofties, as developers who may be using the .NET Framework yourselves, it may make sense to be less flexible, to defend yourselves from the same type of issue.</FONT></P><FONT face=Tahoma>
<P><FONT face=Tahoma>I end up getting involved because of how often cultural preferences enter into the way that both methods work, which can be an additional source of confusion when trying to track down bugs.</FONT></P>
<P>(I admit is unfair of me to assume that you are a smarter developer just because you happen to read this blog, but there it is -- if you&nbsp;are someone who does read this blog the internationalization issues may occur to you more readily!)</FONT></P>
<P><FONT face=Tahoma>One of the people asking about this issue suggested:</FONT></P>
<BLOCKQUOTE dir=ltr style="MARGIN-RIGHT: 0px">
<P><EM><FONT size=2>There should be something in between -- Parse is *way* too loose, and ParseExact is *way* too&nbsp;strict. Why couldn't there some setting in between, or some global setting to choose the level of strictness in property setting?</FONT></EM></P></BLOCKQUOTE>
<P><FONT face=Tahoma>Both suggestions are appealing,&nbsp;and the image of Goldilocks complaining about ParsePoppaBear being <EM>too strict</EM>, ParseMamaBear being <EM>too casual</EM>, and ParseBabyBear being <EM>just right</EM> is pretty darn funny. But this would hard to implement in practice since this simple model is implemented in many different methods that run across a ton of different properties. Each of those methods would need to have this third method or this configuarble switch defined; more importantly, for each method would have to define what it means to vary the strictness and when not to.</FONT></P>
<P><FONT face=Tahoma>It is easy to get people to agree on what they find to be outrageous -- extreme cases are not the problem though. It is where to draw the line between outrageous and harmless, recoverable error.</FONT></P>
<P><FONT face=Tahoma>So odds are, we are stuck with these forgiving and&nbsp;unforgiving&nbsp;constructs -- and it is up to each developer which way they want to go when they are in the world of morphing strings into other types....</FONT></P>
<P><FONT face=Tahoma></FONT>&nbsp;</P>
<P><FONT face=Tahoma color=#ff1493><EM>This post brought to you by</EM> "<FONT size=6>â‰ </FONT>" <EM>(<A href="http://www.fileformat.info/info/unicode/char/2260">U+2260</A>, a.k.a. NOT EQUAL TO)</EM></FONT></P>
<hr/><p><a id="493829" href="#493829">#</a> <strong>CornedBee</strong> on 17 Nov 2005 5:39 AM:</p><div style="margin-left: 1em">A few weeks ago, I read a quote from someone on the IE team, saying that they'd be very strict in the parsing of some new technology, having learned their lesson about forgiving parsing with HTML.<br>Perhaps the XAML people should talk to those guys.<br><br>In general, I think being forgiving when parsing is a mistake. Giving good error messages is way better. I don't think it's too much to ask of people to follow a specification, if only for the sake of interoperability. Let's take your example:<br>&lt;Rectangle Width=&quot;3,3&quot;&gt;<br><br>On first glance, I thought this specified a rectangle 3 units high and 3 units wide. I didn't look to close at the attribute name, and my native German brain was faster identifying the &quot;3,3&quot; as two coordinates than it was giving &quot;Width&quot; its exact meaning; only that it's something related to size had trickled through.<br><br>Then I re-read the thing and realized that Width couldn't refer to height. The second impulse was that you had given the rectangle a width of 3.3. Again the reason lies in my being Austrian: as you probably know, the decimal point in the German locales is ',', not '.', which is the thousands separator. So 3.3 was a reasonable guess, unlike 33, which is counterintuitive (what is that comma doing there?)<br><br>Only by actually reading the text did I find out that it was supposed to be 33.<br><br>Bottom line: loose parsing encourages sloppy coding. But sloppily coded stuff is harder to read not only for the machine, but also for humans. It is a good idea to enforce strict rules.</div>
<p><a id="493887" href="#493887">#</a> <strong>AndrewSeven</strong> on 17 Nov 2005 9:47 AM:</p><div style="margin-left: 1em">Most parsing should be strict, would the loose interpretation of &quot;3,3&quot; be dependant on the current culture? <br>Many non-English notations use the comma as the decimal &quot;separator&quot;. Is it called a &quot;point&quot; in German even though it is a comma? <br><br>Loose parsing has a place too, but mostly for treating user input where you will re-present the value for the user to verify after a loose parse. <br>When you pass the value into the system, the parse should then be strict.<br><br><br></div>
<p><a id="493964" href="#493964">#</a> <strong>Mihai</strong> on 17 Nov 2005 12:35 PM:</p><div style="margin-left: 1em">I agree parsing in locale context is tricky.<br><br>But not here! XAML is a storage format and should be locale independent: <br><a rel="nofollow" target="_new" href="http://www.mihai-nita.net/20051025a.shtml">http://www.mihai-nita.net/20051025a.shtml</a><br><br>Or maybe I don't grok the problem this early in the morning :-)</div>
<p><a id="494084" href="#494084">#</a> <strong>Maurits [MSFT]</strong> on 17 Nov 2005 4:00 PM:</p><div style="margin-left: 1em">XML has nothing to say about locali[sz]ation of floating-point attribute syntax, it just considers it another kind of PC Data.<br><br>But...<br><br>It is worth noting that the XML specs define the VersionNum entity as<br>'1.0'<br>and<br>'1.1'<br><br>respectively.</div>
<p><a id="494379" href="#494379">#</a> <strong>Gabe</strong> on 18 Nov 2005 5:03 AM:</p><div style="margin-left: 1em">The problem with Parse is that it can allow incorrect data to be parsed without error, while ParseExact requires knowing what format the input will a priori.<br><br>It might be handy to have the inbetween function perform some sort of parsing and only return a valid value if the input is unambiguous. For example, &quot;3,3&quot; could be parsed as &quot;3&quot;, &quot;3.3&quot;, or &quot;33&quot;, so it would return an error. Similarly would the date &quot;01/02/03&quot;. However, &quot;01/14/2005&quot; can only parse correctly as a date one way.<br><br>I suppose this may be harder to implement that the other two, but it seems like it could be quite useful!</div>
<p><a id="494475" href="#494475">#</a> <strong>Nick Lamb</strong> on 18 Nov 2005 11:28 AM:</p><div style="margin-left: 1em">Gabe, if you accept 01/14/2005 someone will write code that emits 01/14/2005, and of course then they'll be puzzled as to why it doesn't work on 02/03/2005.</div>
<p><a id="495196" href="#495196">#</a> <strong>Richard</strong> on 21 Nov 2005 5:22 AM:</p><div style="margin-left: 1em">&gt; XML has nothing to say about locali[sz]ation of floating-point attribute syntax<br><br>However XSD does. It specifies a period for the xsd:decimal type. xsd:float then uses this definition for the mantissa.</div>
<p><a id="9799460" href="#9799460">#</a> <strong>Petteri</strong> on 23 Jun 2009 9:46 AM:</p><div style="margin-left: 1em"><p>For me it came as full surprise that the ParseExact won't handle the MS defined DateSeparator that it uses in the MaskedTextBox.</p>
<p>Imagine my surprise when with my computer the mask</p>
<p>0000/00/00 in text box with datetime format yyyy/MM/dd gives</p>
<p>2009/06/23 and in my colleague's 2009.06.23</p>
<p>This comes to full stop when you try to use yyyy/MM/dd as parse string in the parse exact, mine works his does not.</p>
<p>To fix this I had to modify the parsing string by replacing the &quot;/&quot; with current date separator...</p>
<p>dateParse = dateParse.Replace(&quot;/&quot;, CultureInfo.CurrentCulture.DateTimeFormat.DateSeparator);</p>
<p>Now that I understand that the ParseExact is truly exact I know how to convert the strings...</p></div>
<hr/><p><em>go to <a id="newer" href="http://archives.miloush.net/michkap/archive/2005/11/17/492328.html" title="Using multiple keyboards">newer</a> or <a id="older" href="http://archives.miloush.net/michkap/archive/2005/11/16/492312.html" title="Heading to Ireland">older</a> post, or back to <a href="http://archives.miloush.net/michkap/archive/index.html">index</a> or <a href="http://archives.miloush.net/michkap/archive/index.html#2005-11">month</a> or <a href="http://archives.miloush.net/michkap/archive/index.html#2005-11-17">day</a></em></p></body>
<!-- Mirrored from archives.miloush.net/michkap/archive/2005/11/17/492197.html by HTTrack Website Copier/3.x [XR&CO'2014], Thu, 25 May 2017 00:42:40 GMT -->
</html>