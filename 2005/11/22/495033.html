<html>
<!-- Mirrored from archives.miloush.net/michkap/archive/2005/11/22/495033.html by HTTrack Website Copier/3.x [XR&CO'2014], Thu, 25 May 2017 00:42:40 GMT -->
<head><meta charset="utf-8" /><meta name="viewport" content="width=device-width" /><title>More on the fabled EqualString</title></head><body>
<h1>More on the fabled EqualString</h1>
<p><em>by Michael S. Kaplan, published on 2005/11/22 01:01 -08:00, original URI: http://blogs.msdn.com/michkap/archive/2005/11/22/495033.aspx</em></p>
<hr/> <!-- Archival Source: ProcessPostOld -->
<FONT face=Tahoma>
<P><FONT face=Tahoma>If you go back all the way to April and look at some of the comments to the <STRONG><a href="http://archives.miloush.net/michkap/archive/2005/04/10/406880.html">What the %#$* is wrong with German sorting?</A></STRONG> post you will see&nbsp;one of those&nbsp;times that the fact that we have to equate sorting and comparison can confuse people about the results.</FONT></P>
<P>And about&nbsp;a week ago in the <a href="http://archives.miloush.net/michkap/archive/2005/11/13/491646.html"><STRONG>Hungarian is even more complicated than I thought</STRONG></A> post, I explained why the lack of a companion function to <A href="http://msdn.microsoft.com/library/en-us/winui/winui/windowsuserinterface/resources/strings/stringreference/stringfunctions/comparestring.asp">CompareString</A> that tested for equality kept a particular (uncommon?) feature in Hungarian collation from being supported.</P>
<P>But the thing that has generated the most email&nbsp;was neither&nbsp;the issues related to German&nbsp;nor the issues related to Hungarian; it was my contention that the difference between <A href="http://msdn.microsoft.com/library/en-us/winui/winui/windowsuserinterface/resources/strings/stringreference/stringfunctions/comparestring.asp">CompareString</A>&nbsp;and a theoretical <STRONG>EqualString</STRONG> function was orders of magnitiude greater than the difference between <A href="http://msdn.microsoft.com/library/en-us/kmarch/hh/kmarch/k109_ddeef320-7510-446b-af6f-756c3999bec1.xml.asp">RtlCompareUnicodeString</A> and an&nbsp;<A href="http://msdn.microsoft.com/library/en-us/kmarch/hh/kmarch/k109_59d7c507-968a-4cf5-b1f0-91c8cd7ccb64.xml.asp">RtlEqualUnicodeString</A>.</P>
<P>A bunch of people wanted to understand better why the performance difference is so... well... <EM>different</EM>.</P>
<P>And a bunch of other people want to know why, <EM>if</EM> the Rtl* difference is so near to inconsequential yet <EM>they</EM> get the two functions why the NLS side of the world would not get two functions if the performance difference is so bleeding consequential.</P>
<P>Two different, excellent questions in there (and I did retain the most amusing of the wordings of the two questions). To answer the first question, I will&nbsp;explain further&nbsp;the difference between the two scenarios (the binary/ordinal vs. the linguistic).</P>
<UL>
<LI><A href="http://msdn.microsoft.com/library/en-us/kmarch/hh/kmarch/k109_ddeef320-7510-446b-af6f-756c3999bec1.xml.asp">RtlCompareUnicodeString</A>&nbsp;has a simple job -- take two strings and return 0 if they are equal, &lt; 0 if string1 is less than string2, and &gt; 0 if it is greater, <STRONG>in a binary/ordinal sense</STRONG>. Of course this is an ordering that will be unsatisfying to any typical user, and I would suspect most of the atypical ones. 
<LI><A href="http://msdn.microsoft.com/library/en-us/kmarch/hh/kmarch/k109_59d7c507-968a-4cf5-b1f0-91c8cd7ccb64.xml.asp">RtlEqualUnicodeString</A>&nbsp;has an even simpler job -- take two strings and return TRUE if they are equal and FALSE if they are not, <STRONG>in a binary/ordinal sense</STRONG>.</FONT></LI></UL>
<P><FONT face=Tahoma>Now asking a candidate to write the ideal implementations for each of these functions and then with both of them on the board going through the expected differences in performance between them could make for a mildly interesting Microsoft interview question. But beyond that, the difference is not all that&nbsp;significant (in that post last week I hinted at this and the fastest underlying implementations when I mentioned that "<EM>the difference of two numbers not being zero</EM>" and "<EM>two numbers not being equal</EM>" was really not going to be all that significant).</FONT></P>
<P><FONT face=Tahoma>The key issue here is that&nbsp;these functions are&nbsp;looking through the two strings. As soon as&nbsp;they note&nbsp;any difference of any kind, they can return the result. Period.</FONT></P>
<P><FONT face=Tahoma>The world of the less lexicographic and more linguistic&nbsp;<A href="http://msdn.microsoft.com/library/en-us/winui/winui/windowsuserinterface/resources/strings/stringreference/stringfunctions/comparestring.asp">CompareString</A>&nbsp;and&nbsp;mythical&nbsp;<STRONG>EqualString</STRONG> functions is a very different one. </FONT><FONT face=Tahoma>Because in this world those linguistic weight tables are used.</FONT></P>
<P><FONT face=Tahoma>This is hardest on <A href="http://msdn.microsoft.com/library/en-us/winui/winui/windowsuserinterface/resources/strings/stringreference/stringfunctions/comparestring.asp">CompareString</A>&nbsp;where with those weights there are so many different levels of difference, with some levels trumping other levels. Therefore, any</FONT><FONT face=Tahoma> difference between the two strings is an interesting bit of trivia <EM>unless</EM> no greater difference is found later on. Those lower levels include all of the potentially ignorable distinctions in e.g. case, diacritic, width, or kana. </FONT><FONT face=Tahoma>Unless a Unicode weight difference is found (which lets <A href="http://msdn.microsoft.com/library/en-us/winui/winui/windowsuserinterface/resources/strings/stringreference/stringfunctions/comparestring.asp">CompareString</A>&nbsp;return more quickly), it will have to enumerate the full strings, storing up those lesser differences in case it needs them.</FONT></P>
<P><FONT face=Tahoma>And this is where the fictional <STRONG>EqualString</STRONG> function would have it easier -- because like its binary/ordinal cousins it would be able to return after any difference is found, of any weight. This is (potentially)&nbsp;hugely faster&nbsp;for so many of the potential strings that <A href="http://msdn.microsoft.com/library/en-us/winui/winui/windowsuserinterface/resources/strings/stringreference/stringfunctions/comparestring.asp">CompareString</A>&nbsp;has to test for.</FONT></P>
<P><FONT face=Tahoma>This should answer the first question (why the performance difference is so... well... <EM>different</EM>).</FONT></P>
<P><FONT face=Tahoma>The second question (<EM>if</EM> the Rtl* difference is so near to inconsequential yet <EM>they</EM> get the two functions why the NLS side of the world would not get two functions if the performance difference is so bleeding consequential) is a bit more complicated.</FONT></P>
<P><FONT face=Tahoma>There would be essentially two good reasons to&nbsp;consider adding such a function to a future version of Windows:</FONT></P>
<UL>
<LI><FONT face=Tahoma>The need to have separate comparison/sorting operations to provide appropriate linguistic support;</FONT> 
<LI><FONT face=Tahoma>The need to have such an absolute linguistic equality operation done frequently enough that the perfomance difference would be significant in implementations.</FONT></LI></UL>
<P><FONT face=Tahoma>The linguistic support argument is a tough one for two reasons:</FONT></P>
<UL>
<LI><FONT face=Tahoma>Existing implementations will by now be depending on the fact that we combine the operations of comparison and sorting, so we could not remove one functionality without breaking callers.</FONT> 
<LI><FONT face=Tahoma>In most cases, there really is no difference that would confuse anybody -- in fact to date I do not know of any complaint beyond the ones that I directly inspired by pointing out the differences&nbsp;to native speakers of particular languages either to directly answer the question or&nbsp;<STRONG>in this blog</STRONG>! This suggests that the difference is more theoretical in the real world of what people would be sorting/comparing on computers.</FONT></LI></UL>
<P><FONT face=Tahoma>The performace question is harder to discount, although it significant to note that good implementations that are building indexes would be using the <A href="http://msdn.microsoft.com/library/en-us/intl/nls_5s2v.asp">LCMapString</A> function with LCMAP_SORTKEY flag to build sort keys. Obviously such sort keys are numbers already and allow both comparisons and sorts to be done even more quickly than the imaginary <STRONG>EqualString</STRONG> function could do its work. And it is hard to argue that "Microsoft must add something fast" if the person asking is actually not&nbsp;using something faster already....</FONT></P>
<P><FONT face=Tahoma>In fact, sort keys bring the linguistic comparison down to the level of the binary/ordinal world where <A href="http://msdn.microsoft.com/library/en-us/kmarch/hh/kmarch/k109_ddeef320-7510-446b-af6f-756c3999bec1.xml.asp">RtlCompareUnicodeString</A> and <A href="http://msdn.microsoft.com/library/en-us/kmarch/hh/kmarch/k109_59d7c507-968a-4cf5-b1f0-91c8cd7ccb64.xml.asp">RtlEqualUnicodeString</A>&nbsp;do their work. And in using sort keys the difference between the two different oprerations of comparison and sorting&nbsp;is on the same order of magnitude as between the binary/ordinal functions!</FONT></P>
<P><FONT face=Tahoma>The other problem is that in the small number of scenarios where sort keys are not a practical solution, a linguistic comparison is not appriopriate (e.g. filenames and other symbolic identifiers). That would mean that converting the unreal <STRONG>EqualString</STRONG> into a real NLS API would actually encourage bad usage and bad development practice!</FONT></P>
<P><FONT face=Tahoma><EM>(I will talk more about this issue with symbolic identifiers another day, and also it will cone up in an upcoming presentation at the <A href="http://www.unicodeconference.org/conference-at-a-glance.htm">Internationalization &amp; Unicode Conference on March 6-8</A> entitled '<A href="http://www.unicodeconference.org/program-d.htm#Kaplan_S9">Tales of Incorrect String Comparisons</A>'.)</EM></FONT></P>
<P><FONT face=Tahoma>It may be of interest to some that the new in Vista <a href="http://archives.miloush.net/michkap/archive/2005/07/31/445819.html">FindNLSString</A> function probably has&nbsp;more in common with the fairy-tale <STRONG>EqualString</STRONG> than it&nbsp;does with&nbsp;<A href="http://msdn.microsoft.com/library/en-us/winui/winui/windowsuserinterface/resources/strings/stringreference/stringfunctions/comparestring.asp">CompareString</A>&nbsp;since it too&nbsp;pays no attention to&nbsp;non-ignored differences other than to keep looking for the substring. However, the fact that <a href="http://archives.miloush.net/michkap/archive/2005/07/31/445819.html">FindNLSString</A>&nbsp;is&nbsp;also looking for the location within the substring causes it to be slower to answer a different question; the mythological <STRONG>EqualString</STRONG> function would still be faster.</FONT></P>
<P><FONT face=Tahoma><EM>(I will talk more about this issue with the comparison and contrast of </EM><a href="http://archives.miloush.net/michkap/archive/2005/07/31/445819.html"><EM>FindNLSString</EM></A><EM>, </EM><A href="http://msdn.microsoft.com/library/en-us/winui/winui/windowsuserinterface/resources/strings/stringreference/stringfunctions/comparestring.asp"><EM>CompareString</EM></A><EM>, and </EM><A href="http://msdn.microsoft.com/library/en-us/intl/nls_5s2v.asp"><EM>LCMapString</EM></A><EM> with LCMAP_SORTKEY flag another day!)</EM></FONT></P>
<P><FONT face=Tahoma>But <A href="http://dictionary.reference.com/search?q=Irregardless">irregardless</A> of whether&nbsp;it had been able to justify its future inclusion, the arguments for and against&nbsp;the invented<SUP><FONT size=1>1</FONT></SUP> <STRONG>EqualString</STRONG>&nbsp;are certainly worthy of&nbsp;a blog post!</FONT></P>
<P><FONT face=Tahoma></FONT>&nbsp;</P>
<P><FONT face=Tahoma size=1><EM>1 - Special thanks to the Microsoft Word 2003 Thesaurus for its support here in finding appropriate words to use for the unreal EqualString function!</EM></FONT></P>
<P><FONT face=Tahoma color=#ff1493><EM>This post brought to you by</EM> "<FONT size=6>ß</FONT>" <EM>(<A href="http://www.fileformat.info/info/unicode/char/00df">U+00df</A>, a.k.a. LATIN SMALL LETTER SHARP S)<BR><FONT size=1>(A letter that was overheard in the character locker room after reviewing this post muttering "Curses! Folied again...")</FONT></EM></FONT></P>
<hr/><p><a id="495709" href="#495709">#</a> <strong>David</strong> on Tuesday, November 22, 2005 8:34 AM:</p><div style="margin-left: 1em">Just had to tweak me, didn't you :P. I'm pondering whether use of &quot;irregardless&quot; qualifies for the 6th circle (Heretics) or the 8th circle (Sowers of Discord/Scandal/Schism).</div>
<p><a id="495750" href="#495750">#</a> <strong>Stuart Ballard</strong> on Tuesday, November 22, 2005 10:24 AM:</p><div style="margin-left: 1em">This actually seems like a good place to post something I've wanted to ask your advice about for a while.<br><br>See, reading your blog has convinced me that perhaps collation is something I ought to care about and make sure I get right (until recently I basically ignored the issue).<br><br>Background: I work on a C# web application using SQL server through an ORM tool I wrote myself. I care enough to do some once-off work to get this right but not to have to put in extra effort at every DB call or string-equality check, and the other programmers at my company will probably not care at all - issues that apply to Turkish are hard to sell when we barely need to localize for &quot;outside the tristate area&quot;. So I'd like to do something at the ORM or SQL server layer to arrange that the right collation is just used automatically and C# programmers don't need to think about it.<br><br>As far as I can tell SQL server uses case-insensitive English collation rules by default; C# uses ordinal equality. This difference by itself is enough to have introduced bugs on occasion (it's terribly tempting to assume when you get an object &quot;where somefield = @x&quot;, obj.SomeField == x will evaluate to true afterwards) but it gets worse.<br><br>It seems to me that there are three different operations which need different collation rules. Equality testing wants to be ordinal to match what a C# programmer expects (a C# programmer is already used to explicitly uppercasing or lowercasing if they want case-insensitive equality). Sorting (&quot;order by&quot;) is probably for presentation to the user and should use the current culture (English) and probably be case-insensitive, or at least, words that differ by case should sort together. And searching (&quot;foo like '%' + @str + '%'&quot;) should definitely use the current culture but case-sensitivity is an open question; it's probably okay to expect the user to do some work like  uppercasing or lowercasing the string so the case-sensitivity is explicit, but being case-insensitive might be okay too.<br><br>(See, this *is* relevant to your post! Equals versus Compare versus Find...)<br><br>The problem is that it's perfectly reasonable to expect that all these things might happen in the same query! &quot;select from whatever where category_identifier = @cat and name like '%' + @search '%' order by name&quot;<br><br>Is it possible in any way whatsoever to persuade SQL server that equality comparisons should use ordinal equality but like and orderby should be culture-based?</div>
<p><a id="495809" href="#495809">#</a> <strong>orcmid</strong> on Tuesday, November 22, 2005 12:09 PM:</p><div style="margin-left: 1em">Now you got me thinking and that's always a bad idea.<br><br>It strikes me that for mythEqualString to work, one can always consider that there are canonical strings (since we're looking at equivalence classes).  And context is important, so wanting to know mythCanonicalString is locale-, usage-, and immediate-context- and whatever-else-dependent.  Framing the question as one of arriving at canonical forms for equal strings seems like a good way to illuminate the problem and characterize cases.<br><br>One could *specify* mythEqualString in terms of CanonicalString (and of course really do speed-ups and short-circuits in the [cached] implementations).<br><br>I suppose mythCanonicalString *might* also be suitable for specification mythCompareString too , but maybe not.  (Because mythCanonicalString is idempotent, it is specifiable as a test of whether a string is already canonical too.)<br><br>But most of all, this suggests to me a very good way to characterize all of the difficulties of multiple forms for character encoding, of the impact of context, and the problems of treating or passing around material either decontextualized or from clashing contexts. <br><br>My view is that in general, context is always externally and situationally determined, and the difficulty of handling texts procedurally is thereby exposed more clearly too by looking at canonicalization as context-specific.<br><br>So, your mythical comparisons strike me as extremely valuable in narrating the difficulties of text-string comparisons, and illustrating the kinds of differences that arise as one takes on the mythical challenge.<br><br>Sounds too easy.  Has this already been done for Unicode cases?  Does it break down?  I'm curious (but not enough to pay the freight to the next Unicode conference).</div>
<p><a id="496001" href="#496001">#</a> <strong>Maurits</strong> on Tuesday, November 22, 2005 5:55 PM:</p><div style="margin-left: 1em">OK, why is there no EqualString function?</div>
<p><a id="496023" href="#496023">#</a> <strong>Luke Amery</strong> on Tuesday, November 22, 2005 6:54 PM:</p><div style="margin-left: 1em">Stuart, (sorry to butt in Michael), I have been vaguely experimenting with what you are discussing. I have come across casting nvarchar / varchar strings in SQL Server to varbinary to achieve a binary/ordinal equality operation. The results have been what I have expected so far. Can anyone point out the error of my ways?</div>
<p><a id="496252" href="#496252">#</a> <strong>Michael S. Kaplan</strong> on Wednesday, November 23, 2005 10:24 AM:</p><div style="margin-left: 1em">Hi David -- it is in the dictionary, so it is a word. Not even a prescriptive grammarian can do more than say that I am just guilty of informal usage, but they could just read what I write and come to that conclusion anyway....<br><br>Hi Stuart -- I have posted several times about issues where SQL Server and the CLR do different things and those differences lead to problems, so clearly I agree with you. This would just be more examples of the same. Though I do not agree with all of the changes you are uggesting in regards to equality comparisons needing to be ordinal always -- that still ought to be an explicit decision, for both SQL and the CLR.<br><br>Hi Orcmid -- the problem is deciding when Unicode canonical equivalence should enter into equality determinations. Perhaps sometimes, but when? Maybe the answer is to check with the AD folks and similar customers and see if they would ever need that sort of thing (though usually they would just use sort keys anyway).<br><br>Hi Maurits -- not sure how I convinced you, since a lot of the article explains why it may be a bad idea? :-)<br><br>Hi Luke -- you can also use *_BIN or *_BIN2 collations rather than casting to do that sort of comparison. The questions about SQL vs. CLR and their behavior differences are still there....</div>
<p><a id="496279" href="#496279">#</a> <strong>Maurits</strong> on Wednesday, November 23, 2005 11:14 AM:</p><div style="margin-left: 1em">I found your &quot;arguments in favor of&quot; more convincing than your &quot;arguments against&quot;.<br><br>If a developer wants an EqualString, it's trivial to make one:<br><br>boolean EqualString(string a, string b, ...)<br>{<br>  return CompareString(a, b, ...) == 0;<br>}<br><br>so you're not protecting anybody by leaving it out.</div>
<p><a id="496294" href="#496294">#</a> <strong>Stuart Ballard</strong> on Wednesday, November 23, 2005 11:36 AM:</p><div style="margin-left: 1em">Michael, thanks for the responses.<br><br>&quot;Though I do not agree with all of the changes you are [s]uggesting in regards to equality comparisons needing to be ordinal always -- that still ought to be an explicit decision, for both SQL and the CLR.&quot;<br><br>I'm not so much suggesting they should be ordinal always. What I'm doing rather is recognizing the reality that 99% of the time people - including me, and even more so the other developers in my company - aren't going to even *think* about what collation should be used, and there's pretty much nothing I can do about that. Okay, I could make every single get function take a required &quot;collation&quot; parameter for every existing string parameter, but I think the other developers might rebel against that idea :)<br><br>I'm not trying to take away the ability to make an explicit decision if you want to, I'm just trying to make the case where you didn't think about it *at all* do what you expected. C# does that - when I do &quot;==&quot; on strings without thinking about it, it just works.<br><br>&quot;you can also use *_BIN or *_BIN2 collations rather than casting to do that sort of comparison. The questions about SQL vs. CLR and their behavior differences are still there....&quot;<br><br>How would you use the collations to get this query to do what I want it to do? &quot;select from whatever where category_identifier = @cat and name like '%' + @search '%' order by name&quot;<br><br>That is, the equality check should be ordinal but the like and the order by should be cultural. Is there a way to specify different collations for different clauses of the expression? And doesn't that impact whether relevant indexes will get hit or not?<br><br>As far as EqualsString, I agree with others who think there should be one. As far as I can see your performance argument relies on this:<br><br>&quot;And it is hard to argue that &quot;Microsoft must add something fast&quot; if the person asking is actually not using something faster already....&quot;<br><br>But creating sort keys for both strings and comparing them *isn't* necessarily faster, for all workloads. It only works if the same set of strings is going to be reused for many comparisons; the cost of creating a sort key by itself is greater than the cost of CompareString!<br><br>As far as I'm concerned, though, the compelling reason to have an EqualsString method is more to do with API-friendliness. Which chunk of code is easier to read and conveys the intention better?<br><br>if (EqualsString(str1, str2) &amp;&amp;<br>    !EqualsString(str2, str3)) {...}<br><br>or<br><br>if (CompareString(str1, str2) == 0 &amp;&amp;<br>    CompareString(str1, str2) != 0) {<br>}<br><br>(obviously I'm not a C++ programmer and I'm sure those functions actually take more parameters, even the mythical ones, but the point still holds).<br><br>I'm a strong believer in the idea that code should read like what it does. When what it does is test equality, that's what it should say.</div>
<p><a id="496301" href="#496301">#</a> <strong>Michael S. Kaplan</strong> on Wednesday, November 23, 2005 11:46 AM:</p><div style="margin-left: 1em">Hi Maurits!<br><br>&quot;return CompareString(a, b, ...) == 0;&quot;<br><br>Hopefully you meant:<br><br>return CompareString(a, b, ...) == CSTR_EQUAL; <br><br>there? :-)<br><br>The protection comes from not encouraging an unsustainable design pattern....<br><br>I am not 100% convinced it is bad, just looking for scenarios when it would be correct to convinced that it belongs on a list of things to do in the future.</div>
<p><a id="496303" href="#496303">#</a> <strong>Michael S. Kaplan</strong> on Wednesday, November 23, 2005 11:51 AM:</p><div style="margin-left: 1em">Tyhe real problem, Stuart, is understanding when an equality test is important to do -- and when it should acually be an ordinal/binary operation rather than a linguistic one.<br><br>My main concern is that you cannot just add a function to the NLS API set just because it would be cool -- there must be a reason, a valid scenario. Just about all of the cases I have seen, they should have been doing binary comparisons, not lingistic ones. I am still looking for the compelling scenario....</div>
<p><a id="496336" href="#496336">#</a> <strong>Maurits</strong> on Wednesday, November 23, 2005 12:29 PM:</p><div style="margin-left: 1em">&gt; return CompareString(a, b, ...) == CSTR_EQUAL;<br><br>You've got to be kidding.<br><br>OK, my bad for not reading the documentation.  (This is Mom told me to always check my code...)<br><br>(/me reads <a rel="nofollow" target="_new" href="http://tinyurl.com/t4k4">http://tinyurl.com/t4k4</a> )<br><br>Hmm, the return values are missing. :O<br><br>(/me reads <a rel="nofollow" target="_new" href="http://tinyurl.com/8qljr">http://tinyurl.com/8qljr</a> )<br><br>OK, now the return values are there, but as literal 1, 2, and 3, no CSTR_EQUAL. :&amp;<br><br>(/me searches for CSTR_EQUAL)<br><br>Ah, here we go: <a rel="nofollow" target="_new" href="http://tinyurl.com/djoev">http://tinyurl.com/djoev</a><br><br>Yes, I guess I did mean == CSTR_EQUAL there.  Although I might want to check for 0 first to call GetLastError() somehow.</div>
<p><a id="496340" href="#496340">#</a> <strong>Stuart Ballard</strong> on Wednesday, November 23, 2005 12:44 PM:</p><div style="margin-left: 1em">I think I'm missing something in your line of argument.<br><br>On the one hand &quot;Just about all of the cases I have seen, they should have been doing binary comparisons, not lingistic ones.&quot;; on the other &quot;I do not agree with all of the changes you are [s]uggesting in regards to equality comparisons needing to be ordinal always -- that still ought to be an explicit decision&quot;.<br><br>Are you saying that the answer is almost always ordinal but people should still *think* about the question of what collation to use before doing any string comparison or equality test?<br><br>If that is what your saying, I agree that in an ideal world it would be great, but I can't see it happening in practice most of the time :(</div>
<p><a id="496356" href="#496356">#</a> <strong>Michael S. Kaplan</strong> on Wednesday, November 23, 2005 1:04 PM:</p><div style="margin-left: 1em">Hi Stuart,<br><br>I guess I'm saying that adding the function would make it too easy for linguistic comparisons to be done when they should not be -- so maybe adding it would be a bad idea.<br><br>But the behavior of comparisons/equality checking cnnot be changed  once it is implemented as that wozuld break all existing clints.<br><br>Perhaps an EqualStringOrdinal function is needed here. :-)</div>
<p><a id="496434" href="#496434">#</a> <strong>Maurits</strong> on Wednesday, November 23, 2005 3:36 PM:</p><div style="margin-left: 1em">Did you see that the fileformat.info page links back to your blog?<br><br><a rel="nofollow" target="_new" href="http://www.fileformat.info/info/unicode/char/00df/index.htm">http://www.fileformat.info/info/unicode/char/00df/index.htm</a></div>
<p><a id="496439" href="#496439">#</a> <strong>Michael S. Kaplan</strong> on Wednesday, November 23, 2005 3:58 PM:</p><div style="margin-left: 1em">Cool!<br><br>Of course it would have made more sense to point it out on the following page:<br><br><a rel="nofollow" target="_new" href="http://archives.miloush.net/michkap/archive/2005/09/25/473632.html">http://blogs.msdn.com/michkap/473632.aspx</a><br><br>than this one. :-)</div>
<p><a id="496510" href="#496510">#</a> <strong>Dean Harding</strong> on Wednesday, November 23, 2005 7:07 PM:</p><div style="margin-left: 1em">@Stuart<br><br>I believe Michael has described something like this before, but I can't find the original post.  Anyway, you can use computed columns to use different collation rules for the same data. And because you can index computed columns (at least, you can index deterministic ones) then you can still do it in such a way that indexes are used correctly. The only thing would be the extra storage required for two indexes over the same column (though you couldn't really expect anything else).<br><br>Here's some example T-SQL to show you what I mean:<br><br>CREATE TABLE [coll_test]<br>(<br>  [text_column] NVARCHAR(100) COLLATE Latin1_General_CI_AS,<br>  [text_column_BIN] AS [text_column] COLLATE Latin1_General_BIN<br>)<br><br>CREATE INDEX IX_text_column ON [coll_test] ([text_column])<br>CREATE INDEX IX_text_column_BIN ON [coll_test] ([text_column_BIN])<br><br>Then you could write your query as:<br><br>SELECT * FROM [coll_test] WHERE [text_column_BIN] = 'whatever' OR [text_column] LIKE '%search%' ORDER BY [text_column]<br><br>Of course, it's a bit more work to get right, but it could be contained completely within your ORM code. Also, as Michael has pointed out before, SQL Server locale-sensitive collations are still different to CLR locale-sensitive collations, so there may be more issues still.</div>
<p><a id="496515" href="#496515">#</a> <strong>Michael S. Kaplan</strong> on Wednesday, November 23, 2005 7:22 PM:</p><div style="margin-left: 1em">I posted on the method Dean is referring to here:<br><br><a rel="nofollow" target="_new" href="http://archives.miloush.net/michkap/archive/2005/05/06/415199.html">http://blogs.msdn.com/michkap/415199.aspx</a></div>
<hr/><p><em>referenced by</em></p><div style="margin-left: 1em"><p>2008/02/23 <a href="http://archives.miloush.net/michkap/archive/2008/02/23/7850221.html">The triage process gives me hives</a></p><p>2006/05/24 <a href="http://archives.miloush.net/michkap/archive/2006/05/24/605599.html">Invariant vs. Ordinal, the third</a></p><p>2006/04/29 <a href="http://archives.miloush.net/michkap/archive/2006/04/29/586726.html">'Which comes first?' vs. 'Are they equal?'</a></p><p>2006/03/05 <a href="http://archives.miloush.net/michkap/archive/2006/03/05/544133.html">Will I C U at the IUC?</a></p><p>2006/02/09 <a href="http://archives.miloush.net/michkap/archive/2006/02/09/528297.html">Is RtlCompareUnicodeString used correctly?</a></p></div><p><em>go to <a id="newer" href="http://archives.miloush.net/michkap/archive/2005/11/23/495193.html" title="100% roundtrip ASCII? 100% roundtrip ANSI?">newer</a> or <a id="older" href="http://archives.miloush.net/michkap/archive/2005/11/21/495389.html" title="29th Internationalization and Unicode Conference">older</a> post, or back to <a href="http://archives.miloush.net/michkap/archive/index.html">index</a> or <a href="http://archives.miloush.net/michkap/archive/index.html#2005-11">month</a> or <a href="http://archives.miloush.net/michkap/archive/index.html#2005-11-22">day</a></em></p></body>
<!-- Mirrored from archives.miloush.net/michkap/archive/2005/11/22/495033.html by HTTrack Website Copier/3.x [XR&CO'2014], Thu, 25 May 2017 00:42:40 GMT -->
</html>