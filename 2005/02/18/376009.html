<html>
<!-- Mirrored from archives.miloush.net/michkap/archive/2005/02/18/376009.html by HTTrack Website Copier/3.x [XR&CO'2014], Thu, 25 May 2017 00:42:42 GMT -->
<head><meta charset="utf-8" /><meta name="viewport" content="width=device-width" /><title>GetHashCode vs. Compare vs. SortKey</title></head><body>
<h1>GetHashCode vs. Compare vs. SortKey</h1>
<p><em>by Michael S. Kaplan, published on 2005/02/18 05:36 -05:00, original URI: http://blogs.msdn.com/b/michkap/archive/2005/02/18/376009.aspx</em></p>
<hr/> <!-- Archival Source: ProcessPostNew -->
<P>On a regular basis, someone asks the question about what is faster here of the three methods of comparing two strings (this is the latest of them, asked just yesterday):</P>
<BLOCKQUOTE dir=ltr>
<P class=MsoNormal><FONT face=Arial color=navy size=2><SPAN><EM>I’m trying to find out if the gethashcode() method provided with the framework guarantees uniqueness. From as far as I know, It won’t guarantee uniqueness in all cases but it will in the case of strings because the gethascode() method was already overwritten in the string class. </EM></SPAN></FONT></P>
<P class=MsoNormal><FONT face=Arial color=navy size=2><SPAN><EM>Does this mean I can always use:</EM></SPAN></FONT></P>
<BLOCKQUOTE dir=ltr>
<P class=MsoNormal><FONT face=Arial color=navy size=2><SPAN><EM>Somestring.gethashcode() </EM></SPAN></FONT></P></BLOCKQUOTE>
<P class=MsoNormal><FONT face=Arial color=navy size=2><SPAN><EM>to compare two strings since string compares are so expansive?</EM></SPAN></FONT></P></BLOCKQUOTE>
<P>Now this is not at all a dumb question, and is in fact one of the smarter ways of framing it (I'll let you, the reader, imagine some of the&nbsp;dumb ways one <EM>could</EM> make such an inquiry -- I have some doozies in my archives!).</P>
<P>Some people take the technical road on answering this question. They note that a string can be 2gb long&nbsp;and a hash code is a single 32-bit number -- so of course it cannot uniquely represent all numbers. They then proceed to calculate the collision probability. But their prob &amp; stats memory is clearly less rusty than mine (or maybe they just enjoyed it more than I did), so I will stick to what I can remember well and not try to calculate odds on the chances of a duplicate here....</P>
<P>There are only two built-in ways of creating a hash code in Whidbey that will return results that have any kind of culturally correct meaning (and there are none prior to Whidbey<FONT size=1><SUP>1</SUP></FONT>):</P>
<OL>
<LI>Use the static StringComparer.Create override that takes a <A title=CultureInfo href="http://msdn.microsoft.com/library/en-us/cpref/html/frlrfsystemglobalizationcultureinfoclasstopic.asp" target=_blank>CultureInfo</A> (or&nbsp;choose the appropriate one to use the <A title=CurrentCulture href="http://msdn.microsoft.com/library/en-us/cpref/html/frlrfsystemglobalizationcultureinfoclasscurrentculturetopic.asp" target=_blank>CurrentCulture</A> or <A title=InvariantCulture href="http://msdn.microsoft.com/library/en-us/cpref/html/frlrfsystemglobalizationcultureinfoclassinvariantculturetopic.asp" target=_blank>InvariantCulture</A>), and call the GetHashCode override that takes a string. 
<LI>Use <A title=CompareInfo href="http://msdn.microsoft.com/library/en-us/cpref/html/frlrfsystemglobalizationcompareinfoclasstopic.asp" target=_blank>CompareInfo</A>.GetSortKey to create a sort key and then call GetHashCode on <EM>it</EM>.</LI></OL>
<P>From&nbsp;a performance standpoint, #2 seems like it would be more expensive (it is, but not for the reasons you might think). But they both do use the same technique of getting the sort key and calculating a deterministic hash on <STRONG>that</STRONG>. </P>
<P>They both have to run over the entire string to get the sort key and then the entire sort key to build the hash code. Now contrast that with the Compare() case which looks at two strings and returns as soon as it possibly can tell which comes first. The only time it will run over the entire string is if the two strings are almost identical, like</P>
<BLOCKQUOTE dir=ltr>
<P>abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyZ</P></BLOCKQUOTE>
<P>vs.</P>
<BLOCKQUOTE dir=ltr>
<P>abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyz</P></BLOCKQUOTE>
<P>or something. In the real world situation of&nbsp;comparing two strings, only testers of comparison methods will find themselves with a large number of such strings, and that is after they specially construct them!</P>
<P><EM>(The fact that more often people test comparisons by comparing "AAA" to "BBB" shows that they do not understand how comparisons work -- such string comparisons are incredibly fast since one finds the difference in the very first character!)</EM></P>
<P>So, lets look at the three methods, and with our new knowledge of the relative speed of each, judge the performance of each (assumes a random distribution of strings, rather than strings constructed to prove me wrong!):</P>
<OL>
<LI>Using Compare on the two strings directly; 
<LI>Creating sort keys for the two strings and comparing the sort keys; 
<LI>Creating hash codes for the two strings and comparing the hash codes, then when they are equal falling back on #1 or #2 to break the tie.</LI></OL>
<P>If one is doing many comparisons (like in a database) then it does not take very long for #2 to start getting better than #1 -- after all, Compare is only assured to be faster for an individual string comparison. If you are regularly doing comparisons then building an index based on sort key makes a whole lot of sense (and this is precisely how database indexes are built!).</P>
<P>One more note on the hash codes (if you still think it might make sense to cache that&nbsp;System.Int32 value for a great "first pass" on the string)....</P>
<P>There is no meaning that can be derived from one hash code being greater than or less than another -- it certainly does not suggest which string would sort first in a list. The only meaningful comparison of hash codes you can make is whether they are equal (in which case you must use another method to find out the order).</P>
<P><EM><FONT size=1><BR>1 - If there is any interest, I can perhaps give an example about creating such a hash code algorithm another day.<BR></FONT></EM></P>
<P><FONT color=#800080><EM>This post brought to you by</EM> "ۍ" <EM>(<A href="http://www.fileformat.info/info/unicode/char/06cd/index.htm">U+06cd</A>, a.k.a. ARABIC LETTER YEH WITH TAIL)</EM></FONT></P>
<hr/><p><a id="376018" href="#376018">#</a> <strong>KJK::Hyperion</strong> on 18 Feb 2005 4:08 AM:</p><div style="margin-left: 1em">Don't forget strings are immutable: they can be interned (i.e. added to the global pool) safely so that an identity test is a mere pointer comparison (IIRC this is true for OLE BSTRings too). The C# compiler, AFAIK, automatically interns all strings constructed from string literals</div>
<p><a id="376026" href="#376026">#</a> <strong>Michael Kaplan</strong> on 18 Feb 2005 4:20 AM:</p><div style="margin-left: 1em">Yes, this is very true. But the number of actual dupliates is probably pretty small, even as compared to strings that would be &quot;duplicates&quot; by collation criteria (different normalized form, different case in a case insensitive situation, etc.). <br><br>Plus I don't think the Compare code is really checking this case, which means it has to walk the whole string to find differences -- meaning it will be the slowest possible comparison? :-)</div>
<p><a id="376076" href="#376076">#</a> <strong>Tim Smith</strong> on 18 Feb 2005 6:53 AM:</p><div style="margin-left: 1em">This reminds me of some code I once saw.<br><br>if (strncmp (pKey -&gt;szName, szTest, 16) == 0 &amp;&amp; pKey -&gt;ulHash = ulTestHash)<br><br><br>:O</div>
<p><a id="376174" href="#376174">#</a> <strong>Michael Kaplan</strong> on 18 Feb 2005 9:25 AM:</p><div style="margin-left: 1em">Heh heh heh -- that code is *really* silly, especially given the binary nature or strncmp. :-)<br><br>I won't claim that the &quot;hash code&quot; test prior to using a sort key would be my first choice, but I guess there are times it would make sense. And the bulk of the expense would be in record insertion, not at lookup time, which could be argued well in many cases.</div>
<p><a id="376247" href="#376247">#</a> <strong>AC</strong> on 18 Feb 2005 11:45 AM:</p><div style="margin-left: 1em">You don't like probability and statistics? What were the odds?</div>
<p><a id="376273" href="#376273">#</a> <strong>Tim Smith</strong> on 18 Feb 2005 12:31 PM:</p><div style="margin-left: 1em">The application in question was lookup heavy and didn't care about sorting.<br><br>Doh, and I just noticed my example is missing a '='.  LOL.  Classic C/C++ typo.  Warnings must be turned off on the MB. *geek joke*</div>
<p><a id="381192" href="#381192">#</a> <strong>Michael Kaplan</strong> on 27 Feb 2005 5:42 AM:</p><div style="margin-left: 1em">Someone pointed out to me that the String intern stuff only is done on Equals(), not on Compare(), which explains why I was not seeing that particular optimization in comparisons....</div>
<p><strong>Alexander Savin</strong> on 1 Dec 2011 4:59 PM:</p><div style="margin-left: 1em"><p>Michael, with respect to your comment &quot;The fact that more often people test comparisons by comparing &quot;AAA&quot; to &quot;BBB&quot; shows ...&quot; I would say quite the opposite. It is much more important that a comparison function returns as fast as possible if two input strings mismatch not too far from the beginning because most comparisons in the world compare such unequal strings.</p>
<p>I have no alternative to CompareString but I was able to test performance of CompareStringOrdinal (with IgnoreCase = false) vs. wcscmp that I believe behave the same (binary comparison).</p>
<p>For strings having identical prefix not less than 20-30 characters CompareStringOrdinal beats wcscmp. For longer prefix (&gt;100) it is twice as fast (on my i7 machine) if I pass string lengths instead of -1. (Amazingly, the documentation states that CompareString is optimized for the case of cch == -1 and some other restrictions, but no word it is not the case for CompareStringOrdinal.) However, if two strings differ in the very first character or have a short equal prefix CompareStringOrdinal is up to 3 times slower than wcscmp.</p>
<p>I know wcscmp is just a straight loop (even if intrinsic) and CompareStringOrdinal seems to have a &quot;preparation preamble&quot; and manual loop unrolling. I wonder why CompareStringOrdinal is optimized for non-typical case. I understand there still are some cases where CompareStringOrdinal would be beneficial (like sorting path names for the files located in the same deep directory).</p>
</div>
<hr/><p><em>referenced by</em></p><div style="margin-left: 1em"><p>2011/12/06 <a href="http://archives.miloush.net/michkap/archive/2011/12/06/10244626.html">CompareString != CompareStringOrdinal. Even if we want it to be.</a></p></div><p><em>go to <a id="newer" href="http://archives.miloush.net/michkap/archive/2005/02/18/376225.html" title="Ready... set... Reboot!">newer</a> or <a id="older" href="http://archives.miloush.net/michkap/archive/2005/02/17/375235.html" title="LOCALE_SABBREVLANGNAME is so &lt;em>not&lt;/em> an ISO-639 code">older</a> post, or back to <a href="http://archives.miloush.net/michkap/archive/index.html">index</a> or <a href="http://archives.miloush.net/michkap/archive/index.html#2005-02">month</a> or <a href="http://archives.miloush.net/michkap/archive/index.html#2005-02-18">day</a></em></p></body>
<!-- Mirrored from archives.miloush.net/michkap/archive/2005/02/18/376009.html by HTTrack Website Copier/3.x [XR&CO'2014], Thu, 25 May 2017 00:42:42 GMT -->
</html>