<html>
<!-- Mirrored from archives.miloush.net/michkap/archive/2005/03/14/395199.html by HTTrack Website Copier/3.x [XR&CO'2014], Thu, 25 May 2017 00:42:42 GMT -->
<head><meta charset="utf-8" /><meta name="viewport" content="width=device-width" /><title>You toucha my letters, IWordBreaker you face (or, Language-specific processing, #3)</title></head><body>
<h1>You toucha my letters, IWordBreaker you face (or, Language-specific processing, #3)</h1>
<p><em>by Michael S. Kaplan, published on 2005/03/14 08:22 -05:00, original URI: http://blogs.msdn.com/b/michkap/archive/2005/03/14/395199.aspx</em></p>
<hr/> <!-- Archival Source: ProcessPostNew -->
<P><EM><FONT size=2>Prior posts in this series:<BR>&nbsp;&nbsp; </FONT></EM><a href="http://archives.miloush.net/michkap/archive/2005/03/08/389360.html"><EM><FONT size=2>Before you find, or search, you have to *index* (or, Language-specific processing #0)</FONT></EM></A>&nbsp;<BR>&nbsp;&nbsp; </EM><a href="http://archives.miloush.net/michkap/archive/2005/03/08/389675.html"><EM><FONT size=2>I coffee, therefore IFilter (or, Language-specific processing #1)</FONT></EM></A>&nbsp;<BR>&nbsp; &nbsp;<a href="http://archives.miloush.net/michkap/archive/2005/03/13/394822.html"><EM><FONT size=2>IStemmer'ed the tide (or, Language-specific processing #2)</FONT></EM></A></P>
<P>Ok, I have talked a little bit about the <A title="IFilter interface" href="http://msdn.microsoft.com/library/en-us/indexsrv/html/ixrefint_9sfm.asp" target=_blank>IFilter interface</A> and the <A title="IStemmer interface" href="http://msdn.microsoft.com/library/en-us/indexsrv/html/ixrefint_4b76.asp" target=_blank>IStemmer interface</A>. I have also talked about the haunting words of premonition in Nadine Kano's book that referred to the IWordBreak interface.</P>
<P>I have been unable to find anyone who knows whether the name was changed or the text was inaccurate, not that it makes much of a difference. There was a guy I used to work with on the Access development team who would dig back into source logs (as far back Access 1.0 if that is what it took) just so he could explain who had introduced a bug. Fascination in the historical aspects of the development process is no more anti-social of a hobby than stamp collecting. If you know what I mean. :-)</P>
<P>Anyway....</P>
<P>The <A title="IWordBreaker interface" href="http://msdn.microsoft.com/library/en-us/indexsrv/html/ixrefint_93xu.asp" target=_blank>IWordBreaker interface</A>, in the words of docs:</P>
<BLOCKQUOTE><EM><FONT size=2>
<P>The <B>IWordBreaker</B> interface is a language-specific language resource component. The word breaker parses text and identifies individual words and phrases. The word breaker is used in background processes and must be optimized for both throughput and minimal use of resources.</P></FONT></EM></BLOCKQUOTE>
<P>The important method for our purposes is the <A title=BreakText href="http://msdn.microsoft.com/library/en-us/indexsrv/html/ixrefint_22no.asp" target=_blank>BreakText</A> method. It breaks text to identify words and phrases, information that it then provides in the form of <A title=WordSink href="http://msdn.microsoft.com/library/en-us/indexsrv/html/ixrefobj_55uz.asp" target=_blank>WordSink</A> and <A title=PhraseSink href="http://msdn.microsoft.com/library/en-us/indexsrv/html/ixrefobj_3asr.asp" target=_blank>PhraseSink</A> objects. As with the other methods, you can see how knowledge of a language can enable one to break the text in ways most likely to find good results. </P>
<P>The Platform SDK also has a great topic entitled <A href="http://msdn.microsoft.com/library/en-us/indexsrv/html/wbrscenario_54bp.asp">Implementing a Word Breaker</A>&nbsp;which among other things gives specific examples of what I am talking about in the text:</P>
<BLOCKQUOTE><EM><FONT size=2>
<P>The main function of the <B>BreakText</B> method is to process text continuously from the <A href="http://msdn.microsoft.com/library/en-us/indexsrv/html/ixrefint_13xh.asp">text source</A> until all the text is processed, or until the word breaker encounters an error. While in this data processing loop, the <B>BreakText</B> method calls parsing and utility methods that perform specific tasks for that process. For example, the German word breaker may handle compound words, whereas the French word breaker may process <A href="http://msdn.microsoft.com/library/en-us/indexsrv/html/wbrscenario_656b.asp">diacritics</A> or <A href="http://msdn.microsoft.com/library/en-us/indexsrv/html/wbrscenario_6l2r.asp">clitics</A>. The specific functions that the word breaker performs and the strategy that it employs in performing these tasks depend entirely on the requirements for that language.</P>
<P>When breaking text, word breakers identify "alternative" forms for words that may have multiple representations. No semantic relationship is implied between the generated words. In fact, the original word may not be included among the list of alternatives. The alternative forms are saved in the same position in the index as the original word to indicate that they are identical.</P>
<P>When a document is included in the index, each word is assigned an integer value that represents the <I>offset</I>, or the distance of the word from the beginning of a document. The relative distance between words in a query is compared against the offsets stored in the full-text index. The query "Where is Kyle's document" matches any document with "Where" at offset <I>n</I>, "is" at <I>n</I>+1, "Kyle's" at <I>n</I>+2, and "document" at <I>n</I>+3. "Where is Kyle's document filed in the data-base?" is represented as:</P>
<P>
<TABLE>

<TR>
<TD>Where</TD>
<TD>is</TD>
<TD>Kyle<BR>Kyle's</TD>
<TD>document</TD>
<TD>filed</TD>
<TD>in </TD>
<TD>the</TD>
<TD>database<BR>data base</TD></TR></TABLE><BR></P>
<P>In this example, the word breaker stores alternative forms for "Kyle" ("Kyle's") and "database" ("data base") in the index. The word breaker generates and stores alternative words during the index creation process under the following conditions: 
<UL>
<LI>If an alternative word is likely to appear as a single word in a query 
<LI>If a stemmer is not likely to derive the original word from the alternative </LI></UL>
<P>Generating alternative word forms increases the number of ways that queries represent and match a sentence: 
<OL>
<LI>Where is Kyle document filed in the database 
<LI>Where is Kyle's document filed in the database 
<LI>Where is Kyle document filed in the data base 
<LI>Where is Kyle's document filed in the data base </LI></OL></FONT></EM></BLOCKQUOTE>
<P>It then goes on actually explain how the WordSink and PhraseSink objects are used:</P>
<BLOCKQUOTE dir=ltr>
<P><FONT size=2><EM>Word breakers use the </EM></FONT><A href="http://msdn.microsoft.com/library/en-us/indexsrv/html/ixrefobj_55uz.asp"><B><FONT size=2><EM>WordSink</EM></FONT></B></A><FONT size=2><EM> and </EM></FONT><A href="http://msdn.microsoft.com/library/en-us/indexsrv/html/ixrefobj_3asr.asp"><B><FONT size=2><EM>PhraseSink</EM></FONT></B></A><FONT size=2><EM> objects to collect and store all words and phrases that they extract from text. A word breaker stores words in a form that is as close as possible to the original word form in the document. The <B>PhraseSink</B> stores phrases at query time. Phrases improve the relevance of query results because longer sequences of words are rarer and provide greater distinction than smaller phrases. When Indexing Service places a phrase in the <B>PhraseSink</B> at query time, it creates an instance of the word breaker to break the phrase into words. Indexing Service then evaluates the phrase by checking whether the words in the phrase occur adjacent to one another in the index. For example, if "ABCD" occurs in the index at positions x, x+1, x+2, and x+3, the phrase match will occur if any adjacent substring of "ABCD" is submitted in a query. This strategy is effective for character-based word breakers that split phrases and long words during index creation and that generate phrases during query time.</EM></FONT></P></BLOCKQUOTE>
<P>Phrases are interesting because they can veer into areaa that are both domain specific (think about common phrases that might be recognized, like "word breaker") and language specific (think about languages with words that are particles or have very little use as independent search terms but which may be incredibly useful in providing context for surrounding words). Also, the Wordsink and PhraseSink objects are interesting in that they let you add alternate word and phrases&nbsp;as they make sense. Thus if they search for 'Micro$oft' you can put in 'Microsoft' and such &lt;grin&gt;, and other more linguisticlaly sensible word and pharse substitutions.</P>
<P>Finally it moves into area that truly involve language issues, and anyone who is using Unisrribe will recognize the concepts, about the actual breaks:</P>
<BLOCKQUOTE dir=ltr>
<P><FONT size=2><EM>Breaks are the spaces between words. White space, punctuation, formatting, or just the nature of the language itself can cause breaks. There are four different types of breaks that Indexing Service uses: end of word (EOW), end of sentence (EOS), end of paragraph (EOP) and end of chapter (EOC). The EOW break is the default break. After each token, each break indicates a different semantic distance between the words on either side. Words separated by EOW have the tightest semantic link, followed by EOS, EOP, and EOC. Multiple calls to </EM></FONT><A href="http://msdn.microsoft.com/library/en-us/indexsrv/html/ixrefobj_71kb.asp"><B><FONT size=2><EM>PutBreak</EM></FONT></B></A><FONT size=2><EM> are cumulative, and are analogous to inserting null words or sentences.</EM></FONT></P></BLOCKQUOTE>
<P>It is unclear to me at this point how much of the information is truly leveraged and how much is there for potential future growth. But even if it is the latter I think it is a good direction to grow in, if you know what I mean.</P>
<P>Looking in the Platform SDK, there is the lrsample sample for Index Server -- basically it is the word breaker and stemmer sample&nbsp;described <A href="http://msdn.microsoft.com/library/en-us/indexsrv/html/wbrscenario_3e91.asp">here</A>. It has an interesting BreakText method in lrsample.CXX:</P>
<BLOCKQUOTE dir=ltr><FONT face="Courier New" size=1>
<P><FONT face="Courier New" size=1>//+---------------------------------------------------------------------------<BR>//<BR>//&nbsp; Member:&nbsp;&nbsp;&nbsp;&nbsp; CSampleWordBreaker::BreakText<BR>//<BR>//&nbsp; Synopsis:&nbsp;&nbsp; Break a block of text into individual words<BR>//<BR>//&nbsp; Arguments:&nbsp; [pTextSource]&nbsp; -- Source of characters to work on<BR>//&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; [pWordSink]&nbsp;&nbsp;&nbsp; -- Where to send the words found<BR>//&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; [pPhraseSink]&nbsp; -- Where to send the phrases found (not used)<BR>//<BR>//&nbsp; Returns:&nbsp;&nbsp;&nbsp; S_OK if successful or an error code<BR>//<BR>//----------------------------------------------------------------------------</FONT></P>
<P><FONT face="Courier New" size=1>HRESULT STDMETHODCALLTYPE CSampleWordBreaker::BreakText(<BR>&nbsp;&nbsp;&nbsp; TEXT_SOURCE * pTextSource,<BR>&nbsp;&nbsp;&nbsp; IWordSink *&nbsp;&nbsp; pWordSink,<BR>&nbsp;&nbsp;&nbsp; IPhraseSink * pPhraseSink )<BR>{<BR>&nbsp;&nbsp;&nbsp; // Validate arguments</FONT></P>
<P><FONT face="Courier New" size=1>&nbsp;&nbsp;&nbsp; if ( 0 == pTextSource )<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return E_INVALIDARG;</FONT></P>
<P><FONT face="Courier New" size=1>&nbsp;&nbsp;&nbsp; if ( ( 0 == pWordSink ) || ( pTextSource-&gt;iCur == pTextSource-&gt;iEnd ) )<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return S_OK;</FONT></P>
<P><FONT face="Courier New" size=1>&nbsp;&nbsp;&nbsp; if ( pTextSource-&gt;iCur &gt; pTextSource-&gt;iEnd )<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return E_INVALIDARG;</FONT></P>
<P><FONT face="Courier New" size=1>&nbsp;&nbsp;&nbsp; ULONG cwcProcessed;&nbsp;&nbsp; // # chars actually processed by Tokenize()<BR>&nbsp;&nbsp;&nbsp; HRESULT hr = S_OK;</FONT></P>
<P><FONT face="Courier New" size=1>&nbsp;&nbsp;&nbsp; // Pull text from the text source and tokenize it</FONT></P>
<P><FONT face="Courier New" size=1>&nbsp;&nbsp;&nbsp; do<BR>&nbsp;&nbsp;&nbsp; {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; BOOL fFirstTime = TRUE;</FONT></P>
<P><FONT face="Courier New" size=1>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; while ( pTextSource-&gt;iCur &lt; pTextSource-&gt;iEnd )<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ULONG cwc = pTextSource-&gt;iEnd - pTextSource-&gt;iCur;</FONT></P>
<P><FONT face="Courier New" size=1>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Process in buckets of cwcAtATime only<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if ( cwc &gt;= CSampleWordBreaker::cwcAtATime )<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cwc = CSampleWordBreaker::cwcAtATime;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else if ( !fFirstTime )<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;</FONT></P>
<P><FONT face="Courier New" size=1>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; hr = Tokenize( pTextSource, cwc, pWordSink, cwcProcessed );<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if ( FAILED( hr ) )<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return hr;</FONT></P>
<P><FONT face="Courier New" size=1>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pTextSource-&gt;iCur += cwcProcessed;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; fFirstTime = FALSE;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</FONT></P>
<P><FONT face="Courier New" size=1>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; hr = pTextSource-&gt;pfnFillTextBuffer( pTextSource );<BR>&nbsp;&nbsp;&nbsp; } while ( SUCCEEDED( hr ) );</FONT></P>
<P><FONT face="Courier New" size=1>&nbsp;&nbsp;&nbsp; //<BR>&nbsp;&nbsp;&nbsp; // If anything failed except for running out of text, report the error.<BR>&nbsp;&nbsp;&nbsp; // Otherwise, for cases like out of memory, files will not get retried or<BR>&nbsp;&nbsp;&nbsp; // reported as failures properly.<BR>&nbsp;&nbsp;&nbsp; //</FONT></P>
<P><FONT face="Courier New" size=1>&nbsp;&nbsp;&nbsp; if ( ( FAILED( hr ) ) &amp;&amp;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ( FILTER_E_NO_MORE_VALUES != hr ) &amp;&amp;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ( FILTER_E_NO_TEXT != hr ) &amp;&amp;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ( FILTER_E_NO_VALUES != hr ) &amp;&amp;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ( FILTER_E_NO_MORE_TEXT != hr ) &amp;&amp;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ( FILTER_E_END_OF_CHUNKS != hr ) &amp;&amp;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ( FILTER_E_EMBEDDING_UNAVAILABLE != hr ) &amp;&amp;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ( WBREAK_E_END_OF_TEXT != hr ) )<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return hr;</FONT></P>
<P><FONT face="Courier New" size=1>&nbsp;&nbsp;&nbsp; ULONG cwc = pTextSource-&gt;iEnd - pTextSource-&gt;iCur;</FONT></P>
<P><FONT face="Courier New" size=1>&nbsp;&nbsp;&nbsp; if ( 0 == cwc )<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return S_OK;</FONT></P>
<P><FONT face="Courier New" size=1>&nbsp;&nbsp;&nbsp; return Tokenize( pTextSource, cwc, pWordSink, cwcProcessed );<BR>} //BreakText</FONT></P></FONT></BLOCKQUOTE>
<P>The supporting code behind this method (CSampleWordBreaker::Tokenize, ScanChunk, and IsWordChar in particular) are also of interest here if you want to see a working sample. Also note how the code is careful to avoid re-entrancy, which can be a problem so severe that it is probably the best reason to have a sample in the Platform SDK (so we do not find implementations of IWordBreaker in the wild that bring the process to its knees!). </P>
<P>But if you are doing language-specific work, the ability to do the word breaking is huge if you have the information. It is widely believed that the Thai word breaker in Microsoft Word is a bit more sophisticated than the one in <A title=Uniscribe href="http://msdn.microsoft.com/library/en-us/intl/uniscrib_35k5.asp" target=_blank>Uniscribe</A> and GDI+ specifically because it has an extended&nbsp;dictionary behind it (I have never seen the code so I can neither confirm nor deny this). Nadine Kano hints at the problems in her book:</P>
<BLOCKQUOTE dir=ltr>
<H3><FONT size=2>Dividing Lines of Text in Thai</FONT></H3>
<P><FONT size=2>Thai editions of Windows come with a fairly sophisticated line-breaking algorithm. If you are writing a Thai-language application, take advantage of what the system provides rather than trying to come up with your own line-breaking code. To give you an idea of what would be involved, try to decipher the following line:</FONT></P>
<P><FONT size=2>Imaginethatthisisastringtobewordwrappedtheonlywaytodosoinenglishwouldbetoidentifytheindividualwordsandthendeterminethebestplacetobreaktheline</FONT></P>
<P><FONT size=2><B>Translation:</B> Imagine that this is a string to be word-wrapped. The only way to do so in English would be to identify the individual words and then determine the best place to break the line.</FONT></P>
<P><FONT size=2>The line-breaking algorithm provided by the system solves these problems for you.</FONT></P></BLOCKQUOTE>
<P>But if you have&nbsp;better information than what one of Microsoft's word breakers provide then putting in your own word breaker may be just what you (and everyone else) needs! </P>
<P>You may also find&nbsp;a disconnect between components like word breakers for search and Uniscribe at times, and perhaps the word breakers that interest you are the ones that remove this disconnect. Though this is an interesting challenge if you are not the person doing the rendering, or even if you are since they would typically happen at different times. I suspect that even applications like Word cannot do a lot of this sort of thing at the same time given the amount of memory it would take to store the information <EM>just in case</EM> someone wanted to search. </P>
<P>Luckily, many of the Uniscribe methods like <A title=ScriptBreak href="http://msdn.microsoft.com/library/en-us/intl/uniscrib_1dm3.asp" target=_blank>ScriptBreak</A> and ScriptStringBreak can be called independently of the orginal rendering for analysis purposes (more on this another day!).</P>
<P>Next time in the series I'll talk more about the specific language issues that may come up when trying to break and stem streams of text....</P>
<P><FONT size=1></FONT>&nbsp;</P>
<P><FONT color=#ff0000><EM>This post brought to you by</EM> "≈" <EM>(</EM></FONT><EM><FONT color=#ff0000><A href="http://www.fileformat.info/info/unicode/char/2248/index.htm">U+2248</A></FONT></EM><EM><FONT color=#ff0000>, a.k.a. ALMOST EQUAL TO)</FONT></EM></P>
<hr/><p><a id="395259" href="#395259">#</a> <strong>AC</strong> on 14 Mar 2005 8:35 AM:</p><div style="margin-left: 1em">An interesting, if disjointed, post!<br><br>While we wre left wondering how hard it truly is to create the perfect word breaker, the post implies that even the ones Microsoft could you some work. Do you know if any of that work is happening?</div>
<p><a id="395276" href="#395276">#</a> <strong>Michael Kaplan</strong> on 14 Mar 2005 8:51 AM:</p><div style="margin-left: 1em">I honestly do not know what the plans are here, though I plan to keep my eye on places like <a target="_new" href="http://research.microsoft.com/">http://research.microsoft.com/</a> in case they come up with something!<br><br>But you are right that there is much room for future improvement here. And since the architecture is open someone else can do it today if they understand the rules of the language. It is all about getting out of the way.</div>
<p><a id="395535" href="#395535">#</a> <strong>Joseph Petersen</strong> on 14 Mar 2005 3:18 PM:</p><div style="margin-left: 1em">How do you call <a title="Uniscribe" href="http://msdn.microsoft.com/library/en-us/intl/uniscrib_35k5.asp" target="_blank">Uniscribe</a> independent of rendering?</div>
<p><a id="395541" href="#395541">#</a> <strong>Michael Kaplan</strong> on 14 Mar 2005 3:31 PM:</p><div style="margin-left: 1em">Excellent question, Joseph! I'll be talking about this soon!</div>
<p><a id="396560" href="#396560">#</a> <strong>Chrstoph Eisenmann</strong> on 15 Mar 2005 11:04 PM:</p><div style="margin-left: 1em">Hallo &lt;br&gt;&lt;br&gt;You write:&lt;br&gt;&lt;br&gt;Thai editions of Windows come with a fairly sophisticated line-breaking algorithm. If you are writing a Thai-language application, take advantage of what the system provides rather than trying to come up with your own line-breaking code. To give you an idea of what would be involved, try to decipher the following line:&lt;br&gt;&lt;br&gt;...&lt;br&gt;&lt;br&gt;This is my problem. I urgently would need a method which is breaking a thai and laotian sentance into words. I know. It is very complicated, because just seperating by words is not enough. You have also to consider the type of document.&lt;br&gt;&lt;br&gt;The problem is: In thai and laotian where are combined words which make only sence in a document written by laywers, or doctors for example . Take gotmai (the law) the two words make sense independant got mai, but in laywers language they belong together (should not be broken into pieces) otherwise they should.&lt;br&gt;&lt;br&gt;I need a method which uses a&lt;br&gt;&lt;br&gt;- domain specific (like law, medicine) word dictionary first)&lt;br&gt;&lt;br&gt;- a general dictionary (thai) second.&lt;br&gt;&lt;br&gt;- If still no satifying result. Try to break by formula&lt;br&gt;&lt;br&gt;Like said. This would be the best way. But I would be happy with anything which I could use for work breaking. Even (or better because) I am fluent in those languages, I would prefer something which is ready or can be mitified.&lt;br&gt;&lt;br&gt;Can you point me to a direction where I can find some classes, libraries e.t.c. suitable for vb.net (or C#)&lt;br&gt;&lt;br&gt;Thanks for your nice blog. I really like it.&lt;br&gt;&lt;br&gt;Chris&lt;br&gt;&lt;br&gt;Bangkok/Thailand&lt;br&gt;Vietiane/Lao (PDR)&lt;br&gt;</div>
<p><a id="6815539" href="#6815539">#</a> <strong>Tanveer Badar</strong> on 20 Dec 2007 5:11 AM:</p><div style="margin-left: 1em"><p>&quot;There was a guy I used to work with on the Access development team who would dig back into source logs (as far back Access 1.0 if that is what it took) just so he could explain who had introduced a bug.&quot;</p>
<p>That's what I do to get the smelly hat off my head.</p>
</div>
<hr/><p><em>referenced by</em></p><div style="margin-left: 1em"><p>2007/08/12 <a href="http://archives.miloush.net/michkap/archive/2007/08/12/4363488.html">Blast from the [email] past about IWordBreaker</a></p><p>2006/11/12 <a href="http://archives.miloush.net/michkap/archive/2006/11/12/1031784.html">If I wasn't watching her blog, could you really claim I was filtering the list of blogs I read?</a></p><p>2006/08/20 <a href="http://archives.miloush.net/michkap/archive/2006/08/20/707726.html">Avrupalılaştıramadıklarımızdanmışsınızcasına</a></p><p>2005/03/21 <a href="http://archives.miloush.net/michkap/archive/2005/03/21/399589.html">Linguistic and Unicode considerations (or Language-specific Processing #4)</a></p></div><p><em>go to <a id="newer" href="http://archives.miloush.net/michkap/archive/2005/03/15/395684.html" title="Why I didn&#39;t sign the VB6 petition....">newer</a> or <a id="older" href="http://archives.miloush.net/michkap/archive/2005/03/14/395177.html" title="The cat is on the roof">older</a> post, or back to <a href="http://archives.miloush.net/michkap/archive/index.html">index</a> or <a href="http://archives.miloush.net/michkap/archive/index.html#2005-03">month</a> or <a href="http://archives.miloush.net/michkap/archive/index.html#2005-03-14">day</a></em></p></body>
<!-- Mirrored from archives.miloush.net/michkap/archive/2005/03/14/395199.html by HTTrack Website Copier/3.x [XR&CO'2014], Thu, 25 May 2017 00:42:42 GMT -->
</html>