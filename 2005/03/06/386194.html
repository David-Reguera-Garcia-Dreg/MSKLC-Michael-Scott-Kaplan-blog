<html>
<!-- Mirrored from archives.miloush.net/michkap/archive/2005/03/06/386194.html by HTTrack Website Copier/3.x [XR&CO'2014], Thu, 25 May 2017 00:42:42 GMT -->
<head><meta charset="utf-8" /><meta name="viewport" content="width=device-width" /><title>Backcompat is the father of the NLS APIs</title></head><body>
<h1>Backcompat is the father of the NLS APIs</h1>
<p><em>by Michael S. Kaplan, published on 2005/03/06 12:38 -05:00, original URI: http://blogs.msdn.com/b/michkap/archive/2005/03/06/386194.aspx</em></p>
<hr/> <!-- Archival Source: ProcessPostNew -->
<P>A little while back, I was having a conversation with our fearless group's Director, Julie Bennett. Actually, I think maybe she was a Group Manager then, but it is neither here nor there. :-)</P>
<P>I was talking to her because there was a customer who did not like <A title=LCMapString href="http://msdn.microsoft.com/library/en-us/intl/nls_5s2v.asp" target=_blank>LCMapString</A>'s behavior with sort keys. </P>
<P>The API is designed such that if you pass to the API a string and the LCMAP_SORTKEY flag, a binary representation of the string (suitable for use as an index) will be returned. </P>
<P>One of the design principles the API works by when creating sort keys is that it does not touch the target buffer unless</P>
<UL>
<LI>There is, in fact, a target buffer to use, and 
<LI>the API succeeds.</LI></UL>
<P>Unlike even other NLS APIs (e.g. <A title=WideCharToMultiByte href="http://msdn.microsoft.com/library/en-us/intl/unicode_2bj9.asp" target=_blank>WideCharToMultiByte</A> and <A title=MultiByteToWideChar href="http://msdn.microsoft.com/library/en-us/intl/unicode_17si.asp" target=_blank>MultiByteToWideChar</A>), the target buffer is not used as a scratch pad containing&nbsp;the interim&nbsp;results if the API fails during processing so that if there is an error or the size is insufficient it will be left in an unknown state. It is only touched if the end result is "customer ready" and usable. This behavior is true of many other NLS APIs, like <A title=GetLocaleInfo href="http://msdn.microsoft.com/library/en-us/intl/nls_34rz.asp" target=_blank>GetLocaleInfo</A> and <A title=GetNumberFormat href="http://msdn.microsoft.com/library/en-us/intl/nls_8a0k.asp" target=_blank>GetNumberFormat</A>, and <A title=GetDateFormat href="http://msdn.microsoft.com/library/en-us/intl/nls_5w6s.asp" target=_blank>GetDateFormat</A>. Only some of them have the issue with allocation, but most have the behavior of not prematurely touching the target buffer.</P>
<P>The customer was not really happy about that behavior since they <EM>wanted</EM> the target buffer to be used as a scratch pad. They has looked at the disassembly and seen the HeapAlloc calls that were made for larger strings and they were worried about those allocations and wanted them to never happen, for performance reasons. So why couldn't the API just use the target buffer and be done with it?</P>
<P>So I was looking into whether that was feasible. The request made sense and I did not have a specific reason to <EM>not</EM> consider changing it at the time. So why not do a little investigation, right?</P>
<P>I was very surprised at Julie's reaction.</P>
<P>Keep in mind that she had not been doing the development work in this area for years. At this point she was managing the people who were managing the people who managed the people who did&nbsp;this development work. To have this conversation I had to meet with her in the evening after a day full of meetings that included an architect from the Shell team and a VP of something or other. I had seen the movie <A href="http://imdb.com/title/tt0091183/">Head Office</A>&nbsp;where the chairman of the company liked to review individual customers' delinquent phone bills to feel like he was staying connected to the customer, but she&nbsp;is&nbsp;(thankfully!) not that kind of a micro-manager. </P>
<P>I had been getting a bunch of reactions from various people that were mostly the same as my initial gut reaction (a vague sense of unease that it might be a bad idea but no convincing argument against making what seemed like a sensible change to consider).&nbsp;And I thought that as the original author former development owner of these APIs, she might have an opinion. </P>
<P>Boy did she!</P>
<P>She pointed out that the vague sense of unease was probably due to the implicit behavior change that would occur. When you deal with a Windows API there may be hundreds of thousands or more callers with millions of individual calls. One could never predict how one might use an API, and behavior (whether documented or undocumented) was something that would cause users to be broken any time you change it. Now that did not make change impossible, but it&nbsp;<EM>does</EM> minimize&nbsp;change, by necessity. Even when people make calls incorrectly, you have to carefully weigh the benefit of <EM>any</EM> change against both foreseeable/reasonable and unforeseeable/unreason usage.</P>
<P>For example, change to this particular API that must happen includes updates for new languages and occasional bug fixes for old ones. Thankfully&nbsp;the latter&nbsp;is rare and hopefully the former is often. But in any case in order to not break clients who have to depend on sort keys, the collation version APIs (<A href="http://msdn.microsoft.com/library/en-us/intl/nls_19ev.asp" target=_blank>IsNLSDefinedString</A> and <A title=GetNLSVersion href="http://msdn.microsoft.com/library/en-us/intl/nls_5e7i.asp" target=_blank>GetNLSVersion</A>) were added in Windows Server 2003. In that way any client can use a mechanism (like the one I suggested in <A id=CategoryEntryList href="http://archives.miloush.net/michkap/archive/2005/02/03/366145.html">What makes a string <EM>meaningful</EM>?</A>) to allow updates while still working properly. So even when change is deemed worthy a lot of trouble is taken to architect when and how that change is made.</P>
<P>She said in the end there is no way to know what people are doing with our APIs; we only ever&nbsp;get to contact a small minority of the people who work with them. As a a matter of practical necessity the people we <EM>do</EM> talk to are not a representative sample since the type of personality that makes someone seek out public resources for APIs like conferences and newsgroups is not the same as the type that does not. If we change behavior than there is no way to know the full extent of what (or who) we are breaking, but it is a scientific certainty that <EM>someone</EM> will be broken.</P>
<P>I left that meeting with a few thoughts on my mind:</P>
<UL>
<LI>I remembered yet again why I like working for this group -- our fearless leader is a class act (as I have <a href="http://archives.miloush.net/michkap/archive/2005/02/12/371650.html">previously described</A>); 
<LI>I needed to trust that vague sense of unease when I felt it -- my subconscious is much smarter than I am; 
<LI>Even if the old behavior is wrong (and it is really not in this case), changing it is not always the best idea; 
<LI>Perhaps it is just silliness inspired by&nbsp;that scene with "The Architect" in <A href="http://imdb.com/title/tt0234215/">The Matrix Reloaded</A>, but I have to say that if Julie is the mother of the NLS APIs then BackCompat is their father; 
<LI>Backward compatibility trumps sensible changes six days a week and twice on Sunday.</LI></UL>
<P>So how could changes like this one be productively made? Well, there are several different options. Two example options:</P>
<OL>
<LI>A new API -- obviously there is much less backcompat worry in a new API since there is no old behavior issue. Though even in this case documentation about the differences is important since people will bring their old expectations to the new API when there is not a specific reason to set them aside; 
<LI>A new flag to an old API (the known and documented behavior in flags that are invalid is a failure of the API with the <A title=GetLastError href="http://msdn.microsoft.com/library/en-us/debug/base/getlasterror.asp" target=_blank>GetLastError</A> API returning ERROR_INVALID_PARAMETER, and there is a longstanding history of such change in service packs and new versions with adding such flags) -- obviously this also requires careful coordination with doc writers.</LI></OL>
<P>The same rules exist for the .NET Framework, which takes the idea of the problem with breaking changes quite seriously and works with customers to make sure that changes are not made that would break programs.</P>
<P>Armed with this knowledge, a plan can be formulated on what to do. And how best to do it if change must be made.</P>
<P>You may be wondering what will happen for this specific issue, and when? Too early to say, but you know me -- when I can say, I will. </P>
<P>But in the meantime, the next generation of owners of NLS APIs have properly learned the lessons that the previous already knew . And by this, the future of these APIs has been assured. :-)</P>
<P>&nbsp;</P>
<P><FONT color=#ff0000><EM>This post brought to you by </EM>"8"<EM> and </EM>"âˆž"<EM> (<A href="http://www.fileformat.info/info/unicode/char/0038/index.htm">U+0038</A> and <A href="http://www.fileformat.info/info/unicode/char/221e/index.htm">U+221e</A>, a.k.a. DIGIT EIGHT and INFINITY)<BR><FONT size=1>Two characters who are great friends, merely a single best fit mapping away from each other!</FONT></EM></FONT></P>
<hr/><p><a id="386372" href="#386372">#</a> <strong>AC</strong> on 6 Mar 2005 8:14 PM:</p><div style="margin-left: 1em">Aren't there a lot of Win32 APIs that have the same behavior of not stomping on OUT parameters?<br><br>It seems odd to me that you talk about it as if it is an NLS-only feature.</div>
<p><a id="386410" href="#386410">#</a> <strong>Michael Kaplan</strong> on 6 Mar 2005 10:23 PM:</p><div style="margin-left: 1em">I didn't think I had applied that, AC -- if I did then I did not intend to. There are many APIs that do this, both of single small values like handles and for buffers like the NLS functions do.<br><br>In all those cases, I was trying to say it is a bad idea to ever change behavior to something else since one never knows what kind of user code may depend on the old behavior (even if it is not documented).</div>
<hr/><p><em>referenced by</em></p><div style="margin-left: 1em"><p>2008/11/13 <a href="http://archives.miloush.net/michkap/archive/2008/11/13/9065138.html">No need to throw out the baby with the streamwriter; they probably could have just put in a replacement</a></p><p>2006/09/12 <a href="http://archives.miloush.net/michkap/archive/2006/09/12/750218.html">Converting, but not all at once?</a></p><p>2005/10/31 <a href="http://archives.miloush.net/michkap/archive/2005/10/31/486870.html">To Ex or not to Ex? THAT is the question.</a></p><p>2005/04/08 <a href="http://archives.miloush.net/michkap/archive/2005/04/08/406413.html">The ever-misleadingly incorrect usage of the word DEFAULT</a></p><p>2005/03/18 <a href="http://archives.miloush.net/michkap/archive/2005/03/18/398572.html">When is it a backcompat break and when is it fulfilling not-yet-fulfilled technology?</a></p></div><p><em>go to <a id="newer" href="http://archives.miloush.net/michkap/archive/2005/03/07/386452.html" title="A bug with the new oleaut32.dll calendar support and VB, VBA, and VBScript">newer</a> or <a id="older" href="http://archives.miloush.net/michkap/archive/2005/03/05/386026.html" title="TechEd 2005 - I&#39;ll be there!">older</a> post, or back to <a href="http://archives.miloush.net/michkap/archive/index.html">index</a> or <a href="http://archives.miloush.net/michkap/archive/index.html#2005-03">month</a> or <a href="http://archives.miloush.net/michkap/archive/index.html#2005-03-06">day</a></em></p></body>
<!-- Mirrored from archives.miloush.net/michkap/archive/2005/03/06/386194.html by HTTrack Website Copier/3.x [XR&CO'2014], Thu, 25 May 2017 00:42:42 GMT -->
</html>