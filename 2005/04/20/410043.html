<html>
<!-- Mirrored from archives.miloush.net/michkap/archive/2005/04/20/410043.html by HTTrack Website Copier/3.x [XR&CO'2014], Thu, 25 May 2017 00:42:41 GMT -->
<head><meta charset="utf-8" /><meta name="viewport" content="width=device-width" /><title>Encoding APIs and Security Concerns, APIs and Security Decisions</title></head><body>
<h1>Encoding APIs and Security Concerns, APIs and Security Decisions</h1>
<p><em>by Michael S. Kaplan, published on 2005/04/20 11:22 -04:00, original URI: http://blogs.msdn.com/b/michkap/archive/2005/04/20/410043.aspx</em></p>
<hr/> <!-- Archival Source: ProcessPostNew -->
<P><FONT face=Tahoma>The other day I talked about issues with the two big encoding APIs in Win32, in posts <a href="http://archives.miloush.net/michkap/archive/2005/04/18/409095.html"><FONT color=#0000ff><STRONG>A few of the gotchas of WideCharToMultiByte</STRONG></FONT></A>&nbsp;and <a href="http://archives.miloush.net/michkap/archive/2005/04/19/409566.html"><FONT color=#0000ff><STRONG>A few of the gotchas of MultiByteToWideChar</STRONG></FONT></A>.</FONT></P>
<P><FONT face=Tahoma>Both API topics (<A href="http://msdn.microsoft.com/library/en-us/intl/unicode_17si.asp"><STRONG>MultiByteToWideChar</STRONG></A> and <A href="http://msdn.microsoft.com/library/en-us/intl/unicode_2bj9.asp"><STRONG><FONT color=#0000ff>WideCharToMultiByte</FONT></STRONG></A>) include "Security Alert" warnings to which developers should pay heed:</FONT></P>
<BLOCKQUOTE dir=ltr>
<P><FONT face=Tahoma><IMG alt="security note" src="http://msdn.microsoft.com/library/en-us/intl/UI_security_bang_16.gif"></IMG><STRONG> Security Alert</STRONG>&nbsp;&nbsp; Using the <B>WideCharToMultiByte</B> function incorrectly can compromise the security of your application. Calling the <B>WideCharToMultiByte</B> function can easily cause a buffer overrun because the size of the In buffer equals the number of WCHARs in the string, while the size of the Out buffer equals the number of bytes. To avoid a buffer overrun, be sure to specify a buffer size appropriate for the data type the buffer receives. For more information, see </FONT><A href="http://msdn.microsoft.com/library/en-us/intl/sec_intl.asp"><B><FONT face=Tahoma>Security Considerations: International Features</FONT></B></A><FONT face=Tahoma>. </FONT></P>
<P><FONT face=Tahoma><IMG alt="security note" src="http://msdn.microsoft.com/library/en-us/intl/UI_security_bang_16.gif"></IMG><STRONG> Security Alert</STRONG>&nbsp;&nbsp; Using the <B>MultiByteToWideChar</B> function incorrectly can compromise the security of your application. Calling the <B>MultiByteToWideChar</B> function can easily cause a buffer overrun because the size of the In buffer equals the number of bytes in the string, while the size of the Out buffer equals the number of WCHARS. To avoid a buffer overrun, be sure to specify a buffer size appropriate for the data type the buffer receives. For more information, see </FONT><A href="http://msdn.microsoft.com/library/en-us/intl/sec_intl.asp"><B><FONT face=Tahoma>Security Considerations: International Features</FONT></B></A><FONT face=Tahoma>.</FONT></P></BLOCKQUOTE>
<P><FONT face=Tahoma>It seems obvious from the parameter names (cbMultiByte vs. cchWideChar) that one parameter is a count of bytes and the other is a count of characters. But if you mess it up then it is easy to cause a b</FONT><FONT face=Tahoma>uffer overrun as the alerts indicate, which is obviously bad. Another problem that can happen is that the call could fail </FONT><FONT face=Tahoma>due to insufficient buffer size. </FONT></P>
<P><FONT face=Tahoma>Now historically people seem to like calling these APIs without checking the return value. Or alternately they call with a NULL target buffer to get the size, allocate a target buffer based on that size, and then call the API again without checking the return value. </FONT><FONT face=Tahoma>Obviously both of the possible problems can be bad, especially if there is a logic error in the code you use to figure out the buffer allocation (which is usually byte based) and the parameter you then need to pass. You could even allocate buffers twice as large as you need to, which is not a security issue but is at the very least bad practice.</FONT></P>
<P><FONT face=Tahoma>S<FONT face=Tahoma>ince unlike most NLS APIs the target buffer is used even if the API ultimately fails, you may not even notice a problem when you are testing your application -- everything seems like it just works.</FONT></FONT></P>
<P><FONT face=Tahoma>There is another issue which can also lead to security problems. That has to do with whether you either explicitly pass the size of the source buffer or pass -1 to mean that it is&nbsp;null-terminated string.</FONT></P>
<P><FONT face=Tahoma>As the docs indicate:</FONT></P><FONT face=Tahoma>
<BLOCKQUOTE dir=ltr>
<P><FONT size=2><EM>If this parameter is -1, the function processes the entire input string including the null terminator. The resulting wide character string therefore has a null terminator, and the returned length includes the null terminator. </EM></FONT>
<P><FONT size=2><EM>If this parameter is a positive integer, the function processes exactly the specified number of bytes. If the given length does not include a null terminator then the resulting wide character string will not be null terminated, and the returned length does not include a null terminator. </EM></FONT></P></BLOCKQUOTE></FONT>
<P><FONT face=Tahoma>Passing -1 if the source buffer is NULL-terminated is the easiest way to avoid problems. But if may not be NULL-terminated, or you may be trying to convert a substring where the substring may not be NULL terminated even if the full string is. It is crucial to make sure you add the terminating NULL in such cases if you are going to use the resulting string. Or you might be relying on it running through random memory until a NULL is found. </FONT></P>
<P><FONT face=Tahoma>This is a point that may deserve its own security warning, and one that applies to most of the other NLS APIs, too. The semantics of the "-1 for null terminated or the explicit length" source buffer size are very convenient, but a real death trap if used incorrectly, so much so that I would always recommend the following approach:</FONT></P>
<UL>
<LI><FONT face=Tahoma>Use -1 when you can, so the NULL will exist in the result;</FONT> 
<LI><FONT face=Tahoma>Allocate with enough space for the desired target plus room for the NULL, and then make sure to put that NULL in there.</FONT></LI></UL>
<P><FONT face=Tahoma>If you follow those rules consistently for the NLS APIs, you will minimize the chances of subtle problems in your code.</FONT></P>
<P><FONT face=Tahoma>There is a general inconsistency with Win32 APIs about whether returned size parameters include the NULL or not. For the NLS APIs they always do, for USER APIs like GetWindowText they do when you pass NULL to get the size, but they do not when they return the actual desired text. Though on the plus side most of the USER APIs guarantee NULL termination, which the NLS APIs do not. So their subtle bugs (or not so suble bugs if you are looking at the text of a window) are more likely to be one-letter string truncations than actual security concerns like ours.</FONT></P>
<P><FONT face=Tahoma>In general you need to look at the documentation for the API to know the exact behavior, if you do not know what it is. This is a time when the point I made in <A id=_ctl0__ctl0__ctl0__ctl0_BlogSearcher__ctl0_SearchPostList__ctl0_EntryItems__ctl0_PostTitle href="http://archives.miloush.net/michkap/archive/2004/12/19/325199.html"><STRONG>API Consistency and Developer Comfort</STRONG></A>&nbsp;can really come in handy -- if you know in general how a family of APIs work, you can use that knowledge to make good decisions about calling APIs in the family.</FONT></P>
<P><FONT face=Tahoma></FONT>&nbsp;</P>
<P><FONT face=Tahoma><FONT color=#ff0000><EM>This post brought to you by</EM> "à¸’" <EM>(<A href="http://www.fileformat.info/info/unicode/char/0e12/index.htm">U+0e12</A>, a.k.a. THAI CHARACTER THO PHUTHAO)</EM></FONT></FONT></P>
<hr/><p><a id="410066" href="#410066">#</a> <strong>PatriotB</strong> on 20 Apr 2005 10:48 AM:</p><div style="margin-left: 1em">Good posts.  Several years ago I wrote wrapper classes (CTSTR and CBSTR) to encapsulate all the string manipulation that I do, and deep in there are calls to these two functions.  Now would be a great time for me to go back and review them and hopefully see that I'm using them correctly... :)</div>
<p><a id="410104" href="#410104">#</a> <strong>Jeff Parker</strong> on 20 Apr 2005 12:08 PM:</p><div style="margin-left: 1em">You know I do not understand why more Microsoft Documentation doesn't just come out and tell us this when you look up the API. Same in .net the information there shows us how to use it, but it never discuses the proper way or the security risks with using something a certain way.<br><br>For example the memory leak recently discovered in the Enterprise Library that they patched. I didn't even know a memory leak was possible with .net. Once I did a whole lot of digging around I discovered that indeed I had the same memory leak in one of my apps. But you go look at the documentation in msdn on it and no where does it mention using that part of the framework in a specific way could result in a leak. <br><br>Memory Leak info.<br><a rel="nofollow" target="_new" href="http://www.gotdotnet.com/workspaces/news/newsitem.aspx?id=83c68646-befb-4586-ba9f-fdf1301902f5&amp;newsId=87500cd4-1b0a-4fbf-878f-b5f968f50e46">http://www.gotdotnet.com/workspaces/news/newsitem.aspx?id=83c68646-befb-4586-ba9f-fdf1301902f5&amp;newsId=87500cd4-1b0a-4fbf-878f-b5f968f50e46</a><br><br>But thats why we read the blogs for good article like this to make us aware of these problems before they happen.</div>
<p><a id="410155" href="#410155">#</a> <strong>Michael S. Kaplan</strong> on 20 Apr 2005 2:42 PM:</p><div style="margin-left: 1em">In fairness to the docs, all of the issues I mention are documented in the individual functions, even the different USER and NLS functions. What is missing in some cases is the over-arching text that compares and contrasts them, or adds the security context to what is being documented.</div>
<hr/><p><em>referenced by</em></p><div style="margin-left: 1em"><p>2007/09/23 <a href="http://archives.miloush.net/michkap/archive/2007/09/23/5070899.html">If it isn't Unicode, it isn't ANY code!</a></p><p>2006/04/11 <a href="http://archives.miloush.net/michkap/archive/2006/04/11/572943.html">I daresay it is often <= -1</a></p></div><p><em>go to <a id="newer" href="http://archives.miloush.net/michkap/archive/2005/04/21/410305.html" title="Intuitive is in the eye of the beholder">newer</a> or <a id="older" href="http://archives.miloush.net/michkap/archive/2005/04/20/410021.html" title="Upcoming speaking gigs in Cleveland, OH">older</a> post, or back to <a href="http://archives.miloush.net/michkap/archive/index.html">index</a> or <a href="http://archives.miloush.net/michkap/archive/index.html#2005-04">month</a> or <a href="http://archives.miloush.net/michkap/archive/index.html#2005-04-20">day</a></em></p></body>
<!-- Mirrored from archives.miloush.net/michkap/archive/2005/04/20/410043.html by HTTrack Website Copier/3.x [XR&CO'2014], Thu, 25 May 2017 00:42:41 GMT -->
</html>