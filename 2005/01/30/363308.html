<html>
<!-- Mirrored from archives.miloush.net/michkap/archive/2005/01/30/363308.html by HTTrack Website Copier/3.x [XR&CO'2014], Thu, 25 May 2017 00:42:42 GMT -->
<head><meta charset="utf-8" /><meta name="viewport" content="width=device-width" /><title>Why I don't like the IsTextUnicode API</title></head><body>
<h1>Why I don't like the IsTextUnicode API</h1>
<p><em>by Michael S. Kaplan, published on 2005/01/30 02:38 -05:00, original URI: http://blogs.msdn.com/b/michkap/archive/2005/01/30/363308.aspx</em></p>
<hr/> <!-- Archival Source: ProcessPostNew -->
<P>The <A title=IsTextUnicode href="http://msdn.microsoft.com/library/en-us/intl/unicode_81np.asp" target=_blank>IsTextUnicode</A> API has been around since NT 3.5, according to the Platform SDK <A href="http://msdn.microsoft.com/library/en-us/winprog/winprog/windows_nt_3_5.asp">histories</A>. According to the PSDK, its purpose is as follows:</P>
<BLOCKQUOTE dir=ltr>
<P><FONT size=2>The <B>IsTextUnicode</B> function determines whether a buffer is likely to contain a form of Unicode text. The function uses various statistical and deterministic methods to make its determination, under the control of flags passed via <I>lpi</I>. When the function returns, the results of such tests are reported via <I>lpi</I>.</FONT> </P></BLOCKQUOTE>
<P>It then goes on to describe the many different tests that it can do when the appropriate flags are passed:</P>
<P><FONT size=2>IS_TEXT_UNICODE_ASCII16<BR></FONT><FONT size=1>&nbsp;&nbsp;&nbsp;The text is Unicode, and contains only zero-extended ASCII values/characters.</FONT></P>
<P><FONT size=2>IS_TEXT_UNICODE_REVERSE_ASCII16</FONT><BR><FONT size=1>&nbsp;&nbsp;&nbsp;Same as the preceding, except that the Unicode text is byte-reversed.</FONT></P>
<P><FONT size=2>IS_TEXT_UNICODE_STATISTICS</FONT><BR><FONT size=1>&nbsp;&nbsp;&nbsp;The text is probably Unicode, with the determination made by applying statistical analysis. Absolute certainty is not guaranteed. See the following Remarks section.</FONT></P>
<P><FONT size=2>IS_TEXT_UNICODE_REVERSE_STATISTICS</FONT><BR><FONT size=1>&nbsp;&nbsp;&nbsp;Same as the preceding, except that the probably-Unicode text is byte-reversed.</FONT></P>
<P><FONT size=2>IS_TEXT_UNICODE_CONTROLS</FONT><BR><FONT size=1>&nbsp;&nbsp;&nbsp;The text contains Unicode representations of one or more of these nonprinting characters: RETURN, LINEFEED, SPACE, CJK_SPACE, TAB.</FONT></P>
<P><FONT size=2>IS_TEXT_UNICODE_REVERSE_CONTROLS</FONT><BR><FONT size=1>&nbsp;&nbsp;&nbsp;Same as the preceding, except that the Unicode characters are byte-reversed. </FONT></P>
<P><FONT size=2>IS_TEXT_UNICODE_BUFFER_TOO_SMALL</FONT><BR><FONT size=1>&nbsp;&nbsp;&nbsp;There are too few characters in the buffer for meaningful analysis (fewer than two bytes).</FONT></P>
<P><FONT size=2>IS_TEXT_UNICODE_SIGNATURE</FONT><BR><FONT size=1>&nbsp;&nbsp;&nbsp;The text contains the Unicode byte-order mark (BOM) 0xFEFF as its first character.</FONT></P>
<P><FONT size=2>IS_TEXT_UNICODE_REVERSE_SIGNATURE</FONT><BR><FONT size=1>&nbsp;&nbsp;&nbsp;The text contains the Unicode byte-reversed byte-order mark (Reverse BOM) 0xFFFE as its first character.</FONT></P>
<P><FONT size=2>IS_TEXT_UNICODE_ILLEGAL_CHARS</FONT><BR><FONT size=1>&nbsp;&nbsp;&nbsp;The text contains one of these Unicode-illegal characters: embedded Reverse BOM, UNICODE_NUL, CRLF (packed into one WORD), or 0xFFFF.</FONT></P>
<P><FONT size=2>IS_TEXT_UNICODE_ODD_LENGTH</FONT><BR><FONT size=1>&nbsp;&nbsp;&nbsp;The number of characters in the string is odd. A string of odd length cannot (by definition) be Unicode text.</FONT></P>
<P><FONT size=2>IS_TEXT_UNICODE_NULL_BYTES</FONT><BR><FONT size=1>&nbsp;&nbsp;&nbsp;The text contains null bytes, which indicate non-ASCII text.</FONT></P>
<P><FONT size=2>IS_TEXT_UNICODE_UNICODE_MASK</FONT><BR><FONT size=1>&nbsp;&nbsp;&nbsp;This flag constant is a combination of IS_TEXT_UNICODE_ASCII16, IS_TEXT_UNICODE_STATISTICS, IS_TEXT_UNICODE_CONTROLS, IS_TEXT_UNICODE_SIGNATURE.</FONT></P>
<P><FONT size=2>IS_TEXT_UNICODE_REVERSE_MASK</FONT><BR><FONT size=1>&nbsp;&nbsp;&nbsp;This flag constant is a combination of IS_TEXT_UNICODE_REVERSE_ASCII16, IS_TEXT_UNICODE_REVERSE_STATISTICS, IS_TEXT_UNICODE_REVERSE_CONTROLS, IS_TEXT_UNICODE_REVERSE_SIGNATURE.</FONT></P>
<P><FONT size=2>IS_TEXT_UNICODE_NOT_UNICODE_MASK</FONT><BR><FONT size=1>&nbsp;&nbsp;&nbsp;This flag constant is a combination of IS_TEXT_UNICODE_ILLEGAL_CHARS, IS_TEXT_UNICODE_ODD_LENGTH, and two currently unused bit flags. </FONT></P>
<P><FONT size=2>IS_TEXT_UNICODE_NOT_ASCII_MASK</FONT><BR><FONT size=1>&nbsp;&nbsp;&nbsp;This flag constant is a combination of IS_TEXT_UNICODE_NULL_BYTES and three currently unused bit flags.</FONT></P>
<P>Sound impressive and interesting enough yet?</P>
<P><EM><FONT size=2>A bit of trivia -- the code for a flag that used to be documented (IS_TEXT_UNICODE_DBCS_LEADBYTE) is still there (and it is still in the header file, obviously -- the PSDK never breaks people like that). But&nbsp;the flag&nbsp;does not work well, so it is probably just as well that it is not documented any more. I highly recommend not passing it. Or ignoring when it is returned.&nbsp;The flag&nbsp;not dangerous or anything; it's just not too terribly useful for its intended purpose (detecting text that is actually DBCS).</FONT></EM></P>
<P>As I mentioned, the API has been around since NT 3.5. It was written by someone else, outside of the NLS team (such as it was in those days). That is fairly cool since there was not as much Unicode awareness/acceptance back then as there is now....</P>
<P>In those heady days when to most developers&nbsp;Unicode was little more than a foreign word that translated to "<EM>twice the memory and space required for strings</EM>", this function was mostly used as a way to know when to call <A title=WideCharToMultiByte href="http://msdn.microsoft.com/library/en-us/intl/unicode_2bj9.asp" target=_blank>WideCharToMultiByte</A> to know when to convert strings out of Unicode<FONT size=1><SUP>1</SUP></FONT>, and there were very few callers even for that not-so-noble purpose. NT 4.0 did not see much of a usage explosion, although Windows 2000 did , where the number of callers throughout the entire Windows source tree just about tripled (to&nbsp;65 or so callers). Not much movement on the caller side in XP or Server 2003, either. I don't mind this fact much, given why it mostly seemed to be used.</P>
<P>Some time between XP and Server 2003, I did add it to <A title=MSLU href="http://www.microsoft.com/globaldev/handson/dev/mslu_announce.mspx" target=_blank>MSLU</A>, as a nice <A href="http://msdn.microsoft.com/library/en-us/mslu/winprog/unicode_layer_functions_added_to_support_specific_unicode_functionalities.asp">gesture</A> to developers who were frustrated by NT-only APIs<FONT size=1><SUP>2</SUP></FONT>.</P>
<P>Nevertheless, as the title of this post indicates, I don't like the IsTextUnicode API.</P>
<P>You may think you know why -- go ahead, I'll give you three guesses.</P>
<P><STRONG>Guess #1: Because I do not own it?</STRONG> </P>
<P>Sorry, that's not it -- but your opinion about my ego is noted.&nbsp;:-)&nbsp; Strike one!</P>
<P>I'll give you a hint.</P>
<P><STRONG>Hint#1: Look at the Platform SDK description (I'll add emphasis to enhance the hint):</STRONG></P>
<BLOCKQUOTE dir=ltr>
<P><FONT size=2>The <STRONG>IsTextUnicode</STRONG> function determines whether a buffer is likely to contain a form of Unicode text. The function uses <FONT color=#ff0000>various statistical and deterministic methods to make its determination</FONT>, under the control of flags passed via <EM>lpi</EM>. When the function returns, the results of such tests are reported via <EM>lpi</EM>.</FONT> </P></BLOCKQUOTE>
<P><STRONG>Guess #2: Excuse me, I meant because <EM>the NLS team</EM> does not own it?</STRONG> </P>
<P>Hmm, sorry. I figured that was you meant the first time. Strike Two!</P>
<P>I'll give you another hint.</P>
<P><STRONG>Hint #2</STRONG>:&nbsp;There has only been one substantive change made to this API from the time of its creation until Server 2003 shipped -- a <STRONG>const</STRONG> was added to the lpBuffer parameter.</P>
<P>Got it now? Think carefully now, this is your last guess. </P>
<P><STRONG>Guess #3: Because it considers "CRLF (packed into one WORD)" to be&nbsp;illegal, even though </STRONG><A href="http://www.fileformat.info/info/unicode/char/0d0a/index.htm"><STRONG>U+0d0a</STRONG></A><STRONG> is MALAYALAM LETTER UU?</STRONG> </P>
<P>Ooh, good one -- that looks like a bug in the IS_TEXT_UNICODE_ILLEGAL_CHARS flag detection. Even cooler that you properly figured out the byte reversal issue. Or maybe you did not notice that part,&nbsp;since both&nbsp;that ASCII CRLF packed into a WORD and the character&nbsp;would reverse on little-endian systems to look like 0x0a0d in memory, and if you did not allow for byte reversal you would have been right then anyway.</P>
<P>Given the support for Malayalam described previously in the post <A id=_e354926d062d3156_HomePageDays_DaysList__ctl3_DayItem_DayList__ctl1_TitleUrl href="http://archives.miloush.net/michkap/archive/2005/01/26/360685.html">Lions and tigers and <STRIKE>bears</STRIKE>ELKs, Oh my!</A>, this is kind of embarrassing. Or maybe given the fact that the code point has been allocated since Unicode 1.1 (according to <A href="http://www.unicode.org/Public/UNIDATA/DerivedAge.txt">DerivedAge.txt</A>) which was released in June of 1993 (according to <A href="http://www.unicode.org/versions/enumeratedversions.html#Unicode_1_1_0">enumeratedversions.html</A>), this is particularly embarrassing. Though that does make the comment&nbsp;over its use in the API source pretty amusing:</P>
<P><FONT face="Courier New" size=1>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //&nbsp; The following is not currently a Unicode character<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //&nbsp; but is expected to show up accidentally when reading<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //&nbsp; in ASCII files which use CRLF on a little endian machine.</FONT></P>
<P>If you think about it, most UTF-16 big endian files would be from other operating systems and have just a CR or just an LF for their line breaks, even if they were just ASCII. I guess&nbsp;we know&nbsp;why there is no big-endian check for illegal&nbsp;characters? :-)&nbsp; Makes the whole <FONT size=2>IS_TEXT_UNICODE_ILLEGAL_CHARS</FONT>&nbsp;check weird even if it were not totally busted anyway. </P>
<P>For MSLU fans, yes I ported this bug there as well, though not on purpose. Sorry about that, I am not used to reading code points as reversed bytes....</P>
<P>Of course, since I did not know about this problem before, it can't be why I started this post not liking the API. Hell, if not for this imaginary&nbsp;conversation I put together, I still wouldn't know about it. Lucky for everyone that I have displayed this psychological dysfunction in public and thus cannot be further embarrassed by reporting&nbsp;the bug on it, right? Strike 3!</P>
<P>Or we could call it a foul tip, since you found a decade-old bug and all. Ok, it is still Strike 2. :-)</P>
<P>One more hint:</P>
<P><STRONG>Hint #3</STRONG>: There has been no change to this API's underlying mechanics since at least NT 3.51 (and probably since the original NT 3.5 release).</P>
<P>Any more guesses? </P>
<P><STRONG>Guess #4: Because it only seems to test the first 256 bytes, no matter how big of a string I pass?</STRONG></P>
<P>Well, no. I never cared too much for that one, even before I came to Microsoft. But I never really found a file where it made a difference. It would be nice if someone were to change this, but I wouldn't lose any sleep over it -- so it's definitely not a reason to dislike&nbsp;an API. Strike 3!</P>
<P>Ok, I'll just tell you now. Because as an API intended to verify whether a string is following a standard, it wins an award for its obtusitality. Why on earth would the following not have been added, over the years if not in the initial release?</P>
<P><FONT size=2>IS_TEXT_UNICODE_UNPAIRED_SURROGATES<BR>&nbsp;&nbsp;&nbsp;</FONT><FONT size=1>Since it is invalid to have a high surrogate without a low surrogate following it and a low surrogate not proceeded by a high surrogate, why not detect such non-conformant cases?</FONT></P><FONT size=2>
<P><FONT size=2>IS_TEXT_REVERSE_UNICODE_ILLEGAL_CHARS</FONT><BR><FONT size=1>&nbsp;&nbsp;&nbsp;It seems only fair to round out the checks for UTF-16BE by including the reverse version of this flag, doesn't it?</FONT></P>
<P>IS_TEXT_UNICODE_INVALID_FOR_4_00<BR></FONT><FONT size=1>&nbsp;&nbsp;&nbsp;Obviously new flags could be added for each major version -- what better way to check for what is invalid then to check against an official "valid" list?</FONT></P>
<P><FONT size=2>IS_TEXT_UNICODE_INVALID_SCRIPT_USAGE<BR>&nbsp;&nbsp;&nbsp;</FONT><FONT size=1>There are all kinds of sequences that would indicate bad usage, from combining marks from one script used in an unrelated script to illegal sequences to text with invalid ordering per the canonical combining classes, and so on. </FONT></P>
<P><FONT size=2>IS_TEXT_UNICODE_VALID_UTF8_PER_RFC2799<BR></FONT><FONT size=1>&nbsp;&nbsp;&nbsp;The initial description of UTF-8 in <A href="http://www.ietf.org/rfc/rfc2279.txt">RFC 2279</A>, which I think is the method used by Notepad<SUP>3</SUP>.</FONT></P>
<P><FONT size=2>IS_TEXT_UNICODE_VALID_UTF8_PER_UNICODE<BR>&nbsp;&nbsp;&nbsp;</FONT><FONT size=1>The more strict definition of UTF-8, which disallows surrogate code sequences and other non-shortest forms.</FONT></P>
<P><FONT size=2>IS_TEXT_UNICODE_VALID_UTF32 / IS_TEXT_UNICODE_VALID_REVERSE_UTF32<BR>&nbsp;&nbsp;&nbsp;</FONT><FONT size=1>These flags could be combined with some of the older signature detection flags if a UTF-32 LE or BE signature is found.</FONT></P>
<P><FONT size=2>IS_TEXT_UNICODE_UCS2_32 / IS_TEXT_UNICODE_REVERSE_UCS2_32<BR>&nbsp;&nbsp;&nbsp;</FONT><FONT size=1>Analagous to the IS_TEXT_UNICODE_ASCII16/IS_TEXT_UNICODE_REVERSE_ASCII16 flags, they would detect UTF-32 that looks like it could all be represented as UTF-16 without needing surrogate pairs. </FONT></P>
<P>You get the idea -- Unicode is a dynamic standard, getting more interesting&nbsp;and more complicated all the time, not just for its own sake but in how the platform uses it. How&nbsp;can an API which is written a decade ago and never updated, whose job is to ask "is this flipping buffer full of Unicode text?" ever hope to keep up with such a standard?</P>
<P>&nbsp;</P>
<P><FONT size=1><EM>1 - Notepad being a noteworthy exception to this rule, since it used the API to try to detect when a text file was Unicode without a BOM.</EM></FONT></P>
<P><FONT size=1><EM>2 - Similar to why </EM><A title=BeginUpdateResource href="http://msdn.microsoft.com/library/en-us/winui/winui/windowsuserinterface/resources/introductiontoresources/resourcereference/resourcefunctions/beginupdateresource.asp" target=_blank><EM>BeginUpdateResource</EM></A><EM>, </EM><A title=UpdateResource href="http://msdn.microsoft.com/library/en-us/winui/winui/windowsuserinterface/resources/introductiontoresources/resourcereference/resourcefunctions/updateresource.asp" target=_blank><EM>UpdateResource</EM></A><EM>, and </EM><A title=EndUpdateResource href="http://msdn.microsoft.com/library/en-us/winui/winui/windowsuserinterface/resources/introductiontoresources/resourcereference/resourcefunctions/endupdateresource.asp" target=_blank><EM>EndUpdateResource</EM></A><EM> were added, though I must admit that for the *UpdateResource APIs it was mainly due to the fact that former MSFTie Matt Curland did all the work to make the functions Win9x-friendly. :-)</EM></FONT></P>
<P><FONT size=1><EM>3 - These are the rules that have been used by </EM><A title=MultiByteToWideChar href="http://msdn.microsoft.com/library/en-us/intl/unicode_17si.asp" target=_blank><EM>MultiByteToWideChar</EM></A><EM> in later years. Ironically, the MultiByteToWideChar API is used by Notepad to convert files that it detected as UTF-8 by using RFC 2279 rules, meaning that any illegal sequences will be dropped without so much as a warning. Better keep those </EM></FONT><A href="http://www.unicode.org/reports/tr26/"><FONT size=1><EM>CESU-8</EM></FONT></A><FONT size=1><EM> files away from recent enough versions of Notepad!</EM></FONT></P>
<P>&nbsp;</P>
<P><FONT color=#800080><EM>This post sponsored by out much maligned little brother</EM> "ഊ" <EM>(</EM></FONT><A href="http://www.fileformat.info/info/unicode/char/0d0a/index.htm"><EM><FONT color=#800080>U+0d0a</FONT></EM></A><EM><FONT color=#800080>, a.k.a. MALAYALAM LETTER UU)<BR><FONT size=1>Who, like the rest of the Malayalam script, felt very supported by XPSP2, only to find out that the IsTextUnicode API did not share that opinion....</FONT></FONT></EM></P>
<hr/><p><a id="363518" href="#363518">#</a> <strong>Ken Smith</strong> on 30 Jan 2005 6:39 PM:</p><div style="margin-left: 1em">Any chance if a fix for downlevel platforms? :-)</div>
<p><a id="363524" href="#363524">#</a> <strong>Michael Kaplan</strong> on 30 Jan 2005 7:12 PM:</p><div style="margin-left: 1em">I assume you mean the Malayalam thing, right?<br><br>I'm not sure -- it has been broken since the API was written and nobody ever noticed it before. That might make it a harder sell, especially given the overall limitations in the API....</div>
<p><a id="463572" href="#463572">#</a> <strong>Joel Cairney</strong> on 11 Sep 2005 4:19 AM:</p><div style="margin-left: 1em">Yesterday, Buck Hodges was talking about how TFS Version Control determines a file's encoding: ...</div>
<hr/><p><em>referenced by</em></p><div style="margin-left: 1em"><p>2008/03/25 <a href="http://archives.miloush.net/michkap/archive/2008/03/25/8334796.html">Bush might've still hid the facts, but he can't hide them from Vista SP1/Server 2008 Notepad!</a></p><p>2007/06/28 <a href="http://archives.miloush.net/michkap/archive/2007/06/28/3595757.html">Tell yourself 10 times that you don't own that anymore</a></p><p>2007/06/22 <a href="http://archives.miloush.net/michkap/archive/2007/06/22/3466480.html">Your VC++ files don't support Unicode identifers? Drop a BOM on them!</a></p><p>2007/04/22 <a href="http://archives.miloush.net/michkap/archive/2007/04/22/2239345.html">The Notepad encoding detection issues keep coming up</a></p><p>2006/07/11 <a href="http://archives.miloush.net/michkap/archive/2006/07/11/662342.html">More on that which breaks Windows Notepad</a></p><p>2006/06/22 <a href="http://archives.miloush.net/michkap/archive/2006/06/22/643461.html">Things I [don't] like about blogging</a></p><p>2006/06/14 <a href="http://archives.miloush.net/michkap/archive/2006/06/14/631016.html">Behind 'How to break Windows Notepad'</a></p><p>2005/09/11 <a href="http://archives.miloush.net/michkap/archive/2005/09/11/463437.html">Working hard to detect code pages</a></p><p>2005/01/30 <a href="http://archives.miloush.net/michkap/archive/2005/01/30/363420.html">We broke CharNext/CharPrev (or, bugs found through blogging?)</a></p></div><p><em>go to <a id="newer" href="http://archives.miloush.net/michkap/archive/2005/01/30/363420.html" title="We broke CharNext/CharPrev (or, bugs found through blogging?)">newer</a> or <a id="older" href="http://archives.miloush.net/michkap/archive/2005/01/29/363208.html" title="Every character has a story #5 (U+262b FARSI SYMBOL)">older</a> post, or back to <a href="http://archives.miloush.net/michkap/archive/index.html">index</a> or <a href="http://archives.miloush.net/michkap/archive/index.html#2005-01">month</a> or <a href="http://archives.miloush.net/michkap/archive/index.html#2005-01-30">day</a></em></p></body>
<!-- Mirrored from archives.miloush.net/michkap/archive/2005/01/30/363308.html by HTTrack Website Copier/3.x [XR&CO'2014], Thu, 25 May 2017 00:42:42 GMT -->
</html>