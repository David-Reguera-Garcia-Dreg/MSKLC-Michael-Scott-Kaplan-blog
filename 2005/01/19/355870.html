<html>
<!-- Mirrored from archives.miloush.net/michkap/archive/2005/01/19/355870.html by HTTrack Website Copier/3.x [XR&CO'2014], Thu, 25 May 2017 00:42:42 GMT -->
<head><meta charset="utf-8" /><meta name="viewport" content="width=device-width" /><title>He's dead [keys], Jim.</title></head><body>
<h1>He's dead [keys], Jim.</h1>
<p><em>by Michael S. Kaplan, published on 2005/01/19 02:07 -05:00, original URI: http://blogs.msdn.com/b/michkap/archive/2005/01/19/355870.aspx</em></p>
<hr/> <!-- Archival Source: ProcessPostNew -->
<P>Dead keys? As my friend Cathy likes to say -- they're not dead, and they aren't keys.</P>
<P>A little over a month ago, I pointed out that <A id=ArchiveMonth href="http://archives.miloush.net/michkap/archive/2004/12/17/323257.html">Dead keys are not intuitive</A>. And nothing has changed since then -- they are still not very intuitive. And they're not dead. and they're not keys.</P>
<P>Since then, a man named Naushad asked me a very good questions about dead keys, and I thought I would try to answer it. I'll do it here so that if anyone else has the same question, he or she will get help, too. :-)</P>
<P>Naushad asked....</P>
<BLOCKQUOTE dir=ltr>
<P><EM><FONT size=2>I am working on a unicode keyboard. using <A title=MSKLC href="http://www.microsoft.com/globaldev/tools/msklc.mspx" target=_blank>MSKLC</A>. On top of that I'm using a hook application that modifies the behavior of only a few keys for post processing. </FONT></EM></P>
<P><FONT size=2><EM>What I am experiencing is when I call <A title=ToUnicode href="http://msdn.microsoft.com/library/en-us/winui/winui/windowsuserinterface/userinput/keyboardinput/keyboardinputreference/keyboardinputfunctions/tounicode.asp" target=_blank>ToUnicode</A>() in the hook proc (WH_GETMESSAGE) the dead keys don't work anymore. ToUnicode() works perfect as long as I am not pressing any dead key combinations. <BR><BR>My questions are <BR>1. How to extract unicode chars from a WndProc? I am doing it in <A title=WM_KEYDOWN href="http://msdn.microsoft.com/library/en-us/winui/winui/windowsuserinterface/userinput/keyboardinput/keyboardinputreference/keyboardinputmessages/wm_keydown.asp" target=_blank>WM_KEYDOWN</A> using <A title=GetKeyboardState href="http://msdn.microsoft.com/library/en-us/winui/winui/windowsuserinterface/userinput/keyboardinput/keyboardinputreference/keyboardinputfunctions/getkeyboardstate.asp" target=_blank>GetKeyboardState</A>(), MapVirtualKeyW() and ToUnicode(). It breaks the Dead Keys <BR><BR>2. Is there a special way ToUnicode() is to be used with Dead keys? </EM></FONT></P></BLOCKQUOTE>
<P>This is actually the same problem I faced when I was doing the development work on MSKLC!</P>
<P>You see, MSKLC has a feature that has the job of loading an existing keyboard layout on the system. It requires extensive use of the <A title=ToUnicodeEx href="http://msdn.microsoft.com/library/en-us/winui/winui/windowsuserinterface/userinput/keyboardinput/keyboardinputreference/keyboardinputfunctions/tounicodeex.asp" target=_blank>ToUnicodeEx</A> API (which works identically to the ToUnicode API except it lets you pass in the HKL to use), and I found that ToUnicodeEx did not seem to be handling dead keys very well.</P>
<P>The problem is that the APIs work with the state of the keyboard buffer. So when the user types a dead key and you use the ToUnicode API, the two are combined and thus the next keystroke the user types will no longer work with the given dead key at all. It is working on its own. In MSKLC this meant thousands of calls to ToUnicodeEx that would step all over each other any time there was a deadkey.</P>
<P>There are two ways to work around this:</P>
<P>1) You can keep calling ToUnicode with the same info until it is cleared out and then call it one more time to put the state back where it was if you had never typed anything, or</P>
<P>2) You can load all of the keyboard info ahead of time and then when they type information you can look up in your own info cache what the keystrokes mean, without having to call APIs later. </P>
<P>(Note that solution #2 requires a whole bunch of solution #1 be done ahead of time -- in the extreme case that MSKLC was supporting every dead key had&nbsp;to be tested when combined with every other possible key stroke, to load all possible combinations. But since I was trying to load the whole keyboard layout in order to display it, this was needed anyway -- YMMV.)</P>
<P>One interesting thing about this vis-a-vis MSKLC is that on a keyboard with a half dozen dead keys I was easily making thousands of calls to ToUnicodeEx. But even on slower machines, this code runs pretty fast!</P>
<P>Not a great (well, not an easy) answer, but in the end there is no version of ToUnicode or ToUnicodeEx that does not have this kind of "context sensitive" issue. You have to consider every call to it in the context of other calls (and of key stroke presses) that have (a) happened before and that (b) will happen after.</P>
<P>Think of it as yet another reason that dead keys are troublesome -- they are so non-intuitive that it pollutes surrounding technology and makes various keyboarding APIs behave non-intuitively!</P>
<P><EM><FONT size=2>(Naushad, if you are reading this, then the answer to your second question is that you can't, and that the fact that you think you can is a temporary situation that you should not try to pursue since you are creating a legacy of barely searchable text that can have a bad impact on collation and rendering. There is no "magic character" to use here to get what you are looking for. You will really want, therefore, to abandon the scheme and move into a healthier direction that does not involve dead keys. Truly!)</FONT></EM></P>
<P>&nbsp;</P>
<P><FONT color=#800080><EM>This post brought to you by</EM> "<FONT size=3>Ä„" <EM>(<A href="http://www.fileformat.info/info/unicode/char/0104/index.htm">U+0104</A>, a.k.a. LATIN CAPITAL LETTER A WITH OGONEK)</EM></P></FONT></FONT>
<hr/><p><strong>daniel</strong> on 15 Aug 2008 6:05 PM:</p><div style="margin-left: 1em"><p>Hi,</p>
<p>Could you post a sample of [pseudo]code that implements solution #1 (keep calling tounicode). I don't quite understand what is changed when you call tounicode on a deadkey and why it gets screwed up.</p>
<p>Thanks for the informative post! :)</p></div>
<p><strong>Michael S. Kaplan</strong> on 15 Aug 2008 8:04 PM:</p><div style="margin-left: 1em"><p>Actually, I already have, in blogs like <b><a href="http://archives.miloush.net/michkap/archive/2007/10/27/5717859.html">this one</a></b> and other ones like the series it points to...</p></div>
<p><strong>daniel</strong> on 20 Aug 2008 1:22 AM:</p><div style="margin-left: 1em"><p>Thanks for the linky! I'll take a look :)</p></div>
<hr/><p><em>referenced by</em></p><div style="margin-left: 1em"><p>2006/09/10 <a href="http://archives.miloush.net/michkap/archive/2006/09/10/748775.html">Sometimes you *want* to interfere with the keyboard's state buffer</a></p><p>2006/03/22 <a href="http://archives.miloush.net/michkap/archive/2006/03/22/557606.html">Would some keyboard code samples be helpful?</a></p></div><p><em>go to <a id="newer" href="http://archives.miloush.net/michkap/archive/2005/01/19/356280.html" title="Not all characters are created equal: take SYMBOLS, for example">newer</a> or <a id="older" href="http://archives.miloush.net/michkap/archive/2005/01/18/355210.html" title="The jury will give this string no weight">older</a> post, or back to <a href="http://archives.miloush.net/michkap/archive/index.html">index</a> or <a href="http://archives.miloush.net/michkap/archive/index.html#2005-01">month</a> or <a href="http://archives.miloush.net/michkap/archive/index.html#2005-01-19">day</a></em></p></body>
<!-- Mirrored from archives.miloush.net/michkap/archive/2005/01/19/355870.html by HTTrack Website Copier/3.x [XR&CO'2014], Thu, 25 May 2017 00:42:42 GMT -->
</html>