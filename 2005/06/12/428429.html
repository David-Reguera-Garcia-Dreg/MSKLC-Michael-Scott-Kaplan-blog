<html>
<!-- Mirrored from archives.miloush.net/michkap/archive/2005/06/12/428429.html by HTTrack Website Copier/3.x [XR&CO'2014], Thu, 25 May 2017 00:42:41 GMT -->
<head><meta charset="utf-8" /><meta name="viewport" content="width=device-width" /><title>Browsing the shoals of managed string comparisons</title></head><body>
<h1>Browsing the shoals of managed string comparisons</h1>
<p><em>by Michael S. Kaplan, published on 2005/06/12 21:15 -04:00, original URI: http://blogs.msdn.com/b/michkap/archive/2005/06/12/428429.aspx</em></p>
<hr/> <!-- Archival Source: ProcessPostNew -->
<P><FONT face=Tahoma>It was a little over a month ago that I pointed out that <a href="http://archives.miloush.net/michkap/archive/2005/05/08/415522.html">Similar descriptions does not mean similar methodologies</A>, and I spent a little time comparing many of the Win32, Shell, Shlwapi, CRT, and Kernel methods of doing case-insensitive comparisons. And of course <A href="http://blogs.infosupport.com/raimondb/archive/0001/01/01/267.aspx">some people</A>&nbsp;looked at that topic and saw it as&nbsp;a proof that managed code is the way to go to avoid the confusion over which method to use. </FONT></P>
<P><FONT face=Tahoma>But as I hinted at in <a href="http://archives.miloush.net/michkap/archive/2005/04/14/408116.html">this post</A>, things are not so simple in the managed world that you can really count on all of that confusion going away. So you can think of this post as the manged version of that issue.</FONT></P>
<P><FONT face=Tahoma>First there is the core method, the managed equivalent of <A href="http://msdn.microsoft.com/library/en-us/winui/winui/windowsuserinterface/resources/strings/stringreference/stringfunctions/comparestring.asp">CompareString</A>, the <A href="http://msdn.microsoft.com/library/en-us/cpref/html/frlrfsystemglobalizationcompareinfoclasstopic.asp">CompareInfo</A> class and its <A href="http://msdn.microsoft.com/library/en-us/cpref/html/frlrfsystemglobalizationcompareinfoclasscomparetopic.asp">Compare</A> method. One of the overrides for that method takes a <A href="http://msdn.microsoft.com/library/en-us/cpref/html/frlrfsystemglobalizationcompareoptionsclasstopic.asp">CompareOptions enumeration</A> member that lets you get at the gamut of insensitive operations for case, nonspacing mark, symbol, kana, width, etc., as well as getting to Ordinal (and as of Whidbey post Beta 2, OrdinalIgnoreCase). Since you can do it off of any culture, you have access to using the invariant culture as well.</FONT></P>
<P><FONT face=Tahoma>Then there is the <A href="http://msdn.microsoft.com/library/en-us/cpref/html/frlrfsystemstringclasscomparetopic.asp">String.Compare</A> method,&nbsp;whuch supports a subset of those operations, but some of the methods take a CultureInfo object and others take a <A href="http://msdn2.microsoft.com/library/8d9k4871.aspx">StringComparison enumeration</A> member (many of which give access to the same things a CultureInfo would like InvariantCulture&nbsp;or CurrentCulture, or an OrdinalIgnoreCase comparison.</FONT></P>
<P><FONT face=Tahoma>Of course there is also a <A href="http://msdn.microsoft.com/library/en-us/cpref/html/frlrfsystemstringclasscompareordinaltopic.asp">String.CompareOrdinal</A> method which does the same thing that the <A href="http://msdn2.microsoft.com/library/8d9k4871.aspx">StringComparison enumeration</A> with the Ordinal comparison would do.</FONT></P>
<P><FONT face=Tahoma>I would be remiss if I did not point out the String.ToUpper/String.ToUpperInvariant methods, especially since the first of them has an override that takes a CultureInfo which makes the second one not entirely necessary. Those extra invariant methods were added in Whidbey; I would not have strenuously objected if they had been taken out prior to shipping. :-)</FONT></P>
<P><FONT face=Tahoma>There is also the new <A href="http://msdn2.microsoft.com/library/5hc8kytd(en-us,vs.80).aspx">StringComparer class</A>, which has some interesting remarks in it:</FONT></P><FONT face=Tahoma>
<BLOCKQUOTE dir=ltr>
<P><FONT size=2><EM>You might be confused about how to use the <SPAN class=codeEntityReference><A href="http://msdn2.microsoft.com/library/5hc8kytd(en-us,vs.80).aspx">System.StringComparer</A></SPAN> properties because of a seeming contradiction. The value of each <SPAN class=codeEntityReference><A href="http://msdn2.microsoft.com/library/5hc8kytd(en-us,vs.80).aspx">System.StringComparer</A></SPAN> property is a <SPAN class=codeEntityReference><A href="http://msdn2.microsoft.com/library/5hc8kytd(en-us,vs.80).aspx">System.StringComparer</A></SPAN> object. However, the <SPAN class=codeEntityReference><A href="http://msdn2.microsoft.com/library/5hc8kytd(en-us,vs.80).aspx">System.StringComparer</A></SPAN> class is declared <SPAN class=languageKeyword>abstract</SPAN> (<SPAN class=languageKeyword>MustInherit</SPAN> in Visual Basic), which means its members can only be invoked on an object of a class derived from the <SPAN class=codeEntityReference><A href="http://msdn2.microsoft.com/library/5hc8kytd(en-us,vs.80).aspx">System.StringComparer</A></SPAN> class, but each property is declared <SPAN class=languageKeyword>static</SPAN> (<SPAN class=languageKeyword>Shared</SPAN> in Visual Basic), which means the property can be invoked without first creating a derived class. This appears to be a contradiction.</EM></FONT></P>
<P><FONT size=2><EM>You reason you can call a <SPAN class=codeEntityReference><A href="http://msdn2.microsoft.com/library/5hc8kytd(en-us,vs.80).aspx">System.StringComparer</A></SPAN> property directly is because each property actually returns an instance of an anonymous class that is derived from the <SPAN class=codeEntityReference><A href="http://msdn2.microsoft.com/library/5hc8kytd(en-us,vs.80).aspx">System.StringComparer</A></SPAN> class. Consequently, the type of each property value is the base class of the anonymous class, not the type of the anonymous class itself.</EM></FONT></P></BLOCKQUOTE></FONT>
<P><FONT face=Tahoma>I think I can parse that. But for what it is worth, a StringComparer (which includes properties to get at <A href="http://msdn2.microsoft.com/library/d8e91291(en-us,vs.80).aspx">CurrentCulture</A>, <A href="http://msdn2.microsoft.com/library/zc8091cb(en-us,vs.80).aspx">CurrentCultureIgnoreCase</A>, <A href="http://msdn2.microsoft.com/library/1781h47s(en-us,vs.80).aspx">InvariantCulture</A>, <A href="http://msdn2.microsoft.com/library/z3e2ccx2(en-us,vs.80).aspx">InvariantCultureIgnoreCase</A>, <A href="http://msdn2.microsoft.com/library/bfaw046s(en-us,vs.80).aspx">Ordinal</A>, and <A href="http://msdn2.microsoft.com/library/k13t5kxe(en-us,vs.80).aspx">OrdinalIgnoreCase</A> flavors of itself), could also have been covered by a CompareInfo -- maybe we should have made CompareInfo inherit the <A href="http://msdn2.microsoft.com/library/twxabsb7(en-us,vs.80).aspx">IComparer</A> and <A href="http://msdn2.microsoft.com/library/ms132038(en-us,vs.80).aspx">IEqualityComparer</A>&nbsp;interfaces that the StringComparer brings to the mix? :-)</FONT></P>
<P><FONT face=Tahoma>And every time something takes a CultureInfo for comparisons, it is actually pretty much using that CultureInfo's associated CompareInfo. Which you cannot pass in there most of the time, for reasons of type safety.</FONT></P>
<P><FONT face=Tahoma>Ok, the above will hopefully free people of the illusion of simplicity in managed code. And I did not even get into all of the Hashcode providers, dictionaries, hash tables, and lists that would use these various comparison objects, all of which have to be created in particular ways. I will work on trying to sort some of these out another time, in another post.</FONT></P>
<P><FONT face=Tahoma>For now I will point people at <a href="http://archives.miloush.net/michkap/archive/2005/06/02/424128.html">my&nbsp;post</A> about the new string recommendations, and suggest that everyone&nbsp;take that one simple piece of advice I gave:</FONT></P>
<BLOCKQUOTE dir=ltr>
<P><FONT face=Tahoma>Use appropriate comparison methods.</FONT></P>
<P><FONT face=Tahoma size=4>Use appropriate comparison methods.</FONT></P>
<P><FONT face=Tahoma size=5>Use appropriate comparison methods.</FONT></P>
<P><FONT face=Tahoma size=6>Use appropriate comparison methods.</FONT></P></BLOCKQUOTE>
<P><FONT face=Tahoma>The easy (well, easier at least, I think) principles:</FONT></P>
<UL>
<LI><FONT face=Tahoma>If you are trying to compare symbolic identifiers or operating system objects like filenames or named pipes, use an Ordinal type method (or an OrdinalIgnoreCase type method in Whidbey).</FONT></LI>
<LI><FONT face=Tahoma>If you need appropriate linguistic results that work with the myriad of methods that Unicode supports for entering identically appearing&nbsp;strings, then use either a Culture-based comparison or an Invariant culture-based&nbsp;comparison if you need unchanging results.</FONT></LI>
<LI><FONT face=Tahoma>Be aware of how the comparisons are being done in the technologies you are using, and <EM>do your best to match their behavior</EM>.</FONT></LI></UL>
<P><FONT face=Tahoma>If you can follow those three rules, you will seldom if ever go wrong on using appropriate comparison methods.</FONT></P>
<P><FONT face=Tahoma></FONT>&nbsp;</P>
<P><FONT face=Tahoma><FONT color=#ff0000><EM>This post brought to you by</EM> "¢" <EM>and</EM> "£"&nbsp;</FONT><EM><FONT color=#ff0000>(<A href="http://www.fileformat.info/info/unicode/char/00a2/index.htm">U+00a2</A> and <A href="http://www.fileformat.info/info/unicode/char/00a3/index.htm">U+00a3</A>, a.k.a. CENT SIGN and POUND SIGN)<BR><FONT size=1>(As the saying goes, in for a penny, in for a pound....)</FONT></FONT></EM></FONT></P>
<hr/><p><a id="428712" href="#428712">#</a> <strong>TheMuuj</strong> on 13 Jun 2005 6:35 PM:</p><div style="margin-left: 1em">I looked up this post again just to make sure I was doing the right thing when comparing filenames in Whidbey.  I needed to do a wildcard match on a set of files, and remove those files from a List&lt;string&gt; of filenames.<br><br>I knew it needed to be case-insensitive (unless I plan on porting to Mono on Unix), but for some reason I was worreid that NTFS might use culture-based comparisons for file names.  I do know you've talked about how the case-mappings are stored in the file-system, so I have this gut feeling that using StringComparer.OrdinalIgnoreCase might not be good enough.<br><br>Which leads me to believe that .NET either needs a FileName class that would be similar to its Uri class, or perhaps just a PathComparer that implements IComparer&lt;string&gt; and IEqualityComparer&lt;string&gt;.<br><br>Still, different file systems might behave differently, so I suspect this is impossible to solve 100% of the time, especially if you are comparing relative paths.  What if your files  move from one partition/filesystem to another during the lifetime of the program.  Can you use the same filename comparisons?<br><br>Or am I just worrying too much?</div>
<p><a id="428716" href="#428716">#</a> <strong>Michael S. Kaplan</strong> on 13 Jun 2005 6:51 PM:</p><div style="margin-left: 1em">You are just worrying too much. :-)<br><br>The OrdinalIgnoreCase will give you good behavior for FAT and NTFS. For other file systems the story is not so clean (as you point out), but for the basic ondes it is the way.<br><br>File systems cannot use locale-specific case mappings, or they would be unable to be used between machines, or even between changes to the settngs!</div>
<p><a id="428764" href="#428764">#</a> <strong>TheMuuj</strong> on 13 Jun 2005 9:36 PM:</p><div style="margin-left: 1em">Thanks for giving me the answer I wanted to hear, because I'm the type of person who would put a huge workaround in just to keep an edge case from breaking that would probably not come up in production.<br><br>Knowing that OrdinalIgnoreCase is good enough will stop me from thinking about it too much.</div>
<p><a id="435712" href="#435712">#</a> <strong>Anonymous</strong> on 5 Jul 2005 12:51 PM:</p><div style="margin-left: 1em">Since these immortal words were spoken by the voice of Tim Blaney to Ally Sheedy, I think every...</div>
<p><a id="441367" href="#441367">#</a> <strong>Andy Bantly</strong> on 21 Jul 2005 11:23 AM:</p><div style="margin-left: 1em">This may seem off topic but it is not, just transform your thinking back to a kinder, gentler time. ...  If the MS C Runtime library support for the strxfrm() function took into account sort collation,  eg. dictionary vs. phonebook in some locales, then all things collapse onto themselves and the handy strcmp() wins the string compare battle.  Sort collation is that multicultural blot that developers hate and endusers love.  It is found in the regional settings control panel applet and is fun to dink around with for testing your code.  I believe that strxfrm should tokenize those letters that have multiple incarnations, like the 'ss' verse the german version, into the same token.  Alas, too bad Microsoft is too busy trying to litter the playing field with another programming language.<br>   It may seem like I put this lightly and comically but it is an important subject.  Speed and efficiency have always been the earmarks of sorting and string comparison.  The current implementations of string comparisons in the Platform SDK are overweight and slow and does not always handle sort collation.</div>
<p><a id="441383" href="#441383">#</a> <strong>Michael S. Kaplan</strong> on 21 Jul 2005 11:40 AM:</p><div style="margin-left: 1em">Hi Andy,<br><br>Well, nice flamebait in any case. :-)<br><br>The people writing new programming langugaes are not standing in the way of the people who ar working on collation (me and my team, mostly).<br><br>I am really not sure what you refer to in the last part about what is not handled.<br><br>But your original premise is incorrect -- there is no C runtime function that does it right, linguistically speaking, with as many options and features as the NLS functions provide....</div>
<p><strong>Tanveer Badar</strong> on 21 Dec 2007 2:46 PM:</p><div style="margin-left: 1em"><p>Each use of override is incorrect, it should be overload and use IStemmer for derivatives. :)</p>
</div>
<hr/><p><em>referenced by</em></p><div style="margin-left: 1em"><p>2007/08/31 <a href="http://archives.miloush.net/michkap/archive/2007/08/31/4661705.html">Elegant? Beyond compare...</a></p><p>2005/07/05 <a href="http://archives.miloush.net/michkap/archive/2005/07/05/435709.html">'Need more input, Stephanie!'</a></p></div><p><em>go to <a id="newer" href="http://archives.miloush.net/michkap/archive/2005/06/13/428570.html" title="Using full locales rather than the neutral ones?">newer</a> or <a id="older" href="http://archives.miloush.net/michkap/archive/2005/06/11/428351.html" title="Is it Macau or is it Macao?">older</a> post, or back to <a href="http://archives.miloush.net/michkap/archive/index.html">index</a> or <a href="http://archives.miloush.net/michkap/archive/index.html#2005-06">month</a> or <a href="http://archives.miloush.net/michkap/archive/index.html#2005-06-12">day</a></em></p></body>
<!-- Mirrored from archives.miloush.net/michkap/archive/2005/06/12/428429.html by HTTrack Website Copier/3.x [XR&CO'2014], Thu, 25 May 2017 00:42:41 GMT -->
</html>